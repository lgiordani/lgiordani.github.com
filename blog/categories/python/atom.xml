<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | The digital cat]]></title>
  <link href="http://lgiordani.github.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://lgiordani.github.com/"/>
  <updated>2013-05-06T19:05:03+02:00</updated>
  <id>http://lgiordani.github.com/</id>
  <author>
    <name><![CDATA[Leonardo Giordani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Generators - From Iterators to Cooperative Multitasking - 3]]></title>
    <link href="http://lgiordani.github.com/blog/2013/03/29/python-generators-from-iterators-to-cooperative-multitasking-3/"/>
    <updated>2013-03-29T13:25:00+01:00</updated>
    <id>http://lgiordani.github.com/blog/2013/03/29/python-generators-from-iterators-to-cooperative-multitasking-3</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>In this third issue we move on uncovering how generators can be the foundation of a cooperative multitasking system and show some code that implements it. Before we face this topic we will talk shortly about another interesting use of generators, namely generator expressions chains.</p>

<!--more-->


<h2>Chaining generator expressions</h2>

<p>At PyCon 2008 David M. Beazley, author of “Python Essential Reference”, made a very interesting speech about the use of generators in system administration, in other words where usually more or less complex bash scripts are involved and in particular where long pipe sequences are used.</p>

<p>David starts from the consideration that generators, producing one element at a time, are chainable, that is a generator expression can encompass another generator expression and so on. This way he shows how to write in a very compact and reusable way components that can act as “filters” on a data set, thus following the Unix philosophy of building tools that “do one thing and do it well”, chaining them afterwards to get the needed behaviour.</p>

<p>The slides of this presentation are freely downloadable, so I suggest the interested reader to take a look at it at the following address: <a href="http://www.dabeaz.com/generators-uk/">Generator Tricks for Systems Programmers</a>.</p>

<h2>Microthread: cooperative multitasking</h2>

<p><em>Disclaimer: the concepts and code presented here have been heavily influenced by the Kamaelia project. You can find it <a href="http://www.kamaelia.org">here</a>.</em></p>

<p>Let us move forward to see how (Python) generators allow us to easily build applications based on the concept of cooperative multitasking. I assume the reader is familiar with the concepts of preemption and thread-based multitasking and is aware of the pro and cons of such solutions.</p>

<p><strong>Cooperative multitasking</strong> allows an application to hold the control of the CPU for an arbitrary time lapse, waiting for it to voluntarily release the resource to the scheduler. This is a major break with the modern approach to multitasking, where the scheduler is in charge of stopping and resuming applications without any previous agreement with them.</p>

<p>Since application can now stop on their own initiative every issue related to shared data protection, atomicity and synchronization is greatly simplified if not removed. Applications need however a mechanism to stop running, save their internal state and later resume from the same point.</p>

<p>Generators, indeed, through the <code>yield</code> statement implement this very behaviour, thus they may be used to create a system based on cooperative multitasking, where processes are now called <strong>microthreads</strong> to highlight that they are a lightweight form of thread.</p>

<h4>Microthreads</h4>

<p>Let’s look at a simple implementation of such a system. First of all we need a <code>MicroThread</code> object, i.e. an object that can run simultaneously with other similar objects, but in a cooperative way.</p>

<p>```python
class MicroThread(object):</p>

<pre><code>def main(self):
    while 1:
        yield 1
</code></pre>

<p>```</p>

<p>An instance of this object exposes a <code>main()</code> method that, when called, returns a generator. This latter, at each call of its <code>next()</code> method simply returns <code>1</code>, freezing at the same time its execution just after the <code>yield</code> statement, still inside the infinite while loop.</p>

<p>The object can be directly tested</p>

<p>```bash</p>

<blockquote><blockquote><blockquote><p>mt = MicroThread()
g = mt.main()
g
<generator object main at 0xb74331e4>
g.next()
1
```</p></blockquote></blockquote></blockquote>

<p>To make the object more easily inheritable and extendable we can refactor it a little</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (mthread.py)</span> <a href='/downloads/code/python-generators/mthread.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">MicroThread</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
</span><span class='line'>        <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</span><span class='line'>            <span class="k">yield</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Such changes let us inherit the class and extend it simply by overriding the <code>create()</code> and <code>step()</code> methods; the first is called as soon as <code>main()</code> is called, acting as a delayed initializer, while the second is executed at each call of <code>next()</code>, just before freezing the code with <code>yield</code>. Pay attention that since <code>create()</code> is called inside the generator function, you have to call <code>next()</code> once to run it after the genrator has been created. So the standard workflow with this object is</p>

<p>```python</p>

<h1>Instance the object</h1>

<p>mt = MicroThread()</p>

<h1>Initialize it</h1>

<p>mt.next()</p>

<h1>Loop over it</h1>

<p>mt.next()
mt.next()
...
```</p>

<p>Since <code>main()</code> is a generator function it must act as any generator and signal its exhaustion rising a <code>StopIteration</code> exception. The overridden <code>step()</code> method, thus, may raise this exception at any point (even multiple ones) to terminate the microthread.</p>

<h4>Scheduler</h4>

<p>Now we need a scheduler, i.e. the system component that manages running tasks. While in a true multitasking system the scheduler is a big and complex component, in a cooperative environment it can be rather simple: its job is to execute each task and wait till they give control back. In between a task and the following the scheduler can execute other functions, but its basic workflow is very straightforward. Obviously the scheduler shall handle the <code>StopIteration</code> exception possibly raised by a task, removing it from the list of running microthreads.</p>

<p>The core of the scheduler will be something like the following:</p>

<p>```python
for thread in active_microthreads:</p>

<pre><code>try:
    thread.next()
    scheduled_microthreads.append(thread)
except StopIteration:
    pass
</code></pre>

<p>active_microthreads = scheduled_microthreads
scheduled_microthreads = []
```</p>

<p>This snippet encompasses the behaviour described above. We have two lists, <code>active_microthreads</code> with all the tasks that shall be executed in the current loop and <code>scheduled_microthreads</code> with all the tasks that are goig to be executed in the next loop. At each loop of the scheduler all microthreads in <code>active_microthreads</code> are executed, that is they are granted one execution of their <code>next()</code> function. After this the thread is scheduled again, i.e. it is appended to the <code>scheduled_microthreads</code> list. If the thread raises the <code>StopIteration</code> exception during its execution it is simply not scheduled again. When the <code>active_microthreads</code> list is exhausted the loop ends and the scheduled threads list is transferred in the <code>active_threads</code> one; after this the loop starts again.</p>

<p>So the first implementation of the scheduler is the following:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (scheduler.py)</span> <a href='/downloads/code/python-generators/scheduler.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">Scheduler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">add_microthread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mthread</span><span class="p">):</span>
</span><span class='line'>        <span class="n">g</span> <span class="o">=</span> <span class="n">mthread</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</span><span class='line'>        <span class="n">g</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="p">:</span>
</span><span class='line'>                <span class="k">try</span><span class="p">:</span>
</span><span class='line'>                    <span class="n">thread</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>                    <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thread</span><span class="p">)</span>
</span><span class='line'>                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
</span><span class='line'>                    <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The <code>__init__()</code> method initializes the two internal lists we talked about above. The <code>add_microthread()</code> method allows us to add a microthread to the scheduler; the method calls <code>main()</code> on each microthread we add to obtain its generator, then calls <code>next()</code> once on this latter to initialize it and finally adds it to the list of scheduled tasks.</p>

<p>The scheduler logic is then implemented in the <code>run()</code> method, which executes the above core code in an infinite while loop.</p>

<p>We can test the microthreads and the scheduler with this simple code</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (test_scheduler.py)</span> <a href='/downloads/code/python-generators/test_scheduler.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">mthread</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">scheduler</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">TestMicroThread</span><span class="p">(</span><span class="n">mthread</span><span class="o">.</span><span class="n">MicroThread</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">number</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Number:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span>
</span><span class='line'>        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">mt1</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">mt2</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">mt3</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">ms</span> <span class="o">=</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">Scheduler</span><span class="p">()</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt1</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt2</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Here the <code>TestMicroThread</code> is a microthread but the <code>step()</code> method was reimplemented to print a number and wait 1 second. Three microthreads are instanced and added to the scheduler and the <code>run()</code> method of the scheduler is executed. Not surprisingly the result is the following</p>

<p><code>bash
$ python test_scheduler.py
Number: 1
Number: 2
Number: 3
Number: 1
Number: 2
Number: 3
[...]
</code></p>

<p>The three microthreads are executed in a round-robin fashion, as expected from a cooperative multitasking system.</p>

<p>Note: while all microthreads showed in this article just execute <code>yield 1</code> to freeze the code, <code>yield</code> can return any object, just like the <code>return</code> statement does, and this could be exploited to enhance the communication between microthreads and scheduler.</p>

<h4>Microschedulers</h4>

<p>The scheduler could however be more flexible, specifically it could be converted to a microthread itself. The scheduler, when executed, will return a generator, and each call of its <code>next()</code> method will run one of its microthreads. After this the scheduler will freeze and give control back.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (mscheduler.py)</span> <a href='/downloads/code/python-generators/mscheduler.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">MicroScheduler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">add_microthread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mthread</span><span class="p">):</span>
</span><span class='line'>        <span class="n">g</span> <span class="o">=</span> <span class="n">mthread</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</span><span class='line'>        <span class="n">g</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>                <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="p">:</span>
</span><span class='line'>                <span class="k">try</span><span class="p">:</span>
</span><span class='line'>                    <span class="n">thread</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>                    <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thread</span><span class="p">)</span>
</span><span class='line'>                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
</span><span class='line'>                    <span class="k">pass</span>
</span><span class='line'>                <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It is sufficient to rename <code>run()</code> to <code>main()</code>, to match our arbitrary microthread interface, and add some <code>yield</code> statements. The first <code>yield</code> at the beginning of <code>main()</code> terminates the creation part: this scheduler has no <code>create()</code> method, but if present it should be called here. The second <code>yield</code> is called if the scheduler contains no microthreads, since it has nothing to do. The third <code>yield</code> is called after each loop of the microthread running part.</p>

<p>These little changes allow the scheduler to be run into another scheduler, thus enabling us to create a hierarchy to easily build complex systems. At the same time the scheduler can be used as usual simply calling its <code>next()</code> method in a for loop.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (test_mscheduler.py)</span> <a href='/downloads/code/python-generators/test_mscheduler.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">mthread</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">mscheduler</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">TestMicroThread</span><span class="p">(</span><span class="n">mthread</span><span class="o">.</span><span class="n">MicroThread</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">number</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Number:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span>
</span><span class='line'>        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">mt1</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">mt2</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">mt3</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">ms</span> <span class="o">=</span> <span class="n">mscheduler</span><span class="o">.</span><span class="n">MicroScheduler</span><span class="p">()</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt1</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt2</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">main</span><span class="p">():</span>
</span><span class='line'>    <span class="k">pass</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This example is obviously very simple. However it shows how simple it is to build components of a cooperative system and let them live together in an execution space. Executing the scheduler in a different way, for example inside another generator, new microthreads can also be added live. This allows to instance system components on the fly to manage specific needs, such as incoming service requests.</p>

<h2>Conclusions</h2>

<p>Obviously this sort of multitasking cannot provide an interactive execution like that used on our desktop OS or on a Web server, where human users must receive an immediate feedback of their actions. But for systems where task must simply be simultaneously executed without timing needs cooperative multitasking is a valuable solution, due to its simplicity.</p>

<p>Another interesting scenario is that of a real multitasking system (ruled by threaded code or by the OS itself) where each task is made of small cooperating components. This way putting multiple functionalities inside a single component becomes a breeze; the code of each functionality could also be splitted in several plugins and loaded on demand.</p>

<p>A package that implements cooperative multitasking with generator based microthreads is <a href="http://www.kamaelia.org">Kamaelia</a>, and this article has been heavily inspired by it. Other solutions you can find interesting are <a href="http://pypi.python.org/pypi/greenlet">greenlet</a>, presently the most used microthread Python library that runs on the standard unmodified Python interpreter and <a href="http://www.stackless.com/">Stackless Python</a>, a fork of Python that natively implements microthreads.</p>

<h2>Past articles</h2>

<ul>
<li><a href="/blog/2013/03/25/python-generators-from-iterators-to-cooperative-multitasking">Python Generators - From Iterators to Cooperative Multitasking</a></li>
<li><a href="/blog/2013/03/26/python-generators-from-iterators-to-cooperative-multitasking-2">Python Generators - From Iterators to Cooperative Multitasking 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Generators - From Iterators to Cooperative Multitasking - 2]]></title>
    <link href="http://lgiordani.github.com/blog/2013/03/26/python-generators-from-iterators-to-cooperative-multitasking-2/"/>
    <updated>2013-03-26T14:05:00+01:00</updated>
    <id>http://lgiordani.github.com/blog/2013/03/26/python-generators-from-iterators-to-cooperative-multitasking-2</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>After the recap of the iteration process in Python, in this post we will introduce the concept of generator, which aims to solve some problems that arise from the use of iterators.</p>

<!--more-->


<h2>Generators</h2>

<p>The for construct is generally simple to use and such a loop can be found in almost all programming languages. Its implementation, however, can be problematic in some cases. Let’s look at an example:</p>

<p>```python
def sequence(num):</p>

<pre><code>s = []
i = 0
while i != num:
    s.append(i)
    i += 1
return s
</code></pre>

<p>for i in sequence(5):</p>

<pre><code>print i
</code></pre>

<p>```</p>

<p>At  first sight <code>sequence()</code> seems to be a good function without big defects (for the sake of simplicity error checking has been intentionally omitted - it does not work with negative numbers for example - and the code is intentionally non-pythonic).</p>

<p>The problem concealed in such code is that the function does not execute return until the whole list has been built and until the function returns the loop does not start. Thus when the loop begins the function already processed the whole data set.</p>

<p>While you are building normal sequences of numbers this can be considered irrelevant, even for rather long ones. The problem gets worse when the data set becomes very big or when the creation of an element is very demanding process; in the first case the function might fill the memory, whereas in the second one the whole execution can last a very long time. Both conditions happen even before the loop produces the first element.</p>

<p>The solution can be found in the generation concept: generating, in this context, means producing only one element of the sequence at each function call. This way each call will take the minimum amount of memory and CPU time needed to create the element and the loop will start immediately.</p>

<p>To allow the implementation of such a solution without using global variables generators have been introduced in Python. A <strong>generator</strong> is a special type of iterator, its peculiarity being the way it is built. Aside from this, generators behave the same exact way as iterators.</p>

<p>A generator is built from every function that contains the <strong>yield</strong> statement; <code>yield</code>’s behaviour follows that of the <code>return</code> statement, i.e. it terminates the function returning a value to the caller. But whereas return permanently terminates the function, giving up local variables to the garbage collector, <code>yield</code> freezes the function’s code, allowing a later call to resume execution immediately after <code>yield</code>, with all local variables initialized as they were during the previous execution.</p>

<p>Pay attention to the fact that the first call of a function that contains an <code>yield</code> statement returns a generator immediately, without executing a single line of the function’s code. Since a generator is an iterator it automatically exposes a next() method that, when called, will actually continue the execution of the frozen function.</p>

<p>A simple example of generator is the following:</p>

<p>```python
def dec(num):</p>

<pre><code>x = num
while 1:
    x -= 1
    yield x
</code></pre>

<p>```</p>

<p>```bash</p>

<blockquote><blockquote><blockquote><p>g = dec(8)
g
<generator object dec at 0xb6abbf2c>
```</p></blockquote></blockquote></blockquote>

<p>When executed, the <code>dec()</code> function returns a <strong>generator object</strong> and no lines of code have been executed (i.e. <code>x</code> has not yet been initialized).</p>

<p>As soon as <code>next()</code> is called for the first time <code>x</code> will be initialized with the value passed to the function (8 in the example above) and the infinite loop will start. Inside it the local variable <code>x</code> will be decremented and returned to the caller by <code>yield</code>. This latter will also freeze again the code, holding the internal state, in this case the value of the variable <code>x</code>.</p>

<p>```bash</p>

<blockquote><blockquote><blockquote><p>g.next()
7
g.next()
6
g.next()
5
g.next()
4
```</p></blockquote></blockquote></blockquote>

<p>As you can see the generator <code>g</code> remembers its previous state and acts accordingly.</p>

<p>Since generators are iterators they are allowed to raise the <code>StopIteration</code> exception to signal their exhaustion. In the previous example the <code>dec()</code> function never raises it, thus providing an infinite generator (or infinite iterator).</p>

<p>Another caveat: as for return a function is not limited to one statement, but can contain more than one; obviously the peculiarity of yield makes this scenario rather complex, opening at the same time remarkable possibilities such as that of easily build state machines.</p>

<p>What happens if we call the function again, maybe with a different value of the parameter? We simply obtain a new generator object that is completely independent from the first one, although it behaves the same way.</p>

<p>```bash</p>

<blockquote><blockquote><blockquote><p>f = dec(12)
f
<generator object dec at 0xb72e1cac>
f.next()
11
g.next()
3
f.next()
10
g.next()
2
```</p></blockquote></blockquote></blockquote>

<p>Let’s recap the whole concept. A function containing the <code>yield</code> statement is called generator function and when executed returns a generator object; this is nothing more than a simple iterator, which automatically implements the freeze and resume of the function’s code.</p>

<p>Pay attention to the fact that a generator is an iterator (it exposes <code>next()</code> and <code>__iter__()</code> methods and may raise <code>StopIteration</code>) but the opposite is not always true. A generator is an iterator built by a generator function, i.e. through the use of the <code>yield</code> statement; as explained there are other ways to build iterators.</p>

<p>Back to the <code>sequence()</code> function showed above we can now write it as a generator function and use it to build arbitrarily long sequences and, at the limit, infinite.</p>

<p>```python
def sequence(num):</p>

<pre><code>i = 0
while 1:
    if i == num:
        raise StopIteration
    yield i
    i += 1
</code></pre>

<p><code>
</code>bash</p>

<blockquote><blockquote><blockquote><p>s = sequence(3)
s.next()
0
s.next()
1
s.next()
2
s.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in sequence
StopIteration</p>

<p>for i in sequence(3):
...  print i
...
0
1
2
```</p></blockquote></blockquote></blockquote>

<h2>Generators and iterators</h2>

<p>A question might arise: if generators are iterators why should we use the <code>yield</code>-based method to create them? After all, generator functions are simple to write but not so simple to manage, due to the radically different behaviour from that of standard functions. Wouldn’t it be enough to create an iterable object that at each call of the <code>next()</code> method creates the correct element of the sequence?</p>

<p>The answer is certainly affirmative: everything you can do with generators can be done with standard iterators. There are two caveats, however.</p>

<p>First consideration is about performances: instancing an object and calling its methods is slower than calling a function. Every time you hear talking about performance problems always think about Web services, administration or scientific tools and in general about big amounts of data. Obviously a script that manages a dozen or so files is not noticeably affected by such problems.</p>

<p>Second consideration is about code complexity, since writing a function is simpler than writing an object. Take into account, however, that an iterable object can be enriched by custom methods that make it more flexible than a generator; for instance a <code>reset()</code> method that can restore the object to its initial state.</p>

<h2>Generator expressions</h2>

<p>The two observations above identify the problems that generators can solve in a simpler way than iterators do; one of those problems concerns the processing of long arrays of data.</p>

<p>Every Python programmer uses and hopefully appreciates the elegance of list comprehension. The following code instances with a single line 100 objects of the <code>MyObject</code> class and puts them in a list</p>

<p><code>python
object_list = [MyObject() for i in range(100)]
</code></p>

<p>where the classic code would be</p>

<p>```python
object_list = []
for i in range(100):</p>

<pre><code>object_list.append(MyObject())
</code></pre>

<p>```</p>

<p>Surely it is not a lot of code, but it is less easy to understand immediately and less elegant; less pythonic, in a word. List comprehension, however, being nothing more than an alternative syntax to express the above for loop, suffers from the same problems, particularly from performance issues we talked about earlier. Bitter enemies of list comprehensions are long lists and objects which creation is expensive.</p>

<p>Could we take advantage of generators in this case? Yes, with <strong>generator expressions</strong>. The syntax of such expressions is identical to that of list comprehension, except for the use of round brackets instead of square ones. While list comprehension returns a list, however, a generator expression return a generator, as the name implies. The previous code could thus be written this way</p>

<p><code>python
object_generator = (MyObject() for i in range(100))
</code></p>

<p>where <code>object_generator</code> is a generator like one of those returned by a generator function. This latter form of the code would be</p>

<p>```python
def object_generator_function():</p>

<pre><code>for i in range(100):
    yield MyObject()
</code></pre>

<p>object_generator = object_generator_function()
```</p>

<p>Which is, as happens for list comprehension and for loops, less elegant than its equivalent shortcut syntax. Obviously, returning a generator has all the advantages we described above: after the generator expression has been executed no element has yet been created. That will happen when the generator is consumed by a for loop or a similar construct.</p>

<p>As for list comprehension, generator expressions can encompass a condition in the form</p>

<p><code>python
generator = (expression for i in s if condition).
</code></p>

<p>and can also be directly used as arguments for single-argument functions, using function call brackets to mark the expression.</p>

<p><code>python
afunction(expression for i in s)
</code></p>

<p>There is however no real performance improvement using such a syntax, since the generator is exhausted before passing it to the function, but the syntax is very elegant and compact.</p>

<p>A typical example of this use is that of the so-called <strong>dictionary comprehension</strong>; from two lists of the same length, one of keys and one of values, we can obtain a dictionary with</p>

<p><code>python
d = dict(z for z in zip(keys, values))
</code></p>

<p>since <code>dict()</code> accepts an iterable of <code>(key, value)</code> tuples, which is what the generator with <code>zip()</code> returns.</p>

<h2>Conclusions</h2>

<p>Generators are a very powerful tool, not only because they simplify the creation of iterators, but also for the advantage of delaying the creation of the objects in a list and for the capability of generator functions to interrupt and resume the execution. As we will see in the third post this last feature is the foundation stone of an easy approach to cooperative multitasking.</p>

<h2>Past articles</h2>

<ul>
<li><a href="/blog/2013/03/25/python-generators-from-iterators-to-cooperative-multitasking">Python Generators - From Iterators to Cooperative Multitasking</a></li>
</ul>


<h2>Next articles</h2>

<ul>
<li><a href="/blog/2013/03/29/python-generators-from-iterators-to-cooperative-multitasking-3">Python Generators - From Iterators to Cooperative Multitasking 3</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python generators - from iterators to cooperative multitasking]]></title>
    <link href="http://lgiordani.github.com/blog/2013/03/25/python-generators-from-iterators-to-cooperative-multitasking/"/>
    <updated>2013-03-25T10:41:00+01:00</updated>
    <id>http://lgiordani.github.com/blog/2013/03/25/python-generators-from-iterators-to-cooperative-multitasking</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Python is a language that in 11 years of life has been through a very remarkable development and the introduction of several new features, sometimes borrowed from other languages, sometimes arisen from the needs of developers and heavily discussed before being officially implemented. One of these improvements concerns generators, a concept which can be found in the computer science environment since the 70s; it has been implemented in Python from version 2.2 (2001) and became popular from version 2.3 (2003).</p>

<!--more-->


<p>Generators are a generalization of functions that allow to deal in a more complete and rich way with iterations, repeated executions and in general with everything concerns the program flow. In the last years a concept which was considered obsolete started to spread again, namely that of cooperative multitasking. This concept has been shadowed for some years by the advent of multiprocessing and multithreading but, as happened to interpreted languages and virtual machines, as time passes and contexts change good ideas rise again and prove to be anything but dead.</p>

<p>In the Python world, in particular, numerous solutions have appeared which endorse the use of microthreads: these are parallel execution flows without implicit scheduling as opposed to what happens with traditional processes and threads. The big advantage of such objects is the ease of implementation and management of the multiprogramming code, since all synchronization and data protection problems simply do not exist. On the other hand, their use requires a voluntary scheduling, in other words a system that explicitly acquires and releases system resources.</p>

<p>To start talking about cooperative multitasking in Python, thus, it is imperative to understand generators. This first post reviews the concept of iteration and its implementation.</p>

<h2>Iterations</h2>

<p><strong>Iteration</strong> in Python, like in other languages, is a process ruled by the <strong>for</strong> statement and allows to repeatedly execute a block of code, assigning to a variable a value extracted at each execution from a given ordered set. The simplest case of iteration is the processing of a list of values</p>

<p>``` python
for i in [0,1,2,3]:</p>

<pre><code>print i
</code></pre>

<p>```</p>

<p>In Python, however, iteration is more than simple loop over the elements of an array. The for statement implements a well-defined and nontrivial protocol, which allows to build very complex objects.</p>

<p>To understand the structure of iteration in Python we have to clarify what is the difference between iterable and iterator objects.</p>

<h4>Iterators</h4>

<p>In Python jargon an iterator is an object with the following properties:</p>

<ul>
<li>it contains a <strong>set of data</strong></li>
<li>it exposes the <code>next()</code> method, which returns one of the contained elements at each call. Each element is returned only one time. This method goes through the whole set of data the iterator incorporates. In Python 3 this method has been renamed <code>__next__()</code>.</li>
<li>after the <code>next()</code> method returns the last element any successive call of this method raises the <code>StopIteration</code> exception. This signals that the iterator is exhausted.</li>
<li>it exposes the <code>__iter__()</code> method that returns the iterator itself.</li>
</ul>


<h4>Iterables</h4>

<p>The definition of iterable, on the other hand, is more generic: an iterable is a container of data that exposes either the <code>__getitem__()</code> or the <code>__iter__()</code> methods (or both):</p>

<ul>
<li><code>__getitem__(i)</code> shall return the value at the given position <code>i</code> or raise the <code>IndexError</code> exception if there is no data at that position.</li>
<li><code>__iter__()</code> shall return an iterator on the data contained in the iterable</li>
</ul>


<p>As you can see the <code>__getitem__()</code> method considers the data as an ordered set, which is not always the case; for this reason an iterable may define the two different methods, or both.</p>

<p>From the previous definitions you see that an iterator is also automatically an iterable, since it exposes the <code>__iter__()</code> method that returns an iterator (itself).</p>

<h4>Loop protocol</h4>

<p>Back to the loop syntax from above we can clarify the matter saying that in Python <strong>the for statement expects an iterable as argument</strong>. This means that we can give any object the capability of being used in a for loop, simply exposing one of the two previously mentioned methods, <code>__getitem__()</code> or <code>__iter__()</code>.</p>

<p>Let’s look at an example:</p>

<p>```python
class AnIterator(object):</p>

<pre><code>def __init__(self, value):
    self.value = value

def next(self):
    if self.value &lt;= 0:
        raise StopIteration
    tmp = self.value
    self.value = self.value - 1
    return tmp

def __iter__():
    return self
</code></pre>

<p>```</p>

<p>This object is an iterator since it exposes <code>__iter__()</code>. Its <code>next()</code> method returns the decreasing sequence of integer numbers starting from a given number. Testing it we obtain</p>

<p>```sh</p>

<blockquote><blockquote><blockquote><p>iterator = AnIterator(3)
print iterator.next()
3
print iterator.next()
2
print iterator.next()
1
print iterator.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 7, in next
StopIteration</p>

<p>iterator = AnIterator(3)
for i in iterator:
...     print i
...
3
2
1
```</p></blockquote></blockquote></blockquote>

<p>This execution shows that the iterator can be used in a for loop. Pay attention to the fact that I had to instance twice the class, since the first three calls of next() exhausted the first instance.</p>

<p>Let’s dive a little more inside what happens when the for loop runs. The Python code</p>

<p>```python
for i in iterable:</p>

<pre><code>some_code
</code></pre>

<p>```</p>

<p>is equivalent to</p>

<p>```python
_iter = iterable.<strong>iter</strong>()
while 1:</p>

<pre><code>try:
    i = _iter.next()
except StopIteration:
    break
some_code
</code></pre>

<p>```</p>

<p>The for construct receives here an <strong>iterable</strong> object and calls its <code>__iter__()</code> method, obtaining an <strong>iterator</strong> object; then it calls the <code>next()</code> method of this latter until the <code>StopIteration</code> exception is raised. The actual code is a little different, here simplified for clarity’s sake; if you want to learn more about it check the following addresses</p>

<ul>
<li><a href="http://docs.python.org/2/glossary.html">Python Glossary</a></li>
<li><a href="http://docs.python.org/2/library/functions.html#iter">Built-in iter()</a></li>
<li><a href="http://docs.python.org/2/library/stdtypes.html#typeiter">Iterators and sequences</a></li>
</ul>


<h2>Conclusion</h2>

<p>This first post tried to summarize the loop protocol implemented by the for statement, which is in Python very different from many classic languages. Next post will explore the concept of generator and its Python implementation.</p>

<h2>Next articles</h2>

<ul>
<li><a href="/blog/2013/03/26/python-generators-from-iterators-to-cooperative-multitasking-2">Python Generators - From Iterators to Cooperative Multitasking 2</a></li>
<li><a href="/blog/2013/03/29/python-generators-from-iterators-to-cooperative-multitasking-3">Python Generators - From Iterators to Cooperative Multitasking 3</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
