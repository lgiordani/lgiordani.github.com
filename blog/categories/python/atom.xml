<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | The digital cat]]></title>
  <link href="http://lgiordani.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://lgiordani.com/"/>
  <updated>2014-08-20T15:18:11+02:00</updated>
  <id>http://lgiordani.com/</id>
  <author>
    <name><![CDATA[Leonardo Giordani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python 3 OOP Part 3 - Delegation: composition and inheritance]]></title>
    <link href="http://lgiordani.com/blog/2014/08/20/python-3-oop-part-3-delegation-composition-and-inheritance/"/>
    <updated>2014-08-20T15:00:00+02:00</updated>
    <id>http://lgiordani.com/blog/2014/08/20/python-3-oop-part-3-delegation-composition-and-inheritance</id>
    <content type="html"><![CDATA[<!--more-->


<h2>Previous post</h2>

<p><a href="/blog/2014/08/20/python-3-oop-part-2-classes-and-members">Python 3 OOP Part 2 - Classes and members</a></p>

<h2>The Delegation Run</h2>

<p>If classes are objects what is the difference between types and instances?</p>

<p>When I talk about "my cat" I am referring to a concrete instance of the "cat" concept, which is a <em>subtype</em> of "animal". So, despite being both objects, while types can be <em>specialized</em>, instances cannot.</p>

<p>Usually an object B is said to be a specialization of an object A when:</p>

<ul>
<li>B has all the features of A</li>
<li>B can provide new features</li>
<li>B can perform some or all the tasks performed by A in a different way</li>
</ul>


<p>Those targets are very general and valid for any system and the key to achieve them with the maximum reuse of already existing components is <em>delegation</em>. Delegation means that an object shall perform only what it knows best, and leave the rest to other objects.</p>

<p>Delegation can be implemented with two different mechanisms: <em>composition</em> and <em>inheritance</em>. Sadly, very often only inheritance is listed among the pillars of OOP techniques, forgetting that it is an implementation of the more generic and fundamental mechanism of delegation; perhaps a better nomenclature for the two techniques could be <em>explicit delegation</em> (composition) and <em>implicit delegation</em> (inheritance).</p>

<p>Please note that, again, when talking about composition and inheritance we are talking about focusing on a behavioural or structural delegation. Another way to think about the difference between composition and inheritance is to consider if the object <em>knows</em> who can satisfy your request or if the object <em>is</em> the one that satisfy the request.</p>

<p><strong>Please, please, please do not forget composition</strong>: in many cases, composition can lead to simpler systems, with benefits on maintainability and changeability.</p>

<p>Usually composition is said to be a very generic technique that needs no special syntax, while inheritance and its rules are strongly dependent on the language of choice. Actually, the strong dynamic nature of Python softens the boundary line between the two techniques.</p>

<h2>Inheritance Now</h2>

<p>In Python a class can be declared as an <em>extension</em> of one or more different classes, through the <em>class inheritance</em> mechanism. The child class (the one that inherits) has the same internal structure of the parent class (the one that is inherited), and for the case of multiple inheritance the language has very specific rules to manage possible conflicts or redefinitions among the parent classes. A very simple example of inheritance is</p>

<p>``` python
class SecurityDoor(Door):</p>

<pre><code>pass
</code></pre>

<p>```</p>

<p>where we declare a new class <code>SecurityDoor</code> that, at the moment, is a perfect copy of the <code>Door</code> class. Let us investigate what happens when we access attributes and methods. First we instance the class</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>sdoor = SecurityDoor(1, 'closed')
```</p></blockquote></blockquote></blockquote>

<p>The first check we can do is that class attributes are still global and shared</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>SecurityDoor.colour is Door.colour
True
sdoor.colour is Door.colour
True
```</p></blockquote></blockquote></blockquote>

<p>This shows us that Python tries to resolve instance members not only looking into the class the instance comes from, but also investigating the parent classes. In this case <code>sdoor.colour</code> becomes <code>SecurityDoor.colour</code>, that in turn becomes <code>Door.colour</code>. <code>SecurityDoor</code> <em>is</em> a <code>Door</code>.</p>

<p>If we investigate the content of <code>__dict__</code> we can catch a glimpse of the inheritance mechanism in action</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>sdoor.<strong>dict</strong>
{'number': 1, 'status': 'closed'}
sdoor.<strong>class</strong>.<strong>dict</strong>
mappingproxy({'<strong>doc</strong>': None, '<strong>module</strong>': '<strong>main</strong>'})
Door.<strong>dict</strong>
mappingproxy({'<strong>dict</strong>': <attribute '__dict__' of 'Door' objects>,</p>

<pre><code>'colour': 'yellow',
'open': &lt;function Door.open at 0xb687e224&gt;,
'__init__': &lt;function Door.__init__ at 0xb687e14c&gt;,
'__doc__': None,
'close': &lt;function Door.close at 0xb687e1dc&gt;,
'knock': &lt;classmethod object at 0xb67ff6ac&gt;,
'__weakref__': &lt;attribute '__weakref__' of 'Door' objects&gt;,
'__module__': '__main__',
'paint': &lt;classmethod object at 0xb67ff6ec&gt;})
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>As you can see the content of <code>__dict__</code> for <code>SecurityDoor</code> is very narrow compared to that of <code>Door</code>. The inheritance mechanism takes care of the missing elements by climbing up the classes tree. Where does Python get the parent classes? A class always contains a <code>__bases__</code> tuple that lists them</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>SecurityDoor.<strong>bases</strong>
(<class '__main__.Door'>,)
```</p></blockquote></blockquote></blockquote>

<p>So an example of what Python does to resolve a class method call through the inheritance tree is</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>sdoor.<strong>class</strong>.<strong>bases</strong>[0].<strong>dict</strong>['knock'].<strong>get</strong>(sdoor)
<bound method type.knock of <class '__main__.SecurityDoor'>>
sdoor.knock
<bound method type.knock of <class '__main__.SecurityDoor'>>
```</p></blockquote></blockquote></blockquote>

<p>Please note that this is just an example that does not consider multiple inheritance.</p>

<p>Let us try now to override some methods and attributes. In Python you can <em>override</em> (redefine) a parent class member simply by redefining it in the child class.</p>

<p>``` python
class SecurityDoor(Door):</p>

<pre><code>colour = 'gray'
locked = True

def open(self):
    if not self.locked:
        self.status = 'open'
</code></pre>

<p>```</p>

<p>As you can forecast, the overridden members now are present in the <code>__dict__</code> of the <code>SecurityDoor</code> class</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>SecurityDoor.<strong>dict</strong>
mappingproxy({'<strong>doc</strong>': None,</p>

<pre><code>'__module__': '__main__',
'open': &lt;function SecurityDoor.open at 0xb6fcf89c&gt;,
'colour': 'gray',
'locked': True})
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>So when you override a member, the one you put in the child class is used instead of the one in the parent class simply because the former is found before the latter while climbing the class hierarchy. This also shows you that Python does not implicitly call the parent implementation when you override a method. So, overriding is a way to block implicit delegation.</p>

<p>If we want to call the parent implementation we have to do it explicitly. In the former example we could write</p>

<p>``` python
class SecurityDoor(Door):</p>

<pre><code>colour = 'gray'
locked = True

def open(self):
    if self.locked:
        return
    Door.open(self)
</code></pre>

<p>```</p>

<p>You can easily test that this implementation is working correctly.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>sdoor = SecurityDoor(1, 'closed')
sdoor.status
'closed'
sdoor.open()
sdoor.status
'closed'
sdoor.locked = False
sdoor.open()
sdoor.status
'open'
```</p></blockquote></blockquote></blockquote>

<p>This form of explicit parent delegation is heavily discouraged, however.</p>

<p>The first reason is because of the very high coupling that results from explicitly naming the parent class again when calling the method. <em>Coupling</em>, in the computer science lingo, means to link two parts of a system, so that changes in one of them directly affect the other one, and is usually avoided as much as possible. In this case if you decide to use a new parent class you have to manually propagate the change to every method that calls it. Moreover, since in Python the class hierarchy can be dynamically changed (i.e. at runtime), this form of explicit delegation could be not only annoying but also wrong.</p>

<p>The second reason is that in general you need to deal with multiple inheritance, where you do not know a priori which parent class implements the original form of the method you are overriding.</p>

<p>To solve these issues, Python supplies the <code>super()</code> built-in function, that climbs the class hierarchy and returns the correct class that shall be called. The syntax for calling <code>super()</code> is</p>

<p>``` python
class SecurityDoor(Door):</p>

<pre><code>colour = 'gray'
locked = True

def open(self):
    if self.locked:
        return
    super().open(self)
</code></pre>

<p>```</p>

<p>The output of <code>super()</code> is not exactly the <code>Door</code> class. It returns a <code>super</code> object which representation is <code>&lt;super: &lt;class 'SecurityDoor'&gt;, &lt;SecurityDoor object&gt;&gt;</code>. This object however acts like the parent class, so you can safely ignore its custom nature and use it just like you would do with the <code>Door</code> class in this case.</p>

<h2>Enter the Composition</h2>

<p>Composition means that an object knows another object, and explicitly delegates some tasks to it. While inheritance is implicit, composition is explicit: in Python, however, things are far more interesting than this =).</p>

<p>First of all let us implement classic composition, which simply makes an object part of the other as an attribute</p>

<p>``` python
class SecurityDoor:</p>

<pre><code>colour = 'gray'
locked = True

def __init__(self, number, status):
    self.door = Door(number, status)

def open(self):
    if self.locked:
        return
    self.door.open()

def close(self):
    self.door.close()
</code></pre>

<p>```</p>

<p>The primary goal of composition is to relax the coupling between objects. This little example shows that now <code>SecurityDoor</code> is an <code>object</code> and no more a <code>Door</code>, which means that the internal structure of <code>Door</code> is not copied. For this very simple example both <code>Door</code> and <code>SecurityDoor</code> are not big classes, but in a real system objects can very complex; this means that their allocation consumes a lot of memory and if a system contains thousands or millions of objects that could be an issue.</p>

<p>The composed <code>SecurityDoor</code> has to redefine the <code>colour</code> attribute since the concept of delegation applies only to methods and not to attributes, doesn't it?</p>

<p>Well, no. Python provides a very high degree of indirection for objects manipulation and attribute access is one of the most useful. As you already discovered, accessing attributes is ruled by a special method called <code>__getattribute__()</code> that is called whenever an attribute of the object is accessed. Overriding <code>__getattribute__()</code>, however, is overkill; it is a very complex method, and, being called on every attribute access, any change makes the whole thing slower.</p>

<p>The method we have to leverage to delegate attribute access is <code>__getattr__()</code>, which is a special method that is called whenever the requested attribute is not found in the object. So basically it is the right place to dispatch all attribute and method access our object cannot handle. The previous example becomes</p>

<p>``` python
class SecurityDoor:</p>

<pre><code>locked = True

def __init__(self, number, status):
    self.door = Door(number, status)

def open(self):
    if self.locked:
        return
    self.door.open()

def __getattr__(self, attr):
    return getattr(self.door, attr)
</code></pre>

<p>```</p>

<p>Using <code>__getattr__()</code> blends the separation line between inheritance and composition since after all the former is a form of automatic delegation of every member access.</p>

<p>``` python
class ComposedDoor:</p>

<pre><code>def __init__(self, number, status):
    self.door = Door(number, status)

def __getattr__(self, attr):
    return getattr(self.door, attr)
</code></pre>

<p>```</p>

<p>As this last example shows, delegating every member access through <code>__getattr__()</code> is very simple. Pay attention to <code>getattr()</code> which is different from <code>__getattr__()</code>. The former is a built-in that is equivalent to the dotted syntax, i.e. <code>getattr(obj, 'someattr')</code> is the same as <code>obj.someattr</code>, but you have to use it since the name of the attribute is contained in a string.</p>

<p>Composition provides a superior way to manage delegation since it can selectively delegate the access, even mask some attributes or methods, while inheritance cannot. In Python you also avoid the memory problems that might arise when you put many objects inside another; Python handles everything through its reference, i.e. through a pointer to the memory position of the thing, so the size of an attribute is constant and very limited.</p>

<h2>Movie Trivia</h2>

<p>Section titles come from the following movies: <em>The Cannonball Run (1981)</em>, <em>Apocalypse Now (1979)</em>, <em>Enter the Dragon (1973)</em>.</p>

<h2>Sources</h2>

<p>You will find a lot of documentation in <a href="http://www.reddit.com/r/Python/comments/226ahl/some_links_about_python_oop/">this Reddit post</a>. Most of the information contained in this series come from those sources.</p>

<h2>Feedback</h2>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 3 OOP Part 2 - Classes and members]]></title>
    <link href="http://lgiordani.com/blog/2014/08/20/python-3-oop-part-2-classes-and-members/"/>
    <updated>2014-08-20T14:00:00+02:00</updated>
    <id>http://lgiordani.com/blog/2014/08/20/python-3-oop-part-2-classes-and-members</id>
    <content type="html"><![CDATA[<!--more-->


<h2>Previous post</h2>

<p><a href="/blog/2014/08/20/python-3-oop-part-1-objects-and-types">Python 3 OOP Part 1 - Objects and types</a></p>

<h2>Python Classes Strike Again</h2>

<p>The Python implementation of classes has some peculiarities. The bare truth is that in Python the class of an object is an object itself. You can check this by issuing <code>type()</code> on the class</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>a = 1
type(a)
<class 'int'>
type(int)
<class 'type'>
```</p></blockquote></blockquote></blockquote>

<p>This shows that the <code>int</code> class is an object, an instance of the <code>type</code> class.</p>

<p>This concept is not so difficult to grasp as it can seem at first sight: in the real world we deal with <em>concepts</em> using them like <em>things</em>: for example we can talk about the concept of "door", telling people how a door looks like and how it works. In this case the concept of door is the topic of our discussion, so in our everyday experience the <em>type</em> of an object is an object itself. In Python this can be expressed by saying that <em>everything is an object</em>.</p>

<p>If the class of an object is itself an instance it is a concrete object and is stored somewhere in memory. Let us leverage the <em>inspection</em> capabilities of Python and its <code>id()</code> function to check the status of our objects. The <code>id()</code> built-in function returns the memory position of an object.</p>

<p>In the first post we defined this class</p>

<p>``` python
class Door:</p>

<pre><code>def __init__(self, number, status):
    self.number = number
    self.status = status

def open(self):
    self.status = 'open'

def close(self):
    self.status = 'closed'
</code></pre>

<p>```</p>

<p>First of all, let's create two instances of the <code>Door</code> class and check that the two objects are stored at different addresses</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1 = Door(1, 'closed')
door2 = Door(1, 'closed')
hex(id(door1))
'0xb67e148c'
hex(id(door2))
'0xb67e144c'
```</p></blockquote></blockquote></blockquote>

<p>This confirms that the two instances are separate and unrelated.
<strong>Please note that your values are very likely to be different from the ones I got. Being memory addresses they change at every execution.</strong> The second instance was given the same attributes of the first instance to show that the two are different objects regardless of the value of the attributes.</p>

<p>However if we use <code>id()</code> on the class of the two instances we discover that the class is <em>exactly</em> the same</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>hex(id(door1.<strong>class</strong>))
'0xb685f56c'
hex(id(door2.<strong>class</strong>))
'0xb685f56c'
```</p></blockquote></blockquote></blockquote>

<p>Well this is very important. In Python, a class is not just the schema used to build an object. Rather, the class is a shared living object, which code is accessed at run time.</p>

<p>As we already tested, however, attributes are not stored in the class but in every instance, due to the fact that <code>__init__()</code> works on <code>self</code> when creating them. Classes, however, can be given attributes like any other object; with a terrific effort of imagination, let's call them <em>class attributes</em>.</p>

<p>As you can expect, class attributes are shared among the class instances just like their container</p>

<p>``` python
class Door:</p>

<pre><code>colour = 'brown'

def __init__(self, number, status):
    self.number = number
    self.status = status

def open(self):
    self.status = 'open'

def close(self):
    self.status = 'closed'
</code></pre>

<p>```</p>

<p>Pay attention: the <code>colour</code> attribute here is not created using <code>self</code>, so it is contained in the class and shared among instances</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1 = Door(1, 'closed')
door2 = Door(2, 'closed')
Door.colour
'brown'
door1.colour
'brown'
door2.colour
'brown'
```</p></blockquote></blockquote></blockquote>

<p>Until here things are not different from the previous case. Let's see if changes of the shared value reflect on all instances</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>Door.colour = 'white'
Door.colour
'white'
door1.colour
'white'
door2.colour
'white'
hex(id(Door.colour))
'0xb67e1500'
hex(id(door1.colour))
'0xb67e1500'
hex(id(door2.colour))
'0xb67e1500'
```</p></blockquote></blockquote></blockquote>

<h2>Raiders of the Lost Attribute</h2>

<p>Any Python object is automatically given a <code>__dict__</code> attribute, which contains its list of attributes. Let's investigate what this dictionary contains for our example objects:</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>Door.<strong>dict</strong>
mappingproxy({'open': <function Door.open at 0xb68604ac>,</p>

<pre><code>'colour': 'brown',
'__dict__': &lt;attribute '__dict__' of 'Door' objects&gt;,
'__weakref__': &lt;attribute '__weakref__' of 'Door' objects&gt;,
'__init__': &lt;function Door.__init__ at 0xb7062854&gt;,
'__module__': '__main__',
'__doc__': None,
'close': &lt;function Door.close at 0xb686041c&gt;})
</code></pre>

<p>door1.<strong>dict</strong>
{'number': 1, 'status': 'closed'}
```</p></blockquote></blockquote></blockquote>

<p>Leaving aside the difference between a dictionary and a <code>mappingproxy</code> object, you can see that the <code>colour</code> attribute is listed among the <code>Door</code> class attributes, while <code>status</code> and <code>number</code> are listed for the instance.</p>

<p>How comes that we can call <code>door1.colour</code>, if that attribute is not listed for that instance? This is a job performed by the magic <code>__getattribute__()</code> method; in Python the dotted syntax automatically invokes this method so when we write <code>door1.colour</code>, Python executes <code>door1.__getattribute__('colour')</code>. That method performs the  <em>attribute  lookup</em> action, i.e. finds the value of the attribute by looking in different places.</p>

<p>The standard implementation of <code>__getattribute__()</code> searches first the internal dictionary (<code>__dict__</code>) of an object, then the type of the object itself; in this case <code>door1.__getattribute__('colour')</code> executes first <code>door1.__dict__['colour']</code> and then, since the latter raises a <code>KeyError</code> exception, <code>door1.__class__.__dict__['colour']</code></p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.<strong>dict</strong>['colour']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'colour'
door1.<strong>class</strong>.<strong>dict</strong>['colour']
'brown'
```</p></blockquote></blockquote></blockquote>

<p>Indeed, if we compare the objects' equality through the <code>is</code> operator we can confirm that both <code>door1.colour</code> and <code>Door.colour</code> are exactly the same object</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.colour is Door.colour
True
```</p></blockquote></blockquote></blockquote>

<p>When we try to assign a value to a class attribute directly on an instance, we just put in the <code>__dict__</code> of the instance a value with that name, and this value masks the class attribute since it is found first by <code>__getattribute__()</code>. As you can see from the examples of the previous section, this is different from changing the value of the attribute on the class itself.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.colour = 'white'
door1.<strong>dict</strong>['colour']
'white'
door1.<strong>class</strong>.<strong>dict</strong>['colour']
'brown'
Door.colour = 'red'
door1.<strong>dict</strong>['colour']
'white'
door1.<strong>class</strong>.<strong>dict</strong>['colour']
'red'
```</p></blockquote></blockquote></blockquote>

<h2>Revenge of the Methods</h2>

<p>Let's play the same game with methods. First of all you can see that, just like class attributes, methods are listed only in the class <code>__dict__</code>. Chances are that they behave the same as attributes when we get them</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.open is Door.open
False
```</p></blockquote></blockquote></blockquote>

<p>Whoops. Let us further investigate the matter</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>Door.<strong>dict</strong>['open']
<function Door.open at 0xb68604ac>
Door.open
<function Door.open at 0xb68604ac>
door1.open
<bound method Door.open of <__main__.Door object at 0xb67e162c>>
```</p></blockquote></blockquote></blockquote>

<p>So, the class method is listed in the members dictionary as <em>function</em>. So far, so good. The same happens when taking it directly from the class; here Python 2 needed to introduce <em>unbound methods</em>, which are not present in Python 3. Taking it from the instance returns a <em>bound method</em>.</p>

<p>Well, a <em>function</em> is a procedure you named and defined with the <code>def</code> statement. When you refer to a function as part of a class in Python 3 you get a plain function, without any difference from a function defined outside a class.</p>

<p>When you get the function from an instance, however, it becomes a bound method. The name <em>method</em> simply means "a function inside an object", according to the usual OOP definitions, while <em>bound</em> signals that the method is linked to that instance. Why does Python bother with methods being bound or not? And how does Python transform a function into a bound method?</p>

<p>First of all, if you try to call a class function you get an error</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>Door.open()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: open() missing 1 required positional argument: 'self'
```</p></blockquote></blockquote></blockquote>

<p>Yes. Indeed the function was defined to require an argument called 'self', and calling it without an argument raises an exception. This perhaps means that we can give it one instance of the class and make it work</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>Door.open(door1)
door1.status
'open'
```</p></blockquote></blockquote></blockquote>

<p>Python does not complain here, and the method works as expected. So <code>Door.open(door1)</code> is the same as <code>door1.open()</code>, and this is the difference between a plain function coming from a class an a bound method: the bound method automatically passes the instance as an argument to the function.</p>

<p>Again, under the hood, <code>__getattribute__()</code> is working to make everything work and when we call <code>door1.open()</code>, Python actually calls <code>door1.__class__.open(door1)</code>. However, <code>door1.__class__.open</code> is a plain function, so there is something more that converts it into a bound method that Python can safely call.</p>

<p>When you access a member of an object, Python calls <code>__getattribute__()</code> to satisfy the request. This magic method, however, conforms to a procedure known as <em>descriptor protocol</em>. For the read access <code>__getattribute__()</code> checks if the object has a <code>__get__()</code> method and calls this latter. So the converstion of a function into a bound method happens through such a mechanism. Let us review it by means of an example.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.<strong>class</strong>.<strong>dict</strong>['open']
<function Door.open at 0xb68604ac>
```</p></blockquote></blockquote></blockquote>

<p>This syntax retrieves the function defined in the class; the function knows nothing about objects, but it <em>is</em> an object (remember "everything is an object"). So we can look inside it with the <code>dir()</code> built-in function</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>dir(door1.<strong>class</strong>.<strong>dict</strong>['open'])
['<strong>annotations</strong>', '<strong>call</strong>', '<strong>class</strong>', '<strong>closure</strong>', '<strong>code</strong>',
 '<strong>defaults</strong>', '<strong>delattr</strong>', '<strong>dict</strong>', '<strong>dir</strong>', '<strong>doc</strong>', '<strong>eq</strong>',
 '<strong>format</strong>', '<strong>ge</strong>', '<strong>get</strong>', '<strong>getattribute</strong>', '<strong>globals</strong>',
 '<strong>gt</strong>', '<strong>hash</strong>', '<strong>init</strong>', '<strong>kwdefaults</strong>', '<strong>le</strong>', '<strong>lt</strong>',
 '<strong>module</strong>', '<strong>name</strong>', '<strong>ne</strong>', '<strong>new</strong>', '<strong>qualname</strong>', '<strong>reduce</strong>',
 '<strong>reduce_ex</strong>', '<strong>repr</strong>', '<strong>setattr</strong>', '<strong>sizeof</strong>', '<strong>str</strong>',
 '<strong>subclasshook</strong>']
door1.<strong>class</strong>.<strong>dict</strong>['open'].<strong>get</strong>
&lt;method-wrapper '<strong>get</strong>' of function object at 0xb68604ac>
```</p></blockquote></blockquote></blockquote>

<p>As you can see, a <code>__get__</code> method is listed among the members of the function, and Python recognizes it as a <em>method-wrapper</em>. This method shall connect the <code>open</code> function to the <code>door1</code> instance, so we can call it passing the instance alone</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.<strong>class</strong>.<strong>dict</strong>['open'].<strong>get</strong>(door1)
<bound method Door.open of <__main__.Door object at 0xb67e162c>>
```</p></blockquote></blockquote></blockquote>

<p>and we get exactly what we were looking for. This complex syntax is what happens behind the scenes when we call a method of an instance.</p>

<h2>When Methods met Classes</h2>

<p>Using <code>type()</code> on functions defined inside classes reveals some other details on their internal representation</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>Door.open
<function Door.open at 0xb687e074>
door1.open
<bound method Door.open of <__main__.Door object at 0xb6f9834c>>
type(Door.open)
<class 'function'>
type(door1.open)
<class 'method'>
```</p></blockquote></blockquote></blockquote>

<p>As you can see, Python tells the two apart recognizing the first as a <em>function</em> and the second as a <em>method</em>, where the second is a function bound to an instance.</p>

<p>What if we want to define a function that operates on the class instead of operating on the instance? As we may define class attributes, we may also define <em>class methods</em> in Python, through the <code>classmethod</code> decorator. Class methods are functions that are bound to the class and not to an instance.</p>

<p>``` python
class Door:</p>

<pre><code>colour = 'brown'

def __init__(self, number, status):
    self.number = number
    self.status = status

@classmethod
def knock(cls):
    print("Knock!")

def open(self):
    self.status = 'open'

def close(self):
    self.status = 'closed'
</code></pre>

<p>```</p>

<p>Such a definition makes the method callable on both the instance and the class</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.knock()
Knock!
Door.knock()
Knock!
```</p></blockquote></blockquote></blockquote>

<p>and Python identifies both as (bound) methods</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.<strong>class</strong>.<strong>dict</strong>['knock']
<classmethod object at 0xb67ff6ac>
door1.knock
<bound method type.knock of <class '__main__.Door'>>
Door.knock
<bound method type.knock of <class '__main__.Door'>>
type(Door.knock)
<class 'method'>
type(door1.knock)
<class 'method'>
```</p></blockquote></blockquote></blockquote>

<p>As you can see the <code>knock()</code> function accepts one argument, which is called <code>cls</code> just to remember that it is not an instance but the class itself. This means that inside the function we can operate on the class, and the class is shared among instances.</p>

<p>``` python
class Door:</p>

<pre><code>colour = 'brown'

def __init__(self, number, status):
    self.number = number
    self.status = status

@classmethod
def knock(cls):
    print("Knock!")

@classmethod
def paint(cls, colour):
    cls.colour = colour

def open(self):
    self.status = 'open'

def close(self):
    self.status = 'closed'
</code></pre>

<p>```</p>

<p>The <code>paint()</code> classmethod now changes the class attribute <code>colour</code> which is shared among instances. Let's check how it works</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1 = Door(1, 'closed')
door2 = Door(2, 'closed')
Door.colour
'brown'
door1.colour
'brown'
door2.colour
'brown'
Door.paint('white')
Door.colour
'white'
door1.colour
'white'
door2.colour
'white'
```</p></blockquote></blockquote></blockquote>

<p>The class method can be called on the class, but this affects both the class and the instances, since the <code>colour</code> attribute of instances is taken at runtime from the shared class.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.paint('yellow')
Door.colour
'yellow'
door1.colour
'yellow'
door2.colour
'yellow'
```</p></blockquote></blockquote></blockquote>

<p>Class methods can be called on instances too, however, and their effect is the same as before. The class method is bound to the class, so it works on this latter regardless of the actual object that calls it (class or instance).</p>

<h2>Movie Trivia</h2>

<p>Section titles come from the following movies: <em>The Empire Strikes Back (1980)</em>, <em>Raiders of the Lost Ark (1981)</em>, <em>Revenge of the Nerds (1984)</em>, <em>When Harry Met Sally (1989)</em>.</p>

<h2>Sources</h2>

<p>You will find a lot of documentation in <a href="http://www.reddit.com/r/Python/comments/226ahl/some_links_about_python_oop/">this Reddit post</a>. Most of the information contained in this series come from those sources.</p>

<h2>Feedback</h2>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>

<h2>Next post</h2>

<p><a href="/blog/2014/08/20/python-3-oop-part-3-delegation-composition-and-inheritance">Python 3 OOP Part 3 - Delegation: composition and inheritance</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 3 OOP Part 1 - Objects and types]]></title>
    <link href="http://lgiordani.com/blog/2014/08/20/python-3-oop-part-1-objects-and-types/"/>
    <updated>2014-08-20T13:00:00+02:00</updated>
    <id>http://lgiordani.com/blog/2014/08/20/python-3-oop-part-1-objects-and-types</id>
    <content type="html"><![CDATA[<!--more-->


<h2>About this series</h2>

<p>Object-oriented programming (OOP) has been the leading programming paradigm for several decades now, starting from the initial attempts back in the 60s to some of the most important languages used nowadays. Being a set of programming concepts and design methodologies, OOP can never be said to be "correctly" or "fully" implemented by a language: indeed there are as many implementations as languages.</p>

<p>So one of the most interesting aspects of OOP languages is to understand how they implement those concepts. In this post I am going to try and start analyzing the OOP implementation of the Python language. Due to the richness of the topic, however, I consider this attempt just like a set of thoughts for Python beginners trying to find their way into this beautiful (and sometimes peculiar) language.</p>

<p>This series of posts wants to introduce the reader to the Python 3 implementation of Object Oriented Programming concepts. The content of this and the following posts will not be completely different from that of the previous "OOP Concepts in Python 2.x" series, however. The reason is that while some of the internal structures change a lot, the global philosophy doesn't, being Python 3 an <em>evolution</em> of Python 2 and not a new language.</p>

<p>So I chose to split the previous series and to adapt the content to Python 3 instead of posting a mere list of corrections. I find this way to be more useful for new readers, that otherwise sould be forced to read the previoous series.</p>

<h3>Print</h3>

<p>One of the most noticeable changes introduced by Python 3 is the transformation of the <code>print</code> keyword into the <code>print()</code> function. This is indeed a very small change, compared to other modifications made to the internal structures, but is the most visual-striking one, and will be the source of 80% of your syntax errors when you will start writing Python 3 code.</p>

<p>Remember that print is now a function so write <code>print(a)</code> and not <code>print a</code>.d</p>

<h2>Back to the Object</h2>

<p>Computer science deals with data and with procedures to manipulate that data. Everything, from the earliest Fortran programs to the latest mobile apps is about data and their manipulation.</p>

<p>So if data are the ingredients and procedures are the recipes, it seems (and can be) reasonable to keep them separate.</p>

<p>Let's do some procedural programming in Python</p>

<p>``` python</p>

<h1>This is some data</h1>

<p>data = (13, 63, 5, 378, 58, 40)</p>

<h1>This is a procedure that computes the average</h1>

<p>def avg(d):</p>

<pre><code>return sum(d)/len(d)
</code></pre>

<p>print(avg(data))
```</p>

<p>As you can see the code is quite good and general: the procedure (function) operates on a sequence of data, and it returns the average of the sequence items. So far, so good: computing the average of some numbers leaves the numbers untouched and creates new data.</p>

<p>The observation of the everyday world, however, shows that <em>complex data mutate</em>: an electrical device is on or off, a door is open or closed, the content of a bookshelf in your room changes as you buy new books.</p>

<p>You can still manage it keeping data and procedures separate, for example</p>

<p>``` python</p>

<h1>These are two numbered doors, initially closed</h1>

<p>door1 = [1, 'closed']
door2 = [2, 'closed']</p>

<h1>This procedure opens a door</h1>

<p>def open_door(door):</p>

<pre><code>door[1] = 'open'
</code></pre>

<p>open_door(door1)
print(door1)
```</p>

<p>I described a door as a structure containing a number and the status of the door (as you would do in languages like LISP, for example). The procedure knows how this structure is made and may alter it.</p>

<p>This also works like a charm. Some problems arise, however, when we start building specialized types of data. What happens, for example, when I introduce a "lockable door" data type, which can be opened only when it is not locked? Let's see</p>

<p>``` python</p>

<h1>These are two standard doors, initially closed</h1>

<p>door1 = [1, 'closed']
door2 = [2, 'closed']</p>

<h1>This is a lockable door, initially closed and unlocked</h1>

<p>ldoor1 = [1, 'closed', 'unlocked']</p>

<h1>This procedure opens a standard door</h1>

<p>def open_door(door):</p>

<pre><code>door[1] = 'open'
</code></pre>

<h1>This procedure opens a lockable door</h1>

<p>def open_ldoor(door):</p>

<pre><code>if door[2] == 'unlocked':
    door[1] = 'open'
</code></pre>

<p>open_door(door1)
print(door1)</p>

<p>open_ldoor(ldoor1)
print(ldoor1)
```</p>

<p>Everything still works, no surprises in this code. However, as you can see, I had to find a different name for the procedure that opens a locked door since its implementation differs from the procedure that opens a standard door. But, wait... I'm still opening a door, the action is the same, and it just changes the status of the door itself. So why shall I remember that a locked door shall be opened with <code>open_ldoor()</code> instead of <code>open_door()</code> if the verb is the same?</p>

<p>Chances are that this separation between data and procedures doesn't perfectly fit some situations. The key problem is that the "open" action is not actually <em>using</em> the door; rather it is <em>changing its state</em>. So, just like the volume control buttons of your phone, which are <em>on</em> your phone, the "open" procedure should stick to the "door" data.</p>

<p>This is exactly what leads to the concept of <em>object</em>: an object, in the OOP context, is a structure holding data <em>and</em> procedures operating on them.</p>

<h2>What About Type?</h2>

<p>When you talk about data you immediately need to introduce the concept of <em>type</em>. This concept may have two meanings that are worth being mentioned in computer science: the <em>behavioural</em> and the <em>structural</em> one.</p>

<p>The behavioural meaning represents the fact that you know what something is by describing how it acts. This is the foundation of the so-called "duck typing" (here "typing" means "to give a type" and not "to type on a keyboard"): if it <del>types</del> acts like a duck, it <em>is</em> a duck.</p>

<p>The structural meaning identifies the type of something by looking at its internal structure. So two things that act in the same way but are internally different are of different type.</p>

<p>Both points of view can be valid, and different languages may implement and emphasize one meaning of type or the other, and even both.</p>

<h2>Class Games</h2>

<p>Objects in Python may be built describing their structure through a <em>class</em>. A class is the programming representation of a generic object, such as "a book", "a car", "a door": when I talk about "a door" everyone can understand what I'm saying, without the need of referring to a specific door in the room.</p>

<p>In Python, the type of an object is represented by the class used to build the object: that is, in Python the word <em>type</em> has the same meaning of the word <em>class</em>.</p>

<p>For example, one of the built-in classes of Python is <code>int</code>, which represents an integer number</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>a = 6
print(a)
6
print(type(a))
<class 'int'>
print(a.<strong>class</strong>)
<class 'int'>
```</p></blockquote></blockquote></blockquote>

<p>As you can see, the built-in function <code>type()</code> returns the content of the <em>magic attribute</em> <code>__class__</code> (magic here means that its value is managed by Python itself offstage). The type of the variable <code>a</code>, or its class, is <code>int</code>. (This is a very inaccurate description of this rather complex topic, so remember that at the moment we are just scratching the surface).</p>

<p>Once you have a class you can <em>instantiate</em> it to get a concrete object (an <em>instance</em>) of that type, i.e. an object built according to the structure of that class. The Python syntax to instantiate a class is the same of a function call</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>b = int()
type(b)
<class 'int'>
```</p></blockquote></blockquote></blockquote>

<p>When you create an instance, you can pass some values, according to the class definition, to <em>initialize</em> it.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>b = int()
print(b)
0
c = int(7)
print(c)
7
```</p></blockquote></blockquote></blockquote>

<p>In this example, the <code>int</code> class creates an integer with value 0 when called without arguments, otherwise it uses the given argument to initialize the newly created object.</p>

<p>Let us write a class that represents a door to match the procedural examples done in the first section</p>

<p>``` python
class Door:</p>

<pre><code>def __init__(self, number, status):
    self.number = number
    self.status = status

def open(self):
    self.status = 'open'

def close(self):
    self.status = 'closed'
</code></pre>

<p>```</p>

<p>The <code>class</code> keyword defines a new class named <code>Door</code>; everything indented under <code>class</code> is part of the class. The functions you write inside the object are called <em>methods</em> and don't differ at all from standard functions; the nomenclature changes only to highlight the fact that those functions now are part of an object.</p>

<p>Methods of a class must accept as first argument a special value called <code>self</code> (the name is a convention but please never break it).</p>

<p>The class can be given a special method called <code>__init__()</code> which is run when the class is instantiated, receiving the arguments passed when calling the class; the general name of such a method, in the OOP context, is <em>constructor</em>, even if the <code>__init__()</code> method is not the only part of this mechanism in Python.</p>

<p>The <code>self.number</code> and <code>self.status</code> variables are called <em>attributes</em> of the object. In Python, methods and attributes are both <em>members</em> of the object and are accessible with the dotted syntax; the difference between attributes and methods is that the latter can be called (in Python lingo you say that a method is a <em>callable</em>).</p>

<p>As you can see the <code>__init__()</code> method shall create and initialize the attributes since they are not declared elsewhere. This is very important in Python and is strictly linked with the way the language handles the type of variables. I will detail those concepts when dealing with polymorphism in a later post.</p>

<p>The class can be used to create a concrete object</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1 = Door(1, 'closed')
type(door1)
<class '__main__.Door'>
print(door1.number)
1
print(door1.status)
closed
```</p></blockquote></blockquote></blockquote>

<p>Now <code>door1</code> is an instance of the <code>Door</code> class; <code>type()</code> returns the class as <code>__main__.Door</code> since the class was defined directly in the interactive shell, that is in the current main module.</p>

<p>To call a method of an object, that is to run one of its internal functions, you just access it as an attribute with the dotted syntax and call it like a standard function.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.open()
print(door1.number)
1
print(door1.status)
open
```</p></blockquote></blockquote></blockquote>

<p>In this case, the <code>open()</code> method of the <code>door1</code> instance has been called. No arguments have been passed to the <code>open()</code> method, but if you review the class declaration, you see that it was declared to accept an argument (<code>self</code>). When you call a method of an instance, Python automatically passes the instance itself to the method as the first argument.</p>

<p>You can create as many instances as needed and they are completely unrelated each other. That is, the changes you make on one instance do not reflect on another instance of the same class.</p>

<h2>Recap</h2>

<p>Objects are described by a <em>class</em>, which can generate one or more <em>instances</em>, unrelated each other. A class contains <em>methods</em>, which are functions, and they accept at least one argument called <code>self</code>, which is the actual instance on which the method has been called. A special method, <code>__init__()</code> deals with the initialization of the object, setting the initial value of the <em>attributes</em>.</p>

<h2>Movie Trivia</h2>

<p>Section titles come from the following movies: <em>Back to the Future (1985)</em> , <em>What About Bob? (1991)</em>, <em>Wargames (1983)</em>.</p>

<h2>Sources</h2>

<p>You will find a lot of documentation in <a href="http://www.reddit.com/r/Python/comments/226ahl/some_links_about_python_oop/">this Reddit post</a>. Most of the information contained in this series come from those sources.</p>

<h2>Feedback</h2>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>

<h2>Next post</h2>

<p><a href="/blog/2014/08/20/python-3-oop-part-2-classes-and-members">Python 3 OOP Part 2 - Classes and members</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OOP concepts in Python 2.x - Part 3]]></title>
    <link href="http://lgiordani.com/blog/2014/07/04/oop-concepts-in-python-2-dot-x-part-3/"/>
    <updated>2014-07-04T13:00:00+02:00</updated>
    <id>http://lgiordani.com/blog/2014/07/04/oop-concepts-in-python-2-dot-x-part-3</id>
    <content type="html"><![CDATA[<h2>Abstract</h2>

<p>Welcome to the third installment of this little series of posts about Python 2.x OOP implementation. The <a href="/blog/2014/03/05/oop-concepts-in-python-2-dot-x-part-1">first</a> and <a href="/blog/2014/03/10/oop-concepts-in-python-2-dot-x-part-2">second</a> issues introduced the most important concepts at the basis of Python as an object-oriented language.</p>

<p>This post will continue the discussion about metaclasses, introducing Abstract Base Classes, and give some insights on callable objects.</p>

<p><em>This post refers to the internals of Python 2.x - please note that Python 3.x changes (improves!) some of the features shown here. As soon as I feel comfortable with my Python 3 knowledge, I will post an update.</em></p>

<!--more-->


<h2>The Inspection Club</h2>

<p>As you know, Python leverages polymorphism at its maximum by dealing only with generic references to objects. This makes OOP not an addition to the language but part of its structure from the ground up. Moreover, Python pushes the EAFP appoach, which tries to avoid direct inspection of objects as much as possible.</p>

<p>It is however very interesting to read what Guido van Rossum says in <a href="http://legacy.python.org/dev/peps/pep-3119/">PEP 3119</a>: <em>Invocation means interacting with an object by invoking its methods. Usually this is combined with polymorphism, so that invoking a given method may run different code depending on the type of an object. Inspection means the ability for external code (outside of the object's methods) to examine the type or properties of that object, and make decisions on how to treat that object based on that information. [...] In classical OOP theory, invocation is the preferred usage pattern, and inspection is actively discouraged, being considered a relic of an earlier, procedural programming style. However, in practice this view is simply too dogmatic and inflexible, and leads to a kind of design rigidity that is very much at odds with the dynamic nature of a language like Python.</em></p>

<p>The author of Python recognizes that forcing the use of a pure polymorphic approach leads sometimes to solutions that are too complex or even incorrect. In this section I want to show some of the problems that can arise from a pure polymorphic approach and introduce Abstract Base Classes, which aim to solve them. I strongly suggest to read <a href="http://legacy.python.org/dev/peps/pep-3119/">PEP 3119</a> (as for any other PEP) since it contains a deeper and better explanation of the whole matter. Indeed I think that this PEP is so well written that any further explanation is hardly needed. I am however used to write explanations to check how much I understood about the topic, so I am going to try it this time too.</p>

<h4>E.A.F.P the Extra Test Trial</h4>

<p>The EAFP coding style requires you to trust the incoming objects to provide the attributes and methods you need, and to manage the possible exceptions, if you know how to do it. Sometimes, however, you need to test if the incoming object matches a complex behaviour. For example, you could be interested in testing if the object <em>acts</em> like a list, but you quickly realize that the amount of methods a <code>list</code> provides is very big and this could lead to odd EAFP code like</p>

<p>``` python
try:</p>

<pre><code>obj.append
obj.count
obj.extend
obj.index
obj.insert
[...]
</code></pre>

<p>except AttributeError:</p>

<pre><code>[...]
</code></pre>

<p>```</p>

<p>where the methods of the <code>list</code> type are accessed (not called) just to force the object to raise the <code>AttributeError</code> exception if they are not present. This code, however, is not only ugly but also wrong. If you recall the "Enter the Composition" section of the <a href="/blog/2014/03/05/oop-concepts-in-python-2-dot-x-part-1">first post</a>, you know that in Python you can always customize the <code>__getattr__()</code> method, which is called whenever the requested attribute is not found in the object. So I could write a class that passes the test but actually does not act like a list</p>

<p>``` python
class FakeList(object):</p>

<pre><code>def fakemethod(self):
    pass

def __getattr__(self, name):
    if name in ['append', 'count', 'extend', 'index`, 'insert', ...]:
        return self.fakemethod
</code></pre>

<p>```</p>

<p>This is obviously just an example, and no one will ever write such a class, but this demonstrates that just accessing methods does not guarantee that a class <em>acts</em> like the one we are expecting.</p>

<p>There are many examples that could be done leveraging the highly dynamic nature of Python and its rich object model. I would summarize them by saying that sometimes you'd better to check the type of the incoming object.</p>

<p>In Python you can obtain the type of an object using the <code>type()</code> built-in function, but to check it you'd better use <code>isinstance()</code>, which returns a boolean value. Let us see an example before moving on</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>isinstance([], list)
True
isinstance(1, int)
True
class Door(object):
...  pass
...
d = Door()
isinstance(d, Door)
True
class EnhancedDoor(Door):
...  pass
...
ed = EnhancedDoor()
isinstance(ed, EnhancedDoor)
True
isinstance(ed, Door)
True
```</p></blockquote></blockquote></blockquote>

<p>As you can see the function can also walk the class hierarchy, so the check is not so trivial like the one you would obtain by directly using <code>type()</code>.</p>

<p>The <code>isinstance()</code> function, however, does not completely solve the problem. If we write a class that actually <em>acts</em> like a <code>list</code> but does not inherit from it, <code>isinstance()</code> does not recognize the fact that the two may be considered the same thing. The following code returns <code>False</code> regardless the content of the <code>MyList</code> class</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>class MyList(object):
...  pass
...
ml = MyList()
isinstance(ml, list)
False
```</p></blockquote></blockquote></blockquote>

<p>since <code>isinstance()</code> does not check the content of the class or its behaviour, it just consider the class and its ancestors.</p>

<p>The problem, thus, may be summed up with the following question: what is the best way to test that an object exposes a given interface? Here, the word <em>interface</em> is used for its natural meaning, without any reference to other programming solutions, which however address the same problem.</p>

<p>A good way to address the problem could be to write inside an attribute of the object the list of interfaces it promises to implement, and to agree that any time we want to test the behaviour of an object we simply have to check the content of this attribute. This is exactly the path followed by Python, and it is very important to understand that the whole system is just about a promised behaviour.</p>

<p>The solution proposed through PEP 3119 is, in my opinion, very simple and elegant, and it perfectly fits the nature of Python, where things are usually agreed rather than being enforced. Not only, the solution follows the spirit of polymorphism, where information is provided by the object itself and not extracted by the calling code.</p>

<p>In the next sections I am going to try and describe this solution in its main building blocks. The matter is complex so my explanation will lack some details: please refer to the forementioned PEP 3119 for a complete description.</p>

<h4>Who Framed the Metaclasses</h4>

<p>As already described, Python provides two built-ins to inspect objects and classes, which are <code>isinstance()</code> and <code>issubclass()</code> and it would be desirable that a solution to the inspection problem allows the programmer to go on with using those two functions.</p>

<p>This means that we need to find a way to inject the "behaviour promise" into both classes and instances. This is the reason why metaclasses come in play. If you recall what we said about them in the second issue of this series, metaclasses are the classes used to build classes, which means that they are the preferred way to change the structure of a class, and, in consequence, of its instances.</p>

<p>Another way to do the same job would be to leverage the inheritance mechanism, injecting the behaviour through a dedicated parent class. This solution has many downsides, which I'm am not going to detail. It is enough to say that affecting the class hierarchy may lead to complex situations or subtle bugs. Metaclasses may provide here a different entry point for the introduction of a "virtual base class" (as PEP 3119 specifies, this is not the same concept as in C++).</p>

<h4>Overriding Places</h4>

<p>As said, <code>isinstance()</code> and <code>issubclass()</code> are buil-in functions, not object methods, so we cannot simply override them providing a different implementation in a given class. So the first part of the solution is to change the behaviour of those two functions to first check if the class or the instance contains a special method, which is <code>__instancecheck__()</code> for <code>isinstance()</code> and <code>__subclasscheck__()</code> for <code>issubclass()</code>. So both built-ins try to run the respective special method, reverting to the standard algorithm if it is not present.</p>

<p>A note about naming. Methods must accept the object they belong to as the first argument, so the two special methods shall have the form</p>

<p>``` python
def <strong>instancecheck</strong>(cls, inst):
   [...]</p>

<p>def <strong>subclasscheck</strong>(cls, sub):
   [...]
```</p>

<p>where <code>cls</code> is the class where they are injected, that is the one representing the promised behaviour. The two built-ins, however, have a reversed argument order, where the behaviour comes after the tested object: when you write <code>isinstance([], list)</code> you want to check if the <code>[]</code> instance has the <code>list</code> behaviour. This is the reason behind the name choice: just calling the methods <code>__isinstance__()</code> and <code>__issubclass__()</code> and passing arguments in a reversed order would have been confusing.</p>

<h4>This is ABC</h4>

<p>The proposed solution is thus called Abstract Base Classes, as it provides a way to attach to a concrete class a virtual class with the only purpose of signaling a promised behaviour to anyone inspecting it with <code>isinstance()</code> or <code>issubclass()</code>.</p>

<p>To help programmers implement Abstract Base Classes, the standard library has been given an <code>abc</code> module, thet contains the <code>ABCMeta</code> class (and other facilities). This class is the one that implements <code>__instancecheck__()</code> and <code>__subclasscheck__()</code> and shall be used as a metaclass to augment a standard class. This latter will then be able to register other classes as implementation of its behaviour.</p>

<p>Sounds complex? An example may clarify the whole matter. The one from the official documentation is rather simple:</p>

<p>``` python
from abc import ABCMeta</p>

<p>class MyABC:</p>

<pre><code>__metaclass__ = ABCMeta
</code></pre>

<p>MyABC.register(tuple)</p>

<p>assert issubclass(tuple, MyABC)
assert isinstance((), MyABC)
```</p>

<p>Here, the <code>MyABC</code> class is provided the <code>ABCMeta</code> metaclass. This puts the two <code>__isinstancecheck__()</code> and <code>__subclasscheck__()</code> methods inside <code>MyABC</code> so that you can use them like</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>d = {'a': 1}
MyABC.<strong>isinstancecheck</strong>(d)
```</p></blockquote></blockquote></blockquote>

<p>that returns <code>True</code> if the dictionary <code>d</code> is an instance of the Abstract Base Class <code>MyABC</code>. In other words if the dictionary <code>d</code> implements the behaviour promised by the <code>MyABC</code> class.</p>

<p>After the definition of <code>MyABC</code> we need a way to signal that a given class is an instance of the Abstract Base Class and this happens through the <code>register()</code> method, provided by the <code>ABCMeta</code> metaclass. Calling <code>MyABC.register(tuple)</code> we record inside <code>MyABC</code> the fact that the <code>tuple</code> class shall be identified as a subclass of <code>MyABC</code> itself. This is analogous to saying that <code>tuple</code> inherits from <code>MyABC</code> but not quite the same. As already said registering a class in an Abstract Base Class with <code>register()</code> does not affect the class hierarchy. Indeed, the whole <code>tuple</code> class is unchanged.</p>

<h2>Little Shop of Collections</h2>

<p>In addition to the <code>abc</code> module, the standard library now provides a <code>collections</code> module that, besides some interesting container datatypes like <code>namedtuple</code> and <code>OrderedDict</code>, supplies a remarkable number of ABCs that represent container behaviours. An example is <code>collections.Sized</code> that pledges that the registered class will contain the <code>__len__()</code> method, enabling the code to pass it to the <code>len()</code> builtin. Let us exemplify that:</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>class Snake(object):
...   def <strong>init</strong>(self, meters):
...     self.len = meters
...   def <strong>len</strong>(self):
...     return self.len
...</p>

<p>s = Snake(5)
len(s)
5</p>

<p>import collections
collections.Sized.register(Snake)</p>

<p>issubclass(Snake, collections.Sized)
True
```</p></blockquote></blockquote></blockquote>

<p>If not stressed enough, ABCs assure that a given behaviour will be implemented but there is no actual check of this. For example:</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>class FakeSnake(object):
...   def <strong>init</strong>(self, meters):
...     pass
...</p>

<p>collections.Sized.register(FakeSnake)
issubclass(FakeSnake, collections.Sized)
True
f = FakeSnake(6)
len(f)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: object of type 'FakeSnake' has no len()
```</p></blockquote></blockquote></blockquote>

<p>Remember that ABCs are classes just like any other standard Python class, which means that they can be inherited to build more specialized ABCs.</p>

<h4>The Naked Class</h4>

<p>The <code>abc</code> module provides two decorators <code>@abstractmethod</code> and <code>@abstractproperty</code> to help the design of Abstract Base Classes. The first decorator, <code>@abstractmethod</code>, may only be used in a class which metaclass is <code>ABCMeta</code> (just like the example <code>MyABC</code> class described above). Decorating a method with it blocks the instantiation of the class itself until that method is overridden. That enables to write classes that may inherited only if the child class provides an implementation of some specific methods. The <code>@abstractproperty</code> decorator provides the same service for properties.</p>

<p>Let us run through a very simple example:</p>

<p>``` python
import abc</p>

<p>class AbstractCalculator(object):</p>

<pre><code>__metaclass__ = abc.ABCMeta

@abc.abstractmethod
def sum(a, b):
    pass

@abc.abstractmethod
def mutiply(a, b):
    pass
</code></pre>

<p>```</p>

<p>This is a class with <code>ABCMeta</code> as its metaclass, which makes <code>AbstractCalculator</code> an Abstract Base Class. The two <code>sum()</code> and <code>multiply()</code> methods are decorated with <code>@abstractmethod</code>, that raises an exception when we try to instance the class:</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>ac = AbstractCalculator()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Can't instantiate abstract class AbstractCalculator with abstract methods mutiply, sum</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>Moreover, any class that derives from <code>AbstractCalculator</code> and does not override the two methods (implementing them), cannot be instantiated:</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>class Calculator(AbstractCalculator):
...  pass
...
c = Calculator()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Can't instantiate abstract class Calculator with abstract methods mutiply, sum</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>These two decorators are the standard way to enforce a check about a behaviour or an interface, and are the closest thing to a "strict interface check".</p>

<h2>A Fish Called Object</h2>

<p>In the first post, when I discussed for the first time the concept of instantiation, I stated that an instance of a class may be obtained by calling the class itself just like a function. Let me recall you the example</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>b = int()
type(b)
<type 'int'>
```</p></blockquote></blockquote></blockquote>

<p>Later, speaking about methods and attributes, I defined <em>callable</em> something that can be invoked with that syntax. Thus, we can now say that classes are callables, just like methods. What makes an object callable, anyway? It turns out that, as many other things in Python, the solution is pretty straightforward: an object is callable if it contains the <code>__call__()</code> method. Simple, isn't it?</p>

<p>When we execute a syntax like</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>some_object()
```</p></blockquote></blockquote></blockquote>

<p>Python executes under the hood the following code</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>some_object.<strong>call</strong>()
```</p></blockquote></blockquote></blockquote>

<p>where any parameter passed to the class is obviously passed to <code>__call__()</code>.</p>

<p>For standard classes the <code>__call__()</code> method is provided by <code>type</code>, which is the standard metaclass. So when we write</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>b = int()
```</p></blockquote></blockquote></blockquote>

<p>python actually executes this code</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>b = int.<strong>class</strong>.<strong>call</strong>(int)
```</p></blockquote></blockquote></blockquote>

<p>This standard implementation of <code>__call__()</code> runs the constructor mechanism as depicted in the second post, executing <code>__new__()</code> and <code>__init__()</code> to get a new instance and initialize it.</p>

<p>The definition of callable object is very powerful, since it allows to flatten the difference between classes and functions. In OOP many times the two are presented as two completely separated concepts, but in Python it is usually more convenient to talk about callables. Here, Python shows its polymorphic nature at its maximum: if I expect a function and what is given to me is something that acts like a function everything is fine. Functions, however, are themselves simple callable objects. Remember: in Python everything is an object.</p>

<p>Since <code>__call__()</code> is a method we can redefine it in any class, let us try and see what happens</p>

<p>``` python
class CallMe(object):</p>

<pre><code>def __call__(self, *args, **kwds):
    return 1
</code></pre>

<p>```</p>

<p>Class instances usually contain no definition of <code>__call__()</code> and the implementation provided in the class hierarchy prevents them from being called</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>a = int()
a()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'int' object is not callable
```</p></blockquote></blockquote></blockquote>

<p>Nothing forbids us to define a custom <code>__call__()</code> method inside the instance and make it callable. This allows us to pass the instance where Python expects a function or, better, a callable. A classical example is the <code>sort()</code> method of <code>list</code> objects, which accepts an optional callable <code>f</code> that shall compare objects. Here, a callable instance is accepted just like a plain function.</p>

<h2>Final words</h2>

<p>There is still a lot to say about Python OOP. Just to name one topic, functions are a very interesting and wide subject. I would prefer now to update the current material to Python 3, so this is the last post in this small series. Stay tuned <a href="https://twitter.com/tw_lgiordani/">on Twitter</a> if you want to get the latest news from the blog!</p>

<h2>Movie Trivia</h2>

<p>Section titles of this issue come from the following movies: <em>The Breakfast Club</em>, <em>E.T. the Extra-Terrestrial</em>, <em>Who Framed Roger Rabbit</em>, <em>Trading Places</em>, <em>This is Spial Tap</em>, <em>Little Shop of Horrors</em>, <em>The Naked Gun</em>, <em>A Fish Called Wanda</em>.</p>

<h2>Sources</h2>

<p>Some sources for the content of this post. Thank you authors!</p>

<ul>
<li><a href="http://legacy.python.org/dev/peps/pep-3119/">PEP 3119</a> and the <a href="https://docs.python.org/2/library/abc.html#module-abc">ABC module documentation</a></li>
<li><a href="http://www.jeffknupp.com/blog/2013/02/14/drastically-improve-your-python-understanding-pythons-execution-model/">Understanding Python's Execution Model</a> and <a href="http://jeffknupp.com/blog/2014/06/18/improve-your-python-python-classes-and-object-oriented-programming/">Python Classes and Object Oriented Programming</a> by Jeff Knupp</li>
<li><a href="http://www.rafekettler.com/magicmethods.html">A Guide to Python's Magic Methods</a> by Rafe Kettler</li>
<li>Many <a href="http://stackoverflow.com/questions/tagged/python">Stackoverflow</a> questions and answers</li>
</ul>


<h2>Feedback</h2>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>

<h2>Previous articles</h2>

<ul>
<li><a href="/blog/2014/03/05/oop-concepts-in-python-2-dot-x-part-1">OOP Concepts in Python 2.x - Part 1</a></li>
<li><a href="/blog/2014/03/10/oop-concepts-in-python-2-dot-x-part-2">OOP Concepts in Python 2.x - Part 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Method overriding in Python]]></title>
    <link href="http://lgiordani.com/blog/2014/05/19/method-overriding-in-python/"/>
    <updated>2014-05-19T13:51:26+02:00</updated>
    <id>http://lgiordani.com/blog/2014/05/19/method-overriding-in-python</id>
    <content type="html"><![CDATA[<p>What is overriding? Overriding is the ability of a class to change the implementation of a method provided by one of its ancestors.</p>

<p>Overriding is a very important part of OOP since it is the feature that makes inheritance exploit its full power. Through method overriding a class may "copy" another class, avoiding duplicated code, and at the same time enhance or customize part of it. Method overriding is thus a strict part of the inheritance mechanism.</p>

<!--more-->


<h2>A quick glance to inheritance</h2>

<p>As for most OOP languages, in Python inheritance works through implicit delegation: when the object cannot satisfy a request, it first tries to forward the request to its ancestors, following the specific language rules in the case of multiple inheritance.</p>

<p>An exemple:</p>

<p>``` python
class Parent(object):</p>

<pre><code>def __init__(self):
    self.value = 5

def get_value(self):
    return self.value
</code></pre>

<p>class Child(Parent):</p>

<pre><code>pass
</code></pre>

<p>```</p>

<p>As you can see the <code>Child</code> class is empty, but since it inherits from <code>Parent</code> Python takes charge of routing all method calls. So you may use the <code>get_value()</code> method of <code>Child</code> objects and exerything works as expected.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>c = Child()
c.get_value()
5
```</p></blockquote></blockquote></blockquote>

<p>Indeed <code>get_value()</code> is not exactly part of the <code>Child</code> class as if it were defined in it</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>p = Parent()
c = Child()</p>

<p>dir(p)
['<strong>class</strong>', '<strong>delattr</strong>', '<strong>dict</strong>', '<strong>doc</strong>', '<strong>format</strong>',
 '<strong>getattribute</strong>', '<strong>hash</strong>', '<strong>init</strong>', '<strong>module</strong>', '<strong>new</strong>',
 '<strong>reduce</strong>', '<strong>reduce_ex</strong>', '<strong>repr</strong>', '<strong>setattr</strong>', '<strong>sizeof</strong>',
 '<strong>str</strong>', '<strong>subclasshook</strong>', '<strong>weakref</strong>', 'get_value', 'value']</p>

<p>dir(c)
['<strong>class</strong>', '<strong>delattr</strong>', '<strong>dict</strong>', '<strong>doc</strong>', '<strong>format</strong>',
 '<strong>getattribute</strong>', '<strong>hash</strong>', '<strong>init</strong>', '<strong>module</strong>', '<strong>new</strong>',
 '<strong>reduce</strong>', '<strong>reduce_ex</strong>', '<strong>repr</strong>', '<strong>setattr</strong>', '<strong>sizeof</strong>',
 '<strong>str</strong>', '<strong>subclasshook</strong>', '<strong>weakref</strong>', 'get_value', 'value']</p>

<p>dir(Parent)
['<strong>class</strong>', '<strong>delattr</strong>', '<strong>dict</strong>', '<strong>doc</strong>', '<strong>format</strong>',
 '<strong>getattribute</strong>', '<strong>hash</strong>', '<strong>init</strong>', '<strong>module</strong>', '<strong>new</strong>',
 '<strong>reduce</strong>', '<strong>reduce_ex</strong>', '<strong>repr</strong>', '<strong>setattr</strong>', '<strong>sizeof</strong>',
 '<strong>str</strong>', '<strong>subclasshook</strong>', '<strong>weakref</strong>', 'get_value']</p>

<p>dir(Child)
['<strong>class</strong>', '<strong>delattr</strong>', '<strong>dict</strong>', '<strong>doc</strong>', '<strong>format</strong>',
 '<strong>getattribute</strong>', '<strong>hash</strong>', '<strong>init</strong>', '<strong>module</strong>', '<strong>new</strong>',
 '<strong>reduce</strong>', '<strong>reduce_ex</strong>', '<strong>repr</strong>', '<strong>setattr</strong>', '<strong>sizeof</strong>',
 '<strong>str</strong>', '<strong>subclasshook</strong>', '<strong>weakref</strong>', 'get_value']</p>

<p>Parent.<strong>dict</strong>
dict_proxy({'<strong>module</strong>': '<strong>main</strong>',</p>

<pre><code>        'get_value': &lt;function get_value at 0xb69a656c&gt;,
        '__dict__': &lt;attribute '__dict__' of 'Parent' objects&gt;,
        '__weakref__': &lt;attribute '__weakref__' of 'Parent' objects&gt;,
        '__doc__': None,
        '__init__': &lt;function __init__ at 0xb69a6534&gt;})
</code></pre>

<p>Child.<strong>dict</strong>
dict_proxy({'<strong>module</strong>': '<strong>main</strong>', '<strong>doc</strong>': None})
```</p></blockquote></blockquote></blockquote>

<p>This shows that the <code>Child</code> class does not actually contain the <code>get_value()</code> method and that a mechanism of automatical delegation is active under the hood. For an insight on this mechanism check <a href="/blog/2014/03/05/oop-concepts-in-python-2-dot-x-part-1/">this post</a>.</p>

<h2>Method overriding in action</h2>

<p>In Python method overriding occours simply defining in the child class a method with the same name of a method in the parent class. When you define a method in the object you make this latter able to satisfy that method call, so the implementations of its ancestors do not come in play.</p>

<p>``` python
class Parent(object):</p>

<pre><code>def __init__(self):
    self.value = 5

def get_value(self):
    return self.value
</code></pre>

<p>class Child(Parent):</p>

<pre><code>def get_value(self):
    return self.value + 1
</code></pre>

<p>```</p>

<p>Now <code>Child</code> objects behave differently</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>c = Child()
c.get_value()
6
```</p></blockquote></blockquote></blockquote>

<p>and taking a look inside the class we spot a difference</p>

<p>```</p>

<blockquote><blockquote><blockquote><p>Parent.<strong>dict</strong>
dict_proxy({'<strong>module</strong>': '<strong>main</strong>',</p>

<pre><code>        'get_value': &lt;function get_value at 0xb69a656c&gt;,
        '__dict__': &lt;attribute '__dict__' of 'Parent' objects&gt;,
        '__weakref__': &lt;attribute '__weakref__' of 'Parent' objects&gt;,
        '__doc__': None,
        '__init__': &lt;function __init__ at 0xb69a6534&gt;})
</code></pre>

<p>Child.<strong>dict</strong>
dict_proxy({'<strong>module</strong>': '<strong>main</strong>',</p>

<pre><code>        'get_value': &lt;function get_value at 0xb69a65a4&gt;,
        '__doc__': None})
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>since now the <code>Child</code> class actually contains a <code>get_value()</code> method with a different implementation (the id of the two functions are different).</p>

<p>This is of uttermost importance in Python. Inheritance delegation occours automatically, but if a method is overridden the implementation of the ancestors is not considered at all. So, if you want to run the implementation of one or more of the ancestors of your class, you have to call them explicitly.</p>

<p>Why should you want to call the implementation of objects that are deeper in the class hierarchy?</p>

<p>You may want to call it because many times you override a method to enhance its nature, that is to improve the "quality" of the result, and to improve something you need to first access it. So, by calling the original implementation, you get the result you later want to improve.</p>

<p>There is however a well defined reason why <strong>you must always call the original implementation</strong>. This reason may be called "hidden side effects".</p>

<p>When you inherit from a class, you are actually inheriting a whole class hierarchy which internal structure is (or shall be considered) unknown. This means that any method call may hide a complex set of operations on the whole class hierarchy, and some of them may be vital for the library or the framework you are using.</p>

<p>Python makes you call the original implementation of an overridden method explicitly (not differently from other object-oriented languages). This surely follows the Python idea that "Explicit is better than implicit" (<a href="http://legacy.python.org/dev/peps/pep-0020/">The Zen of Python</a>), but this advice is not just a matter of taste or some sort of programming mannerism.</p>

<p>When you override you have to think if you want to filter the arguments for the original implementation, if you want to filter its results, or both. You typically want to filter arguments (pre-filter) if you want to change the data that the parent implementation shall process while you filter the results (post-filter) if you want to add an additional processing layer. Obviously both things may be done together in the same method. Since you have to explicitly call the parent implementation you are free to do it where you want in the code of the new method: the decision about the type of filtering you want to achieve affects the position of the call.</p>

<h4>An example of pre-filtering</h4>

<p>``` python
import datetime</p>

<p>class Logger(object):</p>

<pre><code>def log(self, message):
    print message
</code></pre>

<p>class TimestampLogger(Logger):</p>

<pre><code>def log(self, message):
    message = "{ts} {msg}".format(ts=datetime.datetime.now().isoformat(),
                                  msg=message)
    super(TimestampLogger, self).log(message)
</code></pre>

<p>```</p>

<p>The <code>TimestampLogger</code> object adds some information to the message string before calling the original implementation of its <code>log()</code> method.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>l = Logger()
l.log('hi!')
hi!</p>

<p>t = TimestampLogger()
t.log('hi!')
2014-05-19T13:18:53.402123 hi!</p>

<p>```</p></blockquote></blockquote></blockquote>

<h4>An example of post-filtering</h4>

<p>``` python
import os</p>

<p>class FileCat(object):</p>

<pre><code>def cat(self, filepath):
    f = file(filepath)
    lines = f.readlines()
    f.close()
    return lines
</code></pre>

<p>class FileCatNoEmpty(FileCat):</p>

<pre><code>def cat(self, filepath):
    lines = super(FileCatNoEmpty, self).cat(filepath)
    nonempty_lines = [l for l in lines if l != '\n']
    return nonempty_lines
</code></pre>

<p>```</p>

<p>When you use the <code>FileCatNoEmpty</code> object you get the result of the <code>FileCat</code> object with the empty lines stripped.</p>

<p>As you can see while in the first example the original implementation has been called as the last thing, in the second one it is called before everything else. There is therefore no fixed position for the call of the original method, and it depends on what you want to do.</p>

<h2>Always call super()?</h2>

<p>Shall we <em>always</em> call the original method implementation? In theory a well designed API should make it always possible but we know that boundary cases exist: the original method may have side effect that you want to avoid and sometimes the API cannot be refactored to avoid them. In those cases you may prefer to skip the call to the original implementation of the method; Python does not make it mandatory, so feel free to walk that path if you think the situation requires it. Be sure to know what you are doing, however, and document why you are completely overwriting the method.</p>

<h2>Summary</h2>

<ul>
<li>Call the original implementation of a method you are overriding whenever possible. This meakes the underlying API work as expected. When in need of skipping the call be sure to document the reasons.</li>
<li>Always use <code>super(cls, self)</code> for Python 2.x or <code>super()</code> for Python 3.x to call the original implementation of a method. This respects the resolution order in case of multiple inheritance and, for Python 3.x, protects from changes in the class hierarchy.</li>
<li>If you call to the original implementation of a method do it as soon as you have all the data you need to run it.</li>
</ul>


<h2>Updates</h2>

<p>2014-05-21 As suggested by <a href="http://www.reddit.com/user/caseyweb">caseyweb</a> in <a href="http://www.reddit.com/r/Python/comments/25y4hu/method_overriding_in_python/chn5v1q">this comment</a> the conclusions of the post were too strong, so I updated the post with a new section ("Always call super()?") and the summary. Many thanks caseyweb!</p>

<h2>Links</h2>

<ul>
<li><a href="https://docs.python.org/3/tutorial/classes.html">Python official documentation on classes</a></li>
</ul>


<h2>Feedback</h2>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>
]]></content>
  </entry>
  
</feed>
