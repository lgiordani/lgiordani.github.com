<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | The digital cat]]></title>
  <link href="http://lgiordani.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://lgiordani.github.io/"/>
  <updated>2014-02-17T19:06:39+01:00</updated>
  <id>http://lgiordani.github.io/</id>
  <author>
    <name><![CDATA[Leonardo Giordani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Digging up Django class-based views - 3]]></title>
    <link href="http://lgiordani.github.io/blog/2014/02/14/digging-up-django-class-based-views-3/"/>
    <updated>2014-02-14T16:13:41+01:00</updated>
    <id>http://lgiordani.github.io/blog/2014/02/14/digging-up-django-class-based-views-3</id>
    <content type="html"><![CDATA[<p><em>This post refers to Django 1.5. Please be warned that some of the matters discussed here, some solutions or the given code can be outdated by more recent Django versions</em></p>

<p>In the first two issues of this short series we wandered around the basic concepts of class-based views in Django, and started understanding and using two of the basic generic views Django makes available to you: <code>ListView</code> and <code>DetailView</code>. Both are views that read some data from the database and show them on a rendered template.</p>

<p>This third issue wants to introduce the reader to the class-based version of Django forms. This post is not meant to be a full introduction to the Django form library; rather, I want to show how class-based generic views implement the CUD part of the CRUD operations (Create, Read, Update, Delete), the Read one being implemented by "standard" generic views.</p>

<!--more-->


<h2>A very basic example</h2>

<p>To start working with CBFs (class-based forms) let's say we are working with a <code>StickyNote</code> class which represents a simple text note with a date:</p>

<p>``` python
class StickyNote(models.Model):</p>

<pre><code>timestamp = models.DateTimeField()
text = models.TextField(blank=True, null=True)
</code></pre>

<p>```</p>

<p>One of the first things we usually want to do is to build a form that allows the user to create a new entry in the database, in this case a new sticky note. The functional version of such a form would be the following:</p>

<p>```python
def note_add(request):</p>

<pre><code>form = StickyNoteForm(request.POST or None)
if form.is_valid():
    new_note = form.save()
    new_note.save()
return render_to_response('note_add.html')
</code></pre>

<p>urlpatterns = patterns('',</p>

<pre><code>url(r'^note_add/$', 'note_add'),
</code></pre>

<p>)
```</p>

<p>which is not too complex to grasp. Note that I left aside some imports; the <code>StickNoteForm</code> class is built using a <a href="https://docs.djangoproject.com/en/1.5/topics/forms/modelforms/">model form</a>. Since you <a href="https://docs.djangoproject.com/en/1.5/topics/forms/">already know</a> how functional form views work, let's compare it with the same view expressed with a class:</p>

<p>``` python
class NoteAdd(CreateView):</p>

<pre><code>model = StickyNote
</code></pre>

<p>```</p>

<p>It is no surprise that most of the code went away, thanks to inheritance. As happened in the first two posts with standard views, the class mechanism provides us with a bunch of code that lives somewhere in the class hierarchy and works behind the scenes. Our mission is now to uncover that code to figure out how exactly CBFs work and how we can change them to perform what we need.</p>

<p>To make the post easier to follow, please always remember that "class-based form" is a short name for "class-based form view". That is, CBFs are views, so their job is to process incoming HTTP requests and return a HTTP response. Form views do this in a slightly different way than the standard ones, mostly due to the different nature of POST requests compared with GET ones. Let us take a look at this concept before moving on.</p>

<h2>HTTP requests: GET and POST</h2>

<p><em>Please note that this is a broad subject and that the present section wants only to be a very quick review of the main concepts that are related to Django CBFs</em></p>

<p>HTTP requests come in different forms, depending on the <strong>method</strong> they carry. Those methods are called <strong>HTTP verbs</strong> and the two most used ones are <strong>GET</strong> and <strong>POST</strong>. The GET method tells the server that the client wants to retrieve a resource (the one connected with the relative URL) and shall have no side effects (such as changing the resource). The POST method is used to send some data to the server, the given URL being the <em>resource</em> that shall handle the data.</p>

<p>As you can see, the definition of POST is very broad: the server accepts the incoming data and is allowed to perform any type of action with it, such as creating a new entity, editing or deleting one or more of them, and so on.</p>

<p>Keep in mind that forms are not the same thing as POST request. As a matter of fact, they are connected just incidentally: a form is a way to collect data from a user browsing a HTML page while POST is the way that data is transmitted to the server. You do not need to have a form to make a POST request, you just need some data to send. HTML forms are just a useful way to send POST requests, but not the only one.</p>

<h2>Form views</h2>

<p>Why are form views different from standard views? The answer can be found looking at the flow of a typical data submission on a Web site:</p>

<ol>
<li>The user browses a web page (GET)</li>
<li>The server answers the GET request with a page containing a form</li>
<li>The user fills the form and submits it (POST)</li>
<li>The server receives and processes data</li>
</ol>


<p>As you can see the procedure involves a double interaction with the server: the first request GETs the page, the second POSTs the data. So you need to build a view that answers the GET request and a view that answers the POST one.</p>

<p>Since most of the time the URL we use to POST data is the same URL we used to GET the page, we need to build a view that accepts both methods. This is the main reason of the pattern you are used to see in functional form views in Django. <a href="https://docs.djangoproject.com/en/1.5/topics/forms/">The official Django documentation</a> on the subject uses this snippet of code</p>

<p>``` python
def contact(request):</p>

<pre><code>if request.method == 'POST': # If the form has been submitted...
    form = ContactForm(request.POST) # A form bound to the POST data
    if form.is_valid(): # All validation rules pass
        # Process the data in form.cleaned_data
        # ...
    return HttpResponseRedirect('/thanks/') # Redirect after POST
else:
    form = ContactForm() # An unbound form

return render(request, 'contact.html', {
    'form': form,
})
</code></pre>

<p>```</p>

<p>As you can see the first conditional path deals with the data submission (POST) while the else part deals with the usual case of a GET request.</p>

<p>Now it is time to dig into the class-based forms that Django provides us to understand how they deal with this double interaction.</p>

<p>Let us start with the <code>CreateView</code> class we used in our simple example, which is defined in <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L202">views/generic/edit.py#202</a>. It is an almost empty class that inherits from <code>SingleObjectTemplateResponseMixin</code> and from <code>BaseCreateView</code>. The first class deals with the template selected to render the response and we can leave it aside for the moment. The second class, on the other hand, can be found a couple of lines above, at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L187">views/generic/edit.py#L187</a>, and implements two methods which names are self explaining, <code>get()</code> and <code>post()</code>.</p>

<h4>Processing GET and POST requests</h4>

<p>We already met the <code>get()</code> method in the <a href="/blog/2013/12/11/digging-up-django-class-based-views-2">past article</a> when we talked about the <code>dispatch()</code> method of the <code>View</code> class. A quick recap of its purpose: this method is called when the incoming HTTP request carries the GET verb and is used to process the request itself. Not surprisingly, the <code>post()</code> method is called when the incoming request is a POST one. The two methods are already defined by an ancestor of the <code>BaseCreateView</code> class, namely <code>ProcessFormView</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L145">views/generic/edit.py#L145</a>). It is useful to take a peek at the source code of this last class:</p>

<p>``` python
class ProcessFormView(View):</p>

<pre><code>"""
A mixin that renders a form on GET and processes it on POST.
"""
def get(self, request, *args, **kwargs):
    """
    Handles GET requests and instantiates a blank version of the form.
    """
    form_class = self.get_form_class()
    form = self.get_form(form_class)
    return self.render_to_response(self.get_context_data(form=form))

def post(self, request, *args, **kwargs):
    """
    Handles POST requests, instantiating a form instance with the passed
    POST variables and then checked for validity.
    """
    form_class = self.get_form_class()
    form = self.get_form(form_class)
    if form.is_valid():
        return self.form_valid(form)
    else:
        return self.form_invalid(form)
</code></pre>

<p>```</p>

<p>As you can see the two methods are pretty straightforward. They both retrieve the class of the form with <code>get_form_class()</code> and instance it with <code>get_form()</code> (more on them later). The <code>get()</code> method then just calls the <code>render_to_response()</code> method to render a template, passing the context produced by the <code>get_context_data()</code> method. Note that the context receives the form as built by the <code>get_form()</code> method.</p>

<p>The <code>post()</code> method does not directly render the template since it has to process incoming data before doing this last step. Instead the validation of the form is performed through its <code>is_valid()</code> method and the two methods <code>form_valid()</code> and <code>form_invalid()</code> are called depending on the result of the test. See the <a href="https://docs.djangoproject.com/en/1.5/ref/forms/validation/">official documentation</a> for more information about form validation.</p>

<p>Please note that the behaviour of these classes follows the same pattern of that used in <code>ListView</code> and <code>DetailView</code> as described in the previous two posts.</p>

<p>The <code>ProcessFormView</code> class inherits from <code>View</code>, which was already described in depth in the first two posts of this series; there you can find the <code>as_view()</code> and <code>dispatch()</code> method that are the foundation of the CBVs system.</p>

<h2>The form workflow - part I</h2>

<p>The inheritance path that starts with <code>ProcessFormView</code> spans all the classes that deal with the incoming request, telling GET and POST methods apart. The second inheritance path we can follow from <code>BaseCreateView</code> leads to <code>ModelFormMixin</code>, which is defined at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L75">views/generic/edit.py#L75</a>. This path contains the classes that implement the form management methods. The first two methods that deal with the form are <code>get_form_class()</code> and <code>get_form()</code> that we encountered when discussing the <code>get()</code> and <code>post()</code> methods.</p>

<p>The <code>get_form_class()</code> tries to get the form model from the <code>self.form_class</code> attribute, and if this is not defined tries to extract the model from the <code>self.model</code> or from the queryset. Then it returns a suitable modelform, using a factory defined in <a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/models.py">forms/models.py</a>.</p>

<p>The <code>get_form()</code> method is defined in <code>FormMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L10">views/generic/edit.py#L10</a>) and instances the form class with the keywords returned by <code>get_form_kwargs()</code>, implemented in <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L100">views/generic/edit.py#L100</a>. This last method is quite important as we are going to discover in a short while, since it has a big role in the double interaction that happens with POST requests.</p>

<p>The first implementation of the <code>get_form_kwargs()</code> method that we find in the ancestors tree is in <code>ModelFormMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L100">views/generic/edit.py#L100</a>), but this immediately calls the same method defined in <code>FormMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L10">views/generic/edit.py#L10</a>). The code is</p>

<p>``` python
def get_form_kwargs(self):</p>

<pre><code>kwargs = {'initial': self.get_initial()}
if self.request.method in ('POST', 'PUT'):
    kwargs.update({
        'data': self.request.POST,
        'files': self.request.FILES,
    })
return kwargs
</code></pre>

<p>```</p>

<p>The first value of the form keywords dictionary is the copy of the <code>self.initial</code> dictionary, returned by <code>get_initial()</code> as stated by <a href="https://docs.djangoproject.com/en/1.5/ref/forms/api/#dynamic-initial-values">the official documentation</a>. Then, if the method of the request being processed is POST or PUT, the keywords are updated with the content of the request itself, i.e. posted data and uploaded files. This is used to initialize the form object itself as you can see at <a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/forms.py#L77">forms/forms.py#L77</a>, and I am going to describe this mechanism later.</p>

<p>After this method returns its dictionary, the execution continues in <code>ModelFormMixin</code>. The code of that method is</p>

<p>``` python
def get_form_kwargs(self):</p>

<pre><code>kwargs = super(ModelFormMixin, self).get_form_kwargs()
kwargs.update({'instance': self.object})
return kwargs
</code></pre>

<p>```</p>

<p>that just adds <code>self.object</code> under the <code>instance</code> key of the keywords dictionary. We already met <code>self.object</code> when discussing <code>DetailView</code>, where it contained the result of the queryset, i.e. the object being shown by the view.</p>

<p>What is <code>self.object</code> now? Among the ancestors of our <code>CreateView</code> class, <code>BaseCreateView</code> defines <code>self.object</code> as <code>None</code> so for the moment we can leave it aside. It will come to the rescue later, when we will discuss update and deletion forms, so do not forget it.</p>

<p>The last things we find in the <code>get()</code> method, just after <code>get_form_class()</code> and <code>get_form()</code>, is <code>get_context_data()</code>. As happened in <code>ListView</code> and <code>DetailView</code>, this method builds a dictionary (the context) that is used to render a template. You can find the implementation of <code>get_context_data()</code> at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L130">views/generic/edit.py#L130</a>. As you can see, since <code>self.object</code> has been set to <code>None</code>, the context contains only the instanced form under the <code>form</code> keyword (inserted at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L155">views/generic/edit.py#L155</a>).</p>

<p>Let's recap the process until here.</p>

<ol>
<li>The URL dispatcher requests with GET a page containing a form.</li>
<li>The <code>get()</code> method of <code>ProcessFormView</code> finds the form class of choice through <code>get_form_class()</code></li>
<li>The form class is instanced by <code>get_form()</code> with the values contained in the <code>self.initial</code> dictionary</li>
<li>At this point a template is rendered with a context returned by <code>get_context_data()</code> as usual. The context contains the form.</li>
</ol>


<h2>The form workflow - part II</h2>

<p>Now the user obtained the requested page and is facing an empty form. Once the form has been filled, he or she clicks the submit button and a new HTTP request reaches the server, this time carrying the POST method and a set of data taken from the input fields of the form itself. Our view shall now handle the second interaction step, the one that in functional views is usually managed by the part starting with <code>if request.method == 'POST':</code>.</p>

<p>As we already know, the incoming request is processed by the <code>post()</code> method of <code>ProcessFormView</code>, which works like the <code>get()</code> method in its first part, calling <code>get_form_class()</code> and <code>get_form()</code>. This latter method now deals with a POST request, so the code of <code>get_form_kwargs()</code> in <code>FormMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L10">views/generic/edit.py#L10</a>) adds to the keywords dictionary the submitted data with the <code>data</code> key and the uploaded files under the <code>files</code> key. Why does Django do this? Well, as you can see at <a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/forms.py#L77">forms/forms.py#L77</a> a Django form can be instanced with an optional <code>data</code> keyword, which is stored inside the form object for the subsequent validation phase.</p>

<p>So now the form is bound (that is, it contains some data or files - see <a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/forms.py#L80">forms/forms.py#L80</a>). The <code>post()</code> method now tests the result of <code>is_valid()</code> and acts accordingly calling either <code>form_valid()</code> or <code>form_invalid()</code>. Pay attention that, while <code>is_valid()</code> is a method of the form itself, the two latter methods belong to the <code>BaseCreateView</code>, defined by the same ancestor classes that implement <code>get_form_kwargs()</code>, <code>ModelFormMixin</code> and <code>FormMixin</code>.</p>

<p>The former class implements it at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L123">views/generic/edit.py#L123</a> and puts the result of <code>form.save()</code> into <code>self.object</code>. Remember that <code>self.object</code> is appended to the context under the <code>object</code> key by the <code>get_context_data()</code> method, as shown in the previous section. The <code>form.save()</code> method for modelforms is defined by <code>BaseModelForm</code> at <a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/models.py#L357">forms/models.py#L357</a> and basically saves the instance of the Django model connected with the modelform, that is implements the actual creation at the base of the <code>CreateView</code> form view. As <code>form.save()</code> returns the object saved to the database, it makes sense to store it in <code>self.object</code> and pass it to the template.</p>

<p>The execution of <code>form_valid()</code> continues with the implementation in the <code>FormMixin</code> class at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L61">views/generic/edit.py#L61</a>. This method returns a <code>HttpResponseRedirect</code> object, which is the way you make the browser point to the given URL in Django. In this case the URL is given by <code>self.get_success_url()</code> which tries to return <code>self.success_url</code> if defined, otherwise returns the result of <code>get_absolute_url()</code> for the fresh-made object.</p>

<p>On the other hand, <code>form_invalid()</code> at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L67">views/generic/edit.py#L67</a> deals with the case of a form containing some errors and simply calls <code>render_to_response()</code> passing it the context with the compiled form under the <code>form</code> key.</p>

<h2>Update and Delete operations</h2>

<p>This rather rich code tour unveiled the inner mechanism of the <code>CreateView</code> class, which can be used to create a new object in the database. The <code>UpdateView</code> and <code>DeleteView</code> classes follow a similar path, with minor changes to perform the different action they are implementing.</p>

<p><code>UpdateView</code> wants to show the form already filled with values, so it instances <code>self.object</code> before processing the request (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L210">views/generic/edit.py#L210</a>). This makes the object available in the keywords dictionary under the <code>instance</code> key (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L105">views/generic/edit.py#L105</a>), which is used by modelforms to initialize the data (<a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/models.py#L244">forms/models.py#L244</a>). The <code>form.save()</code> method of <code>BaseModelForm</code> is smart enough to understand if the object has been created or just changed (<a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/models.py#L365">forms/models.py#L365</a> so the <code>post()</code> method of <code>UpdateView</code> works just like the one of <code>CreateView</code>.</p>

<p><code>DeleteView</code> is a bit different from <code>CreateView</code> and <code>UpdateView</code>. As <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-editing/#deleteview">the official documentation</a> states, if called with a GET method it shows a confirmation page that POSTs to the same URL. So, as for the GET requests, <code>DeleteView</code> just uses the <code>get()</code> method defined by its ancestor <code>BaseDetailView</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/detail.py#L103">views/generic/detail.py#L103</a>), which renders the template putting the object in the context. When called with a POST request, the view uses the <code>post()</code> method defined by <code>DeletionMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L233">views/generic/edit.py#L233</a>, which in turn just calls the <code>delete()</code> method of the same class (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L239">views/generic/edit.py#L239</a>). This performs the deletion on the database and redirects to the success URL.</p>

<h2>Conclusion</h2>

<p>As you can see, the structure behind the current implementation of Django class-based form views is rather complex. This allows the user to achieve complex behaviours like the CUD operations just by defining a couple of classes as I did in the simple example at the beginning of the post. Most of the time, however, such a simplification makes it difficult for the programmer to understand how to achieve the desired changes to the class behaviour. So the purpose of this big tour I made inside the Django source code was to give an insight of what methods are called in the lifetime of your HTTP request so that you can better identify what methods you need to override.</p>

<p>When performing special actions that fall outside the standard CUD operations you better inherit from <code>FormView</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L181">views/generic/edit.py#L181</a>). The first thing to do is to check if and how you need to customize the <code>get()</code> and <code>post()</code> methods; remember that you either need to implement the full behaviour of those methods or make you changes and call the parent implementation. If this is not enough for your application consider overriding one of the more dedicated methods, such as <code>get_form_kwargs()</code> or <code>form_valid()</code>.</p>

<p>This post ends the series "Digging Up Django Class-based Views". Stay tuned for other <a href="/blog/categories/django/">upcoming articles on Django</a>!</p>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post or to ask for an in-depth analysis of some topic. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>

<h2>Previous articles</h2>

<ul>
<li><p><a href="/blog/2013/10/28/digging-up-django-class-based-views-1">Digging Up Django Class-based Views - 1</a></p></li>
<li><p><a href="/blog/2013/12/11/digging-up-django-class-based-views-2">Digging Up Django Class-based Views - 2</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Digging up Django class-based views - 2]]></title>
    <link href="http://lgiordani.github.io/blog/2013/12/11/digging-up-django-class-based-views-2/"/>
    <updated>2013-12-11T09:00:00+01:00</updated>
    <id>http://lgiordani.github.io/blog/2013/12/11/digging-up-django-class-based-views-2</id>
    <content type="html"><![CDATA[<h2>Abstract</h2>

<p><em>This post refers to Django 1.5. Please be warned that some of the matters discussed here, some solutions or the given code can be outdated by more recent Django versions</em></p>

<p>In the first installment of this short series, I introduced the theory behind Django class-based views and the reason why in this context classes are more powerful than pure functions. I also introduced one of the generic views Django provides out-of-the-box, which is <code>ListView</code>.</p>

<p>In this second post I want to talk about the second most used generic view, <code>DetailView</code>, and about custom querysets and arguments. Last, I'm going to introduce unspecialized class-based views that allow you to build more complex Web pages. To fully understand <code>DetailView</code>, however, you need to grasp two essential concepts, namely <strong>querysets</strong> and <strong>view parameters</strong>. So I'm sorry for the learn-by-doing readers, but this time too I'm going to start with some pure programming topics.</p>

<!--more-->


<h2>QuerySets or the art of extracting information</h2>

<p>One of the most important parts of Django is the ORM (Object Relational Mapper), which allows you to access the underlying database just like a collection of Python objects. As you know, Django provides you tools to simplify the construction of DB queries; they are <strong>managers</strong> (the <code>.objects</code> attribute of any models, for example) and <strong>query methods</strong> (<code>get()</code>, <code>filter()</code>, and friends). Pay attention because things here are slightly more magical than you can think at a first glance.</p>

<p>When you use one of the methods of a manager you get as a result a <code>QuerySet</code>, which most of the time is used as a list, but is more than this. You can find <a href="https://docs.djangoproject.com/en/1.5/topics/db/queries/">here</a> and <a href="https://docs.djangoproject.com/en/1.5/ref/models/querysets/">here</a> the official documentation about queries and QuerySets, a very recommended reading.</p>

<p>What I want to stress here is that QuesySets are not evaluated until you perform an action that access the content like slicing or iterating on it. This means that we can build QuerySets, pass them to functions, store them, and even build them programmatically or metaprogramming them without the DB being hit. If you think at QuerySets as recipes you are not far from the truth: they are objects that store how you want to retrieve the data of your interest. Actually retriving them is another part of the game. This separation between the definition of something and its execution is called <strong>lazy evaluation</strong>.</p>

<p>Let me give you a very trivial example to show why the lazy evaluation of QuerySets is important.</p>

<p>``` python
[...]</p>

<p>def get_oldest_three(queryset):</p>

<pre><code>return queryset.order_by['id'][0:2]
</code></pre>

<p>old_books = get_oldest_three(Book.objects.all())
old_hardcover_books = \</p>

<pre><code>get_oldest_three(Book.objects.filter('type=Book.HARDCOVER'))
</code></pre>

<p>```</p>

<p>As you can see the <code>get_oldest_three()</code> method is just filtering an incoming QuerySet (which can be of any type); it simply orders the objects and gets the first three inserted in the DB. The important thing here is that we are using QuerySets like pure 'algorithms', or descriptions of a procedure. When creating the <code>old_books</code> variable we are just telling the <code>get_oldest_three()</code> method "Hey, this is the way I extract the data I'm interested in. May you please refine it and return the actual data?"</p>

<p>Being such flexible objects, QuerySets are an important part of generic views, so keep them warm for the upcoming banquet.</p>

<h2>Being flexible: parametric views</h2>

<p>URLs are the API of our Web site or service. This can be more or less evident for the user that browses through the pages, but from the programmer's point of view URLs are the entry points of a computer system. As such, they are not very different from the API of a library: here, static pages are just like constants, or functions that always return that same value (such as a configuration parameter), while dynamic pages are like functions that process incoming data (parameters) and return a result.</p>

<p>So Web URLs can accept parameters, and our underlying view shall do the same. You basically have three methods to convey parameters from the user's browser to your server using HTTP. The first method is named <a href="http://en.wikipedia.org/wiki/Query_string">query string</a> and lists parameters directly in the URL through a universal syntax. The second method is storing parameters in the HTTP request body, which is what POST requests do. We will discuss this method in a later post about forms.</p>

<p>The first method has one big drawback: most of the time URLs are long (and sometimes <em>too</em> long), and difficult to use as a real API. To soften this effect the concept of <a href="http://en.wikipedia.org/wiki/Clean_URL">clean URL</a> arose, and this is the way Django follows natively (though, if you want, you can also stick to the query string method).</p>

<p>Now, <a href="https://docs.djangoproject.com/en/1.5/topics/http/urls/">you know</a> that you can collect parameters contained in the URL parsing it with a regular expression; what we need to discover is how class-based views receive and process them.</p>

<p>In the previous post we already discussed the <code>as_view()</code> method that shall instance the class and return the result of <code>dispatch()</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L46">views/generic/base.py#L46</a>).</p>

<p>``` python</p>

<pre><code>@classonlymethod
def as_view(cls, **initkwargs):
    """
    Main entry point for a request-response process.
    """
    # sanitize keyword arguments
    for key in initkwargs:
        if key in cls.http_method_names:
            raise TypeError("You tried to pass in the %s method name as a "
                            "keyword argument to %s(). Don't do that."
                            % (key, cls.__name__))
        if not hasattr(cls, key):
            raise TypeError("%s() received an invalid keyword %r. as_view "
                            "only accepts arguments that are already "
                            "attributes of the class." % (cls.__name__, key))

    def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        if hasattr(self, 'get') and not hasattr(self, 'head'):
            self.head = self.get
        self.request = request
        self.args = args
        self.kwargs = kwargs
        return self.dispatch(request, *args, **kwargs)

    # take name and docstring from class
    update_wrapper(view, cls, updated=())

    # and possible attributes set by decorators
    # like csrf_exempt from dispatch
    update_wrapper(view, cls.dispatch, assigned=())
    return view
</code></pre>

<p>```</p>

<p>Now look at what the <code>view()</code> wrapper function actually does with the instanced class (here line 21, <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L65">views/generic/base.py#L65</a>); not surprisingly it takes the <code>request</code>, <code>args</code> and <code>kwargs</code> passed by the URLconf passes and converts them into as many class attributes with the same names.</p>

<p>This means that <em>everywhere in our CBVs</em> we can access the original call parameters simply reading <code>self.request</code>, <code>self.args</code> and <code>self.kwargs</code>, where <code>*args</code> and <code>**kwargs</code> are the unnamed and named values extracted by the URLconf regular expression.</p>

<h2>Details</h2>

<p>Just after listing things, one of the most useful things a Web site does is giving details about objects. Obviously any e-commerce site is made for the most part by pages that list products and show product details, but also a blog is made of one or more pages with a list of posts and a page for each of them. So building a detailed view of the content of our database is worth learning.</p>

<p>To help us in this task Django provides <code>DetailView</code>, which indeed deals, as the name suggests, with the details of what we get from the DB. While <code>ListView</code>'s basic behaviour is to extract the list of all objects with a given model, <code>DetailView</code> extracts a single object. How does it know what object shall be extracted?</p>

<p>When <code>dispatch()</code> is called on an incoming HTTP request the only thing it does is to look at the <code>method</code> attribute, which for <code>HttpRequest</code> objects contains the name of the HTTP verb used (e.g. <code>'GET'</code>); then <code>dispatch()</code> looks for a method of the class with the lowercase name of the verb (e.g. <code>'GET'</code> --> <code>get()</code>) (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L78">views/generic/base.py#L78</a>). This handler is then called with the same parameters of <code>dispatch()</code>, namely the <code>request</code> itself, <code>*args</code> and <code>**kwargs</code>.</p>

<p><code>DetailView</code> has no body and inherits everything from two classes; the second one, <code>BaseDetailView</code>, implements the <code>get()</code> method (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/detail.py#L107">views/generic/detail.py#L107</a>).</p>

<p>``` python
def get(self, request, *args, **kwargs):</p>

<pre><code>self.object = self.get_object()
context = self.get_context_data(object=self.object)
return self.render_to_response(context)
</code></pre>

<p>```</p>

<p>As you can see this method extracts the single object it shall represent calling <code>self.get_object()</code>, then calls <code>self.get_context_data()</code> (that we met in the previous post) and last the familiar <code>self.render_to_response()</code> that is the class equivalent of the well know Django function. The method <code>self.get_object()</code> is provided by <code>BaseDetailView</code>'s ancestor <code>SingleObjectMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/detail.py#L10">generic/detail.py#L10</a>): the most important parts of its code, for the sake of our present topic are</p>

<p>``` python
def get_object(self, queryset=None):</p>

<pre><code>if queryset is None:
    queryset = self.get_queryset()

pk = self.kwargs.get(self.pk_url_kwarg, None)
if pk is not None:
    queryset = queryset.filter(pk=pk)

obj = queryset.get()

return obj
</code></pre>

<p>```</p>

<p><strong>Warning</strong>: I removed many lines from the previous function to improve readability; please check the original source code for the complete implementation.</p>

<p>The code shows where <code>DetailView</code> gets the queryset from; the <code>get_queryset()</code> method is provided by <code>SingleObjectMixin</code> itself and basically returns <code>self.queryset</code> if present, otherwise returns all objects of the given model (acting just like <code>ListView</code> does). This <code>queryset</code> is then refined by a <code>filter()</code> and last by a <code>get()</code>. Here <code>get()</code> is not used directly (I think) to manage the different error cases and raise the correct exceptions.</p>

<p>The parameter <code>pk</code> used in <code>filter()</code> comes directly from <code>self.kwargs</code>, so it is taken directly from the URL. Since this is a core concept of views in general I want to look at this part carefully.</p>

<p>Our <code>DetailView</code> is called by an URLconf that provides a regular expression to parse the URL, for example <code>url(r'^(?P&lt;pk&gt;\d+)/$',</code>. This regex extracts a parameter and gives it the name <code>pk</code>, so <code>kwargs</code> of the view will contain <code>pk</code> as key and the actual number in the URL as value. For example the URL <code>123/</code> will result in <code>{'pk': 123}</code>. The default behaviour of <code>DetailView</code> is to look for a <code>pk</code> key and use it to perform the filtering of the queryset, since <code>self.pk_url_kwarg</code> is <code>'pk'</code>.</p>

<p>So if we want to change the name of the parameter we can simply define the <code>pk_url_kwarg</code> of our class and provide a regex that extract the primary key with the new name. For example <code>url(r'^(?P&lt;key&gt;\d+)/$',</code> extracts it with the name <code>key</code>, so we will define <code>pk_url_kwarg = 'key'</code> in our class.</p>

<p>From this quick exploration we learned that a class inheriting from <code>DetailView</code>:</p>

<ul>
<li>provides a context with the <code>object</code> key initialized to a single object</li>
<li><strong>must</strong> be configured with a <code>model</code> class attribute, to know what objects to extract</li>
<li><strong>can</strong> be configured with a <code>queryset</code> class attribute, to refine the set of objects where the single object is extracted from</li>
<li><strong>must</strong> be called from a URL that includes a regexp that extracts the primary key of the searched object as <code>pk</code></li>
<li><strong>can</strong> be configured to use a different name for the primary key through the <code>pk_url_kwarg</code> class attribute</li>
</ul>


<p>The basic use of <code>DetailView</code> is thus exemplified by the following code.</p>

<p>``` python
class BookDetail(DetailView):</p>

<pre><code>model = Book
</code></pre>

<p>urlpatterns = patterns('',</p>

<pre><code>url(r'^(?P&lt;pk&gt;\d+)/$',
    BookDetail.as_view(),
    name='detail'),
)
</code></pre>

<p>```</p>

<p>The view extracts a single object with the <code>Book</code> model; the regex is configured with the standard <code>pk</code> name.</p>

<p>As shown for <code>ListView</code> in the previous post, any CBV uses <code>get_context_data()</code> to return the context dictionary to the rendering engine. So views that inherit from <code>DetailView</code> can add data to the context following the same pattern</p>

<p>``` python
class BookDetail(DetailView):</p>

<pre><code>model = Book

def get_context_data(self, **kwargs):
    context = super(BookDetail, self).get_context_data(**kwargs)
    context['similar'] = get_similar_books(self.object)
    return context
</code></pre>

<p>urlpatterns = patterns('',</p>

<pre><code>url(r'^(?P&lt;pk&gt;\d+)/$',
    BookDetail.as_view(),
    name='detail'),
)
</code></pre>

<p>```</p>

<p>As explained before, you can access the object being shown through <code>self.object</code>, which in the above example is passed to a service function we implemented somewhere in our code.</p>

<h2>Using the base views</h2>

<p>Sometimes, when dealing with complex pages, the generic display CBVs that Django provides are not the right choice. This usually becomes evident when you start overriding method to prevent the view to perform its standard behaviour. As an instance say that you want to show detailed information of more than one object: probably DetailView will soon show its limits, being built to show only one object.</p>

<p>In all those cases that cannot be easily solved by one of the generic display CBVs, your way goes through other classes: <code>RedirectView</code>, <code>TemplateView</code>, and <code>View</code>. The documentation for these base views is <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/base/">here</a>, while the source code is in <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py">views/generic/base.py</a>.</p>

<p>I'm not going to fully describe those views; I want however to briefly point out some peculiarities.</p>

<p><code>View</code> is by now an old friend of us; we met it when we discussed the <code>as_view()</code> and <code>dispatch()</code> method. It is the most generic view class and can be leveraged to perform very specialized tasks such as rendering pages without templates (for example when returning JSON data in AJAX techniques).</p>

<p><code>TemplateView</code> is the best choice to render pages from a template keeping in the meanwhile freedom as regards the context content. Chances are that this is going to be the view you will use the most after <code>ListView</code> and <code>DetailView</code>. Basically you just need to inherit from it and define the <code>get_context_data()</code> method. As you can see from the <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L147">source code</a> <code>TemplateView</code> answers to GET requests only.</p>

<p><code>RedirectView</code>, as the name implies, is used to redirect a request. The redirection mechanism is very simple: its <code>get()</code> method returns a <code>HttpResponseRedirect</code> to the URL defined by the <code>url</code> class attribute. The class exhibits a very interesting behaviour (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L195">views/generic/base.py#L195</a>) when called through HTTP methods other than GET (namely HEAD, POST, OPTIONS, DELETE, and PUT): it "converts" the method to GET simply calling <code>get()</code> from the respective method (<code>head()</code>, <code>post()</code>, and so on). In the next post I'll show how to leverage this simple technique to show the user a prefilled form.</p>

<h2>Date-based views</h2>

<p>Django provides other class-based views that simplify dealing with objects extracted or ordered by date. As a programmer, you know that dealing with dates is sometimes at least awkward; the views in <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/dates.py">views/generic/dates.py</a> aims to help you to tame your date-based objects; any object that contains a date (e.g. post date for articles, birth date for people, log date for messages, etc) can be processed by these views. You can find the official documentation <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-date-based/">here</a>.</p>

<p>Remember that date-based views are CBVs, so they are based on <code>View</code>, just like <code>ListView</code> or <code>TemplateView</code>. So, apart from their specialization on date processing, they behave the same (<code>get_context_data()</code>, <code>get()</code>, <code>dispatch()</code>, and so on).</p>

<h2>Conclusion</h2>

<p>In this post we covered <code>DetailView</code> in deep and, more quickly, all the remaining base and data-based views. In the next post we will step into the rich (and strange) world of forms.</p>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post or to ask for an in-depth analysis of some topic. <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> is the best place to submit corrections.</p>

<h2>Previous articles</h2>

<ul>
<li><a href="/blog/2013/10/28/digging-up-django-class-based-views-1">Digging Up Django Class-based Views - 1</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Digging up Django class-based views - 1]]></title>
    <link href="http://lgiordani.github.io/blog/2013/10/28/digging-up-django-class-based-views-1/"/>
    <updated>2013-10-28T08:43:00+01:00</updated>
    <id>http://lgiordani.github.io/blog/2013/10/28/digging-up-django-class-based-views-1</id>
    <content type="html"><![CDATA[<h2>Abstract</h2>

<p><em>This post refers to Django 1.5. Please be warned that some of the matters discussed here, some solutions or the given code can be outdated by more recent Django versions</em></p>

<p>Django programmers that started with versions prior to 1.3 are used to deal with views as functions, and they learned how to process even complex forms in a procedural way. From the release 1.3, Django introduced class-based views (CBVs) and ported its powerful generic views to this new paradigm (class-based generic views, or CBGVs).</p>

<p>This change, however, has not been harmless for Django novices: the django-users mailing list and StackOverflow are full of questions about views and classes, and the official documentation on this topic is still a little unorganized. Well, open source things are always ready to be improved, aren't they? This post aims to share some thoughts and insights about CBVs, and hopefully it can also lead to an improvement of the official documentation.</p>

<p>I want to thank all Django developers for their work. Despite the previous criticism on documentation, this post wants to be a thanksgiving for their efforts.</p>

<!--more-->


<p>Feel free to comment <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">here</a> or to submit issues <a href="https://github.com/lgiordani/lgiordani.github.com/issues">here</a>.</p>

<h2>What are CBVs?</h2>

<p>Class-based views are, indeed, (Django) views based on (Python) classes. Until here, it makes sense, hopefully. This means that, to master them, you need to understand both Django views and Python classes, so let's give a quick definition of them.</p>

<p>A Django view is a piece of code that processes an HTTP request and returns an HTTP response. Oh yes, nothing more, nothing less.
A Python class is the implementation of the Object-Oriented concept of class in the Python language.</p>

<p>So a view just need to be a <a href="http://docs.python.org/2/library/functions.html#callable">callable</a>, and this includes functions and classes. Thus, to understand the advantages of class-based views over function-based views we shall discuss the merits of classes over functions. This latter sentence could be the title of a 10 volumes book on programming (followed by another 10 volumes book titled "Merits of functions over classes"), so I am just going to scratch the surface of the matter.</p>

<h2>Starting off with Python classes</h2>

<p>The main point of a class is implementing encapsulation: they represent a way of coupling data and functions. Doing this, a class loses the dynamic essence of a procedure, which exists only while it is running, and becomes a living entity, something that sits there, caring for its data, and reacts when we call its functions (methods).</p>

<p>A good analogy for a class is a finite-state machine: once the class has been initialized, methods are what we use to make it move between states. If we do not call methods, the class simply waits there without complaining.</p>

<p>As an example, let's look at a very simple procedure that takes a list and extracts the even numbers from it.</p>

<p>``` python
def extract_even_numbers(alist):</p>

<pre><code>return [i for i in alist if i%2 == 0]
</code></pre>

<p>```</p>

<p>The example is very trivial, but I think there is always time to tangle up the code, so let us start with simple things. A class version of this function could be written as</p>

<p>```python
class EvenExtractor(object):</p>

<pre><code>def __init__(self, alist):
    self.l = alist

def extract(self):
    return [i for i in self.l if i%2 == 0]
</code></pre>

<p>```</p>

<p>Seems to be the same thing, doesn't it? Indeed the difference is subtle but remarkable. Now the extractor has two parts, the first being the initialization and the second being the actual extraction, and we can have the class in one of three states: before initialization (<code>e = EvenExtractor</code>), after initialization (<code>e = EvenExtractor(range(120))</code>), and after extraction (<code>l = e.extract()</code>. Being a finite-state machine we can interact with it before moving from a state to another. For example</p>

<p><code>python
e = EvenExtractor(range(120)) # State B
e.l = range(60)
e.extract() # State C
</code></p>

<p>Well, despite the very simple example the point is: by converting the procedure to a class we obtained a rich tool that can execute its job step by step and, in general, can work in a non linear way.</p>

<h2>Playing with genetics</h2>

<p>The real power of classes used as finite-state machines lies in the concept of <a href="http://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29">inheritance</a>. Inheritance is a mechanism through which a class can copy another class and then change only the parts that have to behave differently. Please note that here we talk about classes and not instances, so the copy action here refers to the structure of the class, not the actual data contained in it. Inheritance is a mean to mimic the behaviour of a class.</p>

<p>(Sidenote: <em>I am a strong supporter of an OO design principle that states "Favour composition over inheritance" (and favor "favor" over "favour" for US audience). I read too many OOP introductions that stress too much the inheritance mechanism and leave composition aside, raising a generation of OOP programmers that, instead of building systems populated by many small collaborating objects create nightmares infested by giant all-purpose things that sometimes resemble an operating system more than a system component. Given that, inheritance plays an important role in OOP, and here we find a very good example of its real benefit.</em>)</p>

<p>Let's continue the above example, first by enriching the EvenExtractor class:</p>

<p>``` python
class EvenExtractor(object):</p>

<pre><code>def __init__(self, alist):
    self.l = [int(elem) for elem in alist]

def extract(self):
    return [i for i in self.l if i%2 == 0]
</code></pre>

<p>```</p>

<p>Now the class performs an important action in its initialization phase, converting all elements of the input list to integers, and we can happily use it in our Next Big Project. Some days after this change we realize that we could also profitably use a class that extracts odd elements form a list. Being good object oriented programmers we write</p>

<p>```  python
class OddExtractor(EvenExtractor):</p>

<pre><code>def extract(self):
    return [i for i in self.l if i%2 != 0]
</code></pre>

<p>```</p>

<p>and call it a day. Indeed, through the inheritance mechanism expressed by that <code>(EvenExtractor)</code> signature of the new class, we defined something that is exactly the same thing as <code>EvenExtractor</code>, with the same methods and attributes, but with a different name. Then we changed the behaviour of the new class but only for the extraction part by <a href="http://en.wikipedia.org/wiki/Method_overriding">overriding the method</a>.</p>

<p>To summarize the lesson: using classes and inheritance you can build finite-state machines that are easily customizable to suit your exact needs. This obviously is just one of the many points of view under which you can consider classes, but it is the one we need to understand Django CBVs.</p>

<h2>Back to Django</h2>

<p>Finally! You couldn't take Python classes anymore, could you? Sorry, we are dealing with them further, but for the moment let us move to Django to look at a practical use of what we learned in the previous sections.</p>

<p>A Django view is a perfect example of a finite-state machine. It takes an incoming request and makes it flow through different processing steps until a final response is produced, which is then sent back to the user. So, for the love of definitions, say that CBVs are the Django mechanism to allow the programmer to write their views leveraging the tools made available by the object-oriented paradigm. In this context (pun intended) CBGVs are the "batteries included" of Django views: (class-based) generic views are powerful tools that the framework gives you to accomplish the most usual tasks, and sometimes even the unusual ones.</p>

<p>Let's dig into one of the examples of the official Django docs; <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#listview">here</a> you find the API of the beloved <code>ListView</code>, a generic view to deal with a list of things (extracted from the database).</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article
</code></pre>

<p>```</p>

<p>This example assumes that <code>articles</code> is your application and <code>Article</code> is one of its models.</p>

<p>This short piece of code leverages the full power of inheritance. Indeed we just derived <code>ArticleListView</code> from <code>ListView</code> and changed the class attribute <code>model</code>: how can this work? How can this class process incoming requests and what are the outputs? The official documentation states "While this view is executing, self.object_list will contain the list of objects (usually, but not necessarily a queryset) that the view is operating upon."; this leaves many dark corners, however, and if you are a novice, chances are that you are already lost.</p>

<p>Since <code>ArticleListView</code> derives from <code>ListView</code>, the latter is the class we have to analyze to understand how data are processed. To do this you need to look at the <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#django.views.generic.list.ListView">documentation</a>, and if something is still unclear you can freely look at the <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/list.py">source code</a>. As already said I find a little difficult to find a clear way through the docs, so I'll try to summarize here what I learned. In the following paragraphs you will find links like (<a href="">SC</a>) which point to the source code, if you want to read it by yourself.</p>

<h4>URL dispatchers and views</h4>

<p>A CBV cannot directly be used in your URL dispatcher; instead you have to give the result of the <code>as_view()</code> method (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L31">SC</a>), which basically defines a function that instances the class (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L46">SC</a>) and calls the <code>dispatch()</code> method (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L47">SC</a>); then the function is returned to be used in the URL dispatcher (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L55">SC</a>). As a user, we are interested only in the fact that the <em>entry point</em> of the class, i.e. the method called when a request hits the URL linked with it, is <code>dispatch()</code>.</p>

<p>Let's use this knowledge to print out a string on the console each time a request is served by our CBV. I'm running through this (indeed simple) task step by step since it shows exactly how you have to deal with CBVs when solving real problems.</p>

<p>If we define the <code>ArticleListView</code> class this way</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article

def dispatch(self, request, *args, **kwargs):
    super(ArticleListView, self).dispatch(request, *args, **kwargs)
</code></pre>

<p>```</p>

<p>the class does not change its behaviour. What we did was to override the <code>dispatch()</code> method with a call to the parent's method, i.e. we explicitly wrote what Python does by default. You can find detailed information about <code>super()</code> <a href="http://docs.python.org/2/library/functions.html#super">here</a>. Please be also sure to understand the star and double star notation to define variable number of arguments; the official documentation is <a href="http://docs.python.org/2.7/tutorial/controlflow.html#more-on-defining-functions">here</a>.</p>

<p>Since views are automatically called by the framework, this latter expects them to comply with a very specific API, so when overriding a method you have to obey its signature. The signature of <code>dispatch()</code> can be found <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/base/#django.views.generic.base.View.dispatch">here</a>; by the way, this documentation of <code>dispatch()</code> gives you good hints about the internal working mechanism of CBVs.</p>

<p>The <code>dispatch()</code> method receives a <code>request</code> argument, which type is <code>HttpRequest</code> (<a href="https://docs.djangoproject.com/en/1.5/ref/request-response/#httprequest-objects">documentation</a>), and we can print it on the console with the standard <code>print()</code> function</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article

def dispatch(self, request, *args, **kwargs):
    print(request)
    super(ArticleListView, self).dispatch(request, *args, **kwargs)
</code></pre>

<p>```</p>

<p>This prints the content of the <code>request</code> object on the standard output of the Python code, that is on the standard output of the server that is running the Django project. If you are running the Django development server, you will find the output on the text console where you issued the <code>django-admin.py runserver</code> command (or <code>manage.py runserver</code>).</p>

<p>This, in a nutshell, is the standard way of dealing with framework classes, and thus with Django's CBGVs: inherit from a predefined class, identify which methods you need to change, override them complying with their signature and calling the parent's code somewhere in the new code.</p>

<p>The full list of methods <code>ListView</code> uses when processing incoming requests is listed on its <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#listview">official documentation page</a> in the "Method Flowchart" section; in the "Ancestors (MRO)" section you can see that <code>ListView</code> itself inherits from a good number of other classes. MRO stands for Method Resolution Order and has to deal with multiple inheritance: if you are eager to deal with one of the most intricate Python topics feel free to read <a href="http://docs.python.org/2/tutorial/classes.html#multiple-inheritance">here</a>.</p>

<h4>Incoming GET requests</h4>

<p>Back to our <code>ArticleListView</code>. The <code>dispatch()</code> method of the parent reads the <code>method</code> attribute of the <code>request</code> object and selects a handler to process the request itself (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L57">SC</a>): this means that if <code>request.method</code> is <code>'GET'</code>, which is the HTTP way to say that we are <em>reading</em> a resource, <code>dispatch()</code> will call the <code>get()</code> method of the class.</p>

<p>The <code>get()</code> method of <code>ListView</code> comes from its <code>BaseListView</code> ancestor (<a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#django.views.generic.list.BaseListView">documentation</a>, <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/list.py#L114">source code</a>). This function is the one that contains the functional view code, so if you are accustomed to function-based views you'll find yourself at home here. As you can see, the function basically fills the attribute <code>self.object_list</code> with the result of the method <code>self.get_queryset()</code>, creates a context calling the method <code>self.get_context_data()</code> and calls the class version of <code>render_to_response()</code>, namely <code>self.render_to_response()</code>.</p>

<p>Are you still with me? Don't give up, we are nearly at the end (with ListView). The method <code>self.get_queryset()</code> comes from the <code>MultipleObjectMixin</code> ancestor of <code>ListView</code> (<a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/mixins-multiple-object/#multipleobjectmixin">documentation</a>, <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/list.py#L11">source code</a>) and simply gets all objects of a given model (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/list.py#L29">SC</a>) issuing <code>queryset = self.model._default_manager.all()</code>. The value of <code>self.model</code> is what we configured in our class when we wrote <code>model = Article</code>.</p>

<p>That's all. Our <code>ArticleListView</code> class extracts all <code>Article</code> objects from the database, and calls a template passing a context that contains a single variable, <code>object_list</code>, instanced with the list of extracted objects.</p>

<h4>Templates and contexts</h4>

<p>Are you satisfied? I'm actually still curious about the template and the context. Let's see what we can find about these topics. First of all, when the class calls <code>self.render_to_response()</code> it uses the code that comes from its <code>TemplateResponseMixin</code> ancestor (<a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/mixins-simple/#templateresponsemixin">documentation</a>, <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L81">source code</a>); the method calls some other functions but its basic behaviour is to create a response using a template and a context. The template, again through a series of calls which you can follow by yourself, comes from <code>self.template_name</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L109">SC</a>); while <code>TemplateResponseMixin</code> defines it <code>None</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L85">SC</a>), <code>ListView</code> does some magic through ancestors (<a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/list.py#L128">SC</a>) to return a template which name derives from the given model. So, in short, our <code>ArticleListView</code>, defining an <code>Article</code> model, automatically uses a template that is called <code>article_list.html</code>.</p>

<p>May we change this behaviour? Of course! This is, after all, the point of using classes instead of functions: easily customize the behaviour. We can change the definition of our class like:</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article
template_name = 'sometemplate.html'
</code></pre>

<p>```</p>

<p>What does this exactly do? When the <code>self.render_to_response()</code> method looks for <code>self.template_name</code> this attribute has a value, so there is no need to call the predefined methods and <code>sometemplate.html</code> becomes the name of the template used to render the response. This follows a very useful pattern of object-oriented programming; if you are interested I can write something about this topic.</p>

<p>As regards the context, remember that it is only a dictionary of values you want to access when compiling the template. Variable names inside the context (as thus inside the template), data format and data content are completely up to you. When using CBGVs, however, you will find in your context some variables that have been created by the ancestors of your view, as happens for <code>object_list</code>. What if you want to show a page with the list of all Articles, but you want to add a value to the context?</p>

<p>Nothing is easier: you just need to override the function that produces the context and change its behaviour. Say, for example, that we want to show the number of total readers of our site, along with the list of articles. Assuming that a <code>Reader</code> model is available we can write</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article, Reader</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article

def get_context_data(self, **kwargs):
    context = super(ArticleListView, self).get_context_data(**kwargs)
    context['readers'] = Reader.objects.count()
    return context
</code></pre>

<p>```</p>

<p>As always, when overriding a method we first call the ancestor's one, so that we get the result expected from a normal behaviour of the method, then we add out customizations.</p>

<h2>Conclusion</h2>

<p>In this first post I tried to uncover some of the mysteries behind CBVs and CBGVs in Django, by showing step by step what happens to a GET request that hits a class-based view. Hopefully the matter has now been demystified a little!</p>

<p>In the next posts I will discuss DetailView, the generic view to show detail about an object, how to create custom CBVs and how to use CBVs to process forms, i.e. POST requests.</p>

<p>Let me know if this post helped you in understanding the matter and feel free to point out any error or to ask questions.</p>

<h2>Updates</h2>

<p>2013-10-29: As pointed out by <a href="http://www.reddit.com/user/mbrochh">mbrochh</a> on Reddit, there is a very useful resource for Django programmers: <a href="http://ccbv.co.uk/">Classy Class-Based Views</a>. It is a comprensive index of all CBGVs with ancestors and method signatures. Make sure to have it in you Django bookmarks!</p>

<p>2013-10-29: I fixed a couple of typos when overriding <code>dispatch()</code>. Thanks to Tom Evans for spotting them.</p>

<p>2013-10-30: Fixed the <code>__init__()</code> method of <code>EvenExtractor</code>, that was missing the <code>self</code> parameter. Thanks <a href="http://www.reddit.com/user/meatypocket">meatypocket</a>.</p>

<h2>Next articles</h2>

<ul>
<li><a href="/blog/2013/12/11/digging-up-django-class-based-views-2">Digging Up Django Class-based Views - 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postage - a RabbitMQ-based component Python library]]></title>
    <link href="http://lgiordani.github.io/blog/2013/07/25/postage-a-rabbitmq-based-component-python-library/"/>
    <updated>2013-07-25T15:50:00+02:00</updated>
    <id>http://lgiordani.github.io/blog/2013/07/25/postage-a-rabbitmq-based-component-python-library</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/pika/pika">Pika</a> is a wonderful pure Python implementation of the AMQP protocol. Using it you can exploit the full power of your RabbitMQ installation from your Python code.</p>

<p>When using pika to develop a component-based system I tried to write some code to simplify its use: the result is <a href="https://github.com/lgiordani/postage">Postage</a>, a Python library that provides higher level structures such as a message format, components fingerprint, rich producer and consumers.</p>

<p>Most notably it provides a handler mechanism for consumers that makes message processing a breeze.</p>

<p>Postage is freely available under the GPL2. It is based on the pika BlockingConnection since I had no experience with other adapters. If you want to hack it, feel free to <a href="https://github.com/lgiordani/postage">fork it on Github</a> and submit a pull request.</p>

<!--more-->


<h2>A simple ping example</h2>

<p>I'll describe here a very simple example of a producer/consumer system using Postage; I'll write a server that answers ping messages and a program that sends them. First I will implement a simple server that receives ping messages without answering, to introduce the reader to the base structures, then I will evolve it.</p>

<p>To execute the program you need a working RabbitMQ system, check the RabbitMQ documentation to install and run it. Postage assumes that your system is configured with the standard values (a "/" virtualhost, "guest" user and password). If not check <a href="https://github.com/lgiordani/postage#environment-variables">this paragraph</a> of the documentation.</p>

<h4>Setting up the exchange</h4>

<p>Put the following code in a <code>facilities.py</code> file:</p>

<p>``` python
from postage import messaging</p>

<p>class PingExchange(messaging.Exchange):</p>

<pre><code>"""This is the exchange that receives ping messages."""
name = "ping-exchange"
exchange_type = "direct"
passive = False
durable = True
auto_delete = False
</code></pre>

<p>```</p>

<p>This imports the messaging part of Postage and declares a <code>PingExchange</code>, which is a simple direct RabbitMQ exchange, which name is <code>ping-exchange</code>. Remember that in a AMQP system exchanges are unique by name and virtualhost, i.e. given a virtualhost the name of the exchange uniquely identifies it.</p>

<h4>Setting up the producer</h4>

<p>Just below the exchange object we declare a producer, a class that can send a given set of messages:</p>

<p>``` python
class PingProducer(messaging.GenericProducer):</p>

<pre><code>eks = [(PingExchange, 'ping_rk')]

def build_message_ping(self):
    return messaging.MessageCommand('ping')
</code></pre>

<p>```</p>

<p>First of all our producer inherits from <code>GenericProducer</code>, a rich object that manages low-level stuff such as connection to the AMQP broker (RabbitMQ), exchange declaration and message creation.</p>

<p>The <code>eks</code> class attribute is a list of exchange/routing key couples (tuples); we list here all the exchanges that will receive our messages when the object will send them and for each exchange we give a routing key. Recall that routing keys are used to label messages so that the exchange can route them to the subscribing queues (according to the rules of the exchange type). Here, we declare that the messages of our producer are going to be sent to the <code>PingExchange</code> exchange with the <code>ping_rk</code> routing key.</p>

<p>Then we declare a <code>build_message_ping()</code> method, which simply builds a new message and returns it. This latter is a command message that in Postage lingo means a message that contains an action the receiver shall execute (a fire-and-forget call).</p>

<h4>The producer</h4>

<p>The program that sends ping messages is very straightforward; it shall declare a message producer and use it to send the message. Create the <code>send_ping.py</code> file and write the following code</p>

<p>``` python
from postage import messaging
import facilities</p>

<p>fingerprint = messaging.Fingerprint(name="ping_sender")</p>

<p>```</p>

<p>After the usual imports, I create a fingerprint for this program. As explained in <a href="https://github.com/lgiordani/postage#fingerprint">the documentation</a>, a fingerprint is a collection of useful information about the component that sends messages. It can be easily customized since all Postage objects expect it to be a dictionary, so any object that behaves like a dictionary works. The standard <code>Fingerprint</code> provided by Postage collects some useful properties from the OS and the RabbitMQ installation; here we customize the <code>name</code> value that otherwise would be set to <code>None</code>. The fingerprint, once loaded in a producer, will be automatically attached to any message the producer will send.</p>

<p>``` python
producer = facilities.PingProducer(fingerprint.as_dict())
producer.message_ping()</p>

<p>```</p>

<p>The <code>PingProducer</code> we declared in <code>facilities.py</code> is instanced, and its <code>message_ping()</code> method is invoked.
If you review the above paragraph you will notice that you never defined a <code>message_ping()</code> method; this is automatically implemented by the <code>GenericProducer</code> class from the <code>build_message_ping()</code> method. The class performs many actions under the hood: it executes some code to set up the correct RabbitMQ structures, calls your method to get the actual message data, attaches the fingerprint to the message, and serializes the message data. Eventually, the producer sends the message to the exchange defined in the class (<code>PingExchange</code>) with the linked routing key (<code>ping_rk</code>).</p>

<h4>The server program</h4>

<p>Now we will write a component that receives ping command messages and performs some action accordingly. Open a <code>receive_ping.py</code> file and write the following code</p>

<p>``` python
from postage import messaging
from postage import microthreads</p>

<p>import facilities</p>

<p>fingerprint = messaging.Fingerprint(name="ping_receiver")
```</p>

<p>that loads the modules we need and builds the fingerprint of this application. Creating a receiver means declaring a class that inherits from <code>MessageProcessor</code> and implements a method for each incoming message we want to process.</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>@messaging.MessageHandler('command', 'ping')
def msg_ping(self, content):
    print "Got a ping!"
</code></pre>

<p>```</p>

<p>As you can see here the <code>msg_ping()</code> method is declared as a handler for the command message <code>ping</code>; the name of the method is arbitrary, but it has to accept one parameter, namely the content of the incoming message (more on this later). In this case, when the object receives a ping message it just prints out a string.</p>

<p>``` python
eqks = [(facilities.PingExchange, [('ping_queue', 'ping_rk')])]
receiver = PingReceiver(fingerprint.as_dict(), eqks,</p>

<pre><code>                    None, messaging.global_vhost)
</code></pre>

<p>```</p>

<p>To start the receiver we have to connect it to an exchange; recall that the AMQP mechanism requires you to declare a queue and to connect it to an exchange through a key, which format depends on the exchange type. Being the <code>PingExchange</code> a direct exchange we want to connect to it with the exact routing key we want to match, that is <code>ping_rk</code>. The <code>eqks</code> structure is rather complex and may result overblown in such a simple context: it is a list of tuples in the form <code>(exchange_class, qk_list)</code> that links the given exchange class to a list of queues; this latter list contains tuples in the form <code>(queue_name, key)</code>. Each queue listed here connects to the exchange and fetches messages that match the linked key.</p>

<p>In this case, we simply subscribe the <code>facilities.PingExchange</code> exchange with a <code>ping_queue</code> queue receiving messages routed with the <code>ping_rk</code> key.</p>

<p>The receiver is then instanced. The arguments we pass are the fingerprint dictionary, the eqks we just discussed, a HUP tuple (Host, User, Password) to connect to RabbitMQ and the RabbitMQ virtualhost we want to use. In this case, we stick to the <a href="https://github.com/lgiordani/postage#environment-variables">default HUP</a> and to the default virtualhost.</p>

<p>``` python
scheduler = microthreads.MicroScheduler()
scheduler.add_microthread(receiver)</p>

<p>for i in scheduler.main():</p>

<pre><code>pass
</code></pre>

<p>```</p>

<p>This code creates a scheduler and adds the receiver, which is a <code>microthreads.Microthread</code>, then starts the execution loop.</p>

<h4>Execution</h4>

<p>Open two different shells on your system and execute the receiver in the first</p>

<p><code>text
$ python receive_ping.py
postage.messaging: global_vhost set to /
</code></p>

<p>and the sender in the second</p>

<p><code>text
$ python send_ping.py
postage.messaging: global_vhost set to /
$  
</code></p>

<p>The receiver shall at this point notify that a message has been sent</p>

<p><code>text
$ python receive_ping.py
postage.messaging: global_vhost set to /
Got a ping!
</code></p>

<p>which is what we expected. You can stop the receiver with <code>Ctrl-C</code>, this kills the Pika connection somehow abruptly, but I am not going to implement in this article a good signal management.</p>

<h4>Adding message parameters</h4>

<p>Now we want to add a parameter to the message we send, namely the time at which the message was sent. To do this we make some changes to <code>facilities.py</code></p>

<p>``` python
import time</p>

<p>[...]</p>

<p>class PingProducer(messaging.GenericProducer):</p>

<pre><code>eks = [(PingExchange, 'ping_rk')]

def build_message_ping(self):
    return messaging.MessageCommand('ping')

def build_message_timed_ping(self):
    return messaging.MessageCommand('timed_ping',
                                    parameters={'time':time.time()})
</code></pre>

<p>```</p>

<p>As you can see I just added the <code>build_message_timed_ping()</code> method, which sends a <code>timed_ping</code> command, but this time I added a <code>parameters</code> dictionary that encompasses all the parameters of the command. Remember that all the structures you put in a message are serialized in JSON by default so they must be processable by <code>json.dumps()</code>; if you need to send very complex structures you can customize Postage to use another encoder, either a customized JSON or a completely different one; see <a href="https://github.com/lgiordani/postage#encoder">the documentation</a>.</p>

<p>The receiver has to be modified accordingly:</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>@messaging.MessageHandler('command', 'ping')
def msg_ping(self, content):
    print "Got a ping!"

@messaging.MessageHandler('command', 'timed_ping')
def msg_timed_ping(self, content):
    print "Got a timed ping! Time is %s" %(content['parameters']['time'])
</code></pre>

<p>```</p>

<p>Here the new method, <code>msg_timed_ping()</code>, prints a different message extracting the parameters from the message content.
Last, you need to add the actual call that sends the message to <code>send_ping.py</code>:</p>

<p><code>python
producer = facilities.PingProducer(fingerprint.as_dict())
producer.message_ping()
producer.message_timed_ping()
</code></p>

<p>The execution shows that everything works as expected</p>

<p><code>text
$ python receive_ping.py
postage.messaging: global_vhost set to /
Got a ping!
Got a timed ping! Time is 1374826309.06
</code></p>

<h4>Adding call parameters</h4>

<p>If you want to allow the user to pass a parameter when sending the message, you just need to accept and use it in your <code>build_message_NAME()</code> method. In <code>facilities.py</code> add:</p>

<p>``` python
class PingProducer(messaging.GenericProducer):</p>

<pre><code>[...]
def build_message_custom_ping(self, custom_value):
    return messaging.MessageCommand('custom_ping',
                                parameters={'custom_value':custom_value})
</code></pre>

<p>```</p>

<p>Add a handler in the receiver (<code>receive_ping.py</code>):</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>[...]
@messaging.MessageHandler('command', 'custom_ping')
def msg_custom_ping(self, content):
    print "Got a custom ping! The custom value is %s"\
          %(content['parameters']['custom_value'])
</code></pre>

<p>```</p>

<p>And exploit it when sending the message (<code>send_ping.py</code>):</p>

<p><code>python
producer.message_custom_ping(("Just ping me", 1))
</code></p>

<p>When you execute it you get:</p>

<p><code>text
$ python receive_ping.py
postage.messaging: global_vhost set to /
Got a ping!
Got a timed ping! Time is 1374832738.18
Got a custom ping! The custom value is [u'Just ping me', 1]
</code></p>

<p>Pay attention to JSON, which does not tell apart tuples from lists.</p>

<h4>RPC calls to the rescue</h4>

<p>The ping mechanism is not really working until the server answers the message. To answer incoming messages we can implement two different strategies; the first is the asynchronous one, which leverages fire-and-forget messages, the second uses RPC calls. While the first is simpler to implement at a system level (you just send messages as usual), it is complex on the user side since it requires the programmer to structure the whole program in an asynchronous way. The second approach, resembling usual function calls, is easier to understand and include in a program; it has many downsides and caveats, however, so do not abuse it.</p>

<p>For the sake of simplicity let us implement a RPC version of the ping mechanism. First we add a specific message to the producer</p>

<p>``` python
class PingProducer(messaging.GenericProducer):</p>

<pre><code>[...]
def build_rpc_ping(self):
    return messaging.RpcCommand('ping')
</code></pre>

<p>```</p>

<p>Things are not very different from the previous cases here: we use the <code>build_rpc_NAME()</code> form of the method then we return an RpcCommand, instead of a MessageCommand. Beware that, alas!, nomenclature here is a little misleading: both are messages in the sense of "something that will be sent on the AMQP network", but while MessageCommand does not expect an answer, RpcCommand does.</p>

<p>I want to point out that the name of the message is <code>ping</code> just like the previous one; Postage tells the two messages apart using the name (<code>ping</code>), the type (<code>command</code>) and the category (<code>rpc</code> or <code>message</code>), although this latter is somewhat concealed.</p>

<p>The receiver needs a new handler to process the incoming RPC <code>ping</code> message:</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>[...]
@messaging.RpcHandler('command', 'ping')
def msg_rpc_ping(self, content, reply_func):
    print "Got a ping! Answering..."
    reply_func(messaging.MessageResult('Pong'))
</code></pre>

<p>```</p>

<p>Accordingly, there is an RPC version of <code>MessageHandler</code>, <code>RpcHandler</code>. The method has to accept an additional parameter that is a reply function; this latter can be called at any time from the method, allowing it to perform some cleanup after answering if needed. In this case, it simply sends a <code>MessageResult</code> object back with <code>'Pong'</code> as value.</p>

<p>In <code>send_ping.py</code> you can now make a remote call:</p>

<p>``` python
answer = producer.rpc_ping()</p>

<p>if answer.body['content']['type'] == 'success':</p>

<pre><code>print "Answer: %s" %(answer.body['content']['value'])
</code></pre>

<p>elif answer.body['content']['type'] == 'exception':</p>

<pre><code>print "An exception occoured! (%s)" %(answer.body['content']['value'])
</code></pre>

<p>```</p>

<p>The first part is straightforward: you call the RPC just like a local function. What you get is always a <code>MessageResult</code> object or derived (<code>MessageResultError</code> or <code>MessageResultException</code>). Be warned that the API here is awkward, to be indulgent. I wrote it, but probably the good-coder-in-me (TM) was on holiday that time; <a href="https://github.com/lgiordani/postage/issues/1">I am going to fix it</a> in a short time.</p>

<p>Anyway, you have to check the answer to be sure that the call was successful; never, never, never trust RPC calls, network is in the middle and everything can happen (yes, even someone tripping over the network cable).</p>

<p>If the receiver is unreachable the producer waits some time and then tries the call again: by default it waits 30 seconds and tries again 4 times; after all that it returns a <code>MessageResultException</code> containing a <code>TimeoutError</code> exception. You can try it changing the decorator of <code>msg_rpc_ping()</code> to match <code>ping_other</code> (or whatever) instead of <code>ping</code>. After two minutes, you will get your exception. You can easily customize these values by setting the value of <code>GenericProducer.rpc_timeout</code> and <code>GenericProducer.max_retry</code>.</p>

<h4>Handlers unleashed</h4>

<p>Message handlers are powerful, but there is a couple of tricks more in Postage. The first one is <code>MessageHandlerFullBody</code> that you can use exactly like <code>MessageHandler</code>; the difference is that the decorated method does not receive the message content (the <code>content</code> key of the body) but the full body. You can leverage this to access the underlying message structure: this allows you to access the fingerprint included in the message, which contains precious information about the process that sent the message. Let's show how it works; add a new handler to the receiver:</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>[...]
@messaging.MessageHandlerFullBody('command', 'ping')
def msg_ping_full(self, body):
    fingerprint = body['fingerprint']
    print "Got a ping from %s running on %s with pid %s"\
          %(fingerprint['name'], fingerprint['host'], fingerprint['pid'])
</code></pre>

<p>```</p>

<p>Here, we handle the <code>ping</code> command, just like the method <code>msg_ping()</code> does; indeed nothing stops you to write more than a handler for a given message, but remember that they are processed in random order. Obviously we need to give the decorated method a different name, otherwise the second one will redefine the first one. Being decorated with <code>MessageHandlerFullBody</code> the method receives the full body of the message and can access the fingerprint.</p>

<p>Executing it we get:</p>

<p><code>text
$ python receive_ping.py
postage.messaging: global_vhost set to staging
Got a ping from ping_sender running on yoda with pid 26812
Got a ping!
</code></p>

<p>As we expected both handlers have been activated by the incoming message, and, not surprisingly, they have been processed out of order.</p>

<p>The second trick handlers have in store for you is the Handler class. Instead of decorating a method you can define a class that inherits from <code>Handler</code> and decorate that; this class shall at least define a <code>call()</code> method without arguments (aside from <code>self</code>) that will be executed when the relative message arrives. This class can access <code>self.data</code>, which is the data passed by the decorator (either the message content or the full body), <code>self.reply_func</code> that defaults to <code>None</code> for non-RPC messages, and <code>self.processor</code> that is the underlying <code>MessageProcessor</code> object hosting the handler.</p>

<p>To show how it works let's add another handler to the receiver:</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>[...]
@messaging.MessageHandler('command', 'ping')
class MsgPing(messaging.Handler):
    def call(self):
        print "Got a ping - processed by %s hosted by %s"\
              %(self.__class__, self.processor.__class__)
</code></pre>

<p>```</p>

<p>You can see that the definition of a basic handler class is pretty simple. When executed this gives the following:</p>

<p>``` text
$ python receive_ping.py
postage.messaging: global_vhost set to staging
Got a ping - processed by <class '__main__.MsgPing'></p>

<pre><code>         hosted by &lt;class '__main__.PingReceiver'&gt;
</code></pre>

<p>Got a ping from ping_sender running on yoda with pid 27596
Got a ping!
```</p>

<p>Leveraging the full body access and the class handlers you can write advanced filters on incoming messages, and add interesting features like runtime configuration of your handlers or configuration through incoming messages.</p>

<h2>Full code</h2>

<p>This is the full code of the discussed examples.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (facilities.py)</span> <a href='/downloads/code/postage/facilities.py'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">postage</span> <span class="kn">import</span> <span class="n">messaging</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PingExchange</span><span class="p">(</span><span class="n">messaging</span><span class="o">.</span><span class="n">Exchange</span><span class="p">):</span>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;This is the exchange that receives ping messages.&quot;&quot;&quot;</span>
</span><span class='line'>    <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ping-exchange&quot;</span>
</span><span class='line'>    <span class="n">exchange_type</span> <span class="o">=</span> <span class="s">&quot;direct&quot;</span>
</span><span class='line'>    <span class="n">passive</span> <span class="o">=</span> <span class="bp">False</span>
</span><span class='line'>    <span class="n">durable</span> <span class="o">=</span> <span class="bp">True</span>
</span><span class='line'>    <span class="n">auto_delete</span> <span class="o">=</span> <span class="bp">False</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PingProducer</span><span class="p">(</span><span class="n">messaging</span><span class="o">.</span><span class="n">GenericProducer</span><span class="p">):</span>
</span><span class='line'>    <span class="c"># Send messages to this exchange with this routing key</span>
</span><span class='line'>    <span class="n">eks</span> <span class="o">=</span> <span class="p">[(</span><span class="n">PingExchange</span><span class="p">,</span> <span class="s">&#39;ping_rk&#39;</span><span class="p">)]</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Send a &#39;ping&#39; command</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">build_message_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">messaging</span><span class="o">.</span><span class="n">MessageCommand</span><span class="p">(</span><span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Send a &#39;timed_ping&#39; command</span>
</span><span class='line'>    <span class="c"># Parameters: time</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">build_message_timed_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">messaging</span><span class="o">.</span><span class="n">MessageCommand</span><span class="p">(</span><span class="s">&#39;timed_ping&#39;</span><span class="p">,</span>
</span><span class='line'>	    <span class="n">parameters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">:</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()})</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Send a &#39;custom_ping&#39; command</span>
</span><span class='line'>    <span class="c"># Parameters: custom_value</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">build_message_custom_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">custom_value</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">messaging</span><span class="o">.</span><span class="n">MessageCommand</span><span class="p">(</span><span class="s">&#39;custom_ping&#39;</span><span class="p">,</span>
</span><span class='line'>	    <span class="n">parameters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;custom_value&#39;</span><span class="p">:</span><span class="n">custom_value</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Send a &#39;ping&#39; RPC command</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">build_rpc_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">messaging</span><span class="o">.</span><span class="n">RpcCommand</span><span class="p">(</span><span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (send_ping.py)</span> <a href='/downloads/code/postage/send_ping.py'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">postage</span> <span class="kn">import</span> <span class="n">messaging</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">facilities</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Build the fingerprint of this application</span>
</span><span class='line'><span class="n">fingerprint</span> <span class="o">=</span> <span class="n">messaging</span><span class="o">.</span><span class="n">Fingerprint</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;ping_sender&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Instance the ping producer</span>
</span><span class='line'><span class="n">producer</span> <span class="o">=</span> <span class="n">facilities</span><span class="o">.</span><span class="n">PingProducer</span><span class="p">(</span><span class="n">fingerprint</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Send a &#39;ping&#39; command</span>
</span><span class='line'><span class="n">producer</span><span class="o">.</span><span class="n">message_ping</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Send a &#39;timed_ping&#39; command</span>
</span><span class='line'><span class="n">producer</span><span class="o">.</span><span class="n">message_timed_ping</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Send a &#39;custom_ping&#39; command</span>
</span><span class='line'><span class="n">producer</span><span class="o">.</span><span class="n">message_custom_ping</span><span class="p">((</span><span class="s">&quot;Just ping me&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Send a &#39;ping&#39; RPC call</span>
</span><span class='line'><span class="n">answer</span> <span class="o">=</span> <span class="n">producer</span><span class="o">.</span><span class="n">rpc_ping</span><span class="p">()</span>
</span><span class='line'><span class="k">if</span> <span class="n">answer</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="s">&#39;content&#39;</span><span class="p">][</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;success&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;Answer: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">answer</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="s">&#39;content&#39;</span><span class="p">][</span><span class="s">&#39;value&#39;</span><span class="p">])</span>
</span><span class='line'><span class="k">elif</span> <span class="n">answer</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="s">&#39;content&#39;</span><span class="p">][</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;exception&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;An exception occoured! (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">answer</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="s">&#39;content&#39;</span><span class="p">][</span><span class="s">&#39;value&#39;</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (receive_ping.py)</span> <a href='/downloads/code/postage/receive_ping.py'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">postage</span> <span class="kn">import</span> <span class="n">messaging</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">postage</span> <span class="kn">import</span> <span class="n">microthreads</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">facilities</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Build the fingerprint of this application</span>
</span><span class='line'><span class="n">fingerprint</span> <span class="o">=</span> <span class="n">messaging</span><span class="o">.</span><span class="n">Fingerprint</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;ping_receiver&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PingReceiver</span><span class="p">(</span><span class="n">messaging</span><span class="o">.</span><span class="n">MessageProcessor</span><span class="p">):</span>
</span><span class='line'>    <span class="c"># Process an incoming &#39;ping&#39; command</span>
</span><span class='line'>    <span class="nd">@messaging.MessageHandler</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">msg_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Got a ping!&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Process an incoming &#39;timed_ping&#39; command</span>
</span><span class='line'>    <span class="nd">@messaging.MessageHandler</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;timed_ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">msg_timed_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Got a timed ping! Time is </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">content</span><span class="p">[</span><span class="s">&#39;parameters&#39;</span><span class="p">][</span><span class="s">&#39;time&#39;</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Process an incoming &#39;custom_ping&#39; command</span>
</span><span class='line'>    <span class="nd">@messaging.MessageHandler</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;custom_ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">msg_custom_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Got a custom ping! The custom value is </span><span class="si">%s</span><span class="s">&quot;</span>\
</span><span class='line'>	    <span class="o">%</span><span class="p">(</span><span class="n">content</span><span class="p">[</span><span class="s">&#39;parameters&#39;</span><span class="p">][</span><span class="s">&#39;custom_value&#39;</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Process an incoming &#39;ping&#39; RPC command</span>
</span><span class='line'>    <span class="nd">@messaging.RpcHandler</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">msg_rpc_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">reply_func</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Got a ping! Answering...&quot;</span>
</span><span class='line'>        <span class="n">reply_func</span><span class="p">(</span><span class="n">messaging</span><span class="o">.</span><span class="n">MessageResult</span><span class="p">(</span><span class="s">&#39;Pong&#39;</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Process the full body of an incoming &#39;ping&#39; command</span>
</span><span class='line'>    <span class="nd">@messaging.MessageHandlerFullBody</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">msg_ping_full</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
</span><span class='line'>        <span class="n">fingerprint</span> <span class="o">=</span> <span class="n">body</span><span class="p">[</span><span class="s">&#39;fingerprint&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Got a ping from </span><span class="si">%s</span><span class="s"> running on </span><span class="si">%s</span><span class="s"> with pid </span><span class="si">%s</span><span class="s">&quot;</span>\
</span><span class='line'>	    <span class="o">%</span><span class="p">(</span><span class="n">fingerprint</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">],</span> <span class="n">fingerprint</span><span class="p">[</span><span class="s">&#39;host&#39;</span><span class="p">],</span> <span class="n">fingerprint</span><span class="p">[</span><span class="s">&#39;pid&#39;</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Process an incoming &#39;ping&#39; command with a class handler</span>
</span><span class='line'>    <span class="nd">@messaging.MessageHandler</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">MsgPing</span><span class="p">(</span><span class="n">messaging</span><span class="o">.</span><span class="n">Handler</span><span class="p">):</span>
</span><span class='line'>        <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>            <span class="k">print</span> <span class="s">&quot;Got a ping - processed by </span><span class="si">%s</span><span class="s"> hosted by </span><span class="si">%s</span><span class="s">&quot;</span>\
</span><span class='line'>		<span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Exchange/Queue/Key</span>
</span><span class='line'><span class="n">eqks</span> <span class="o">=</span> <span class="p">[(</span><span class="n">facilities</span><span class="o">.</span><span class="n">PingExchange</span><span class="p">,</span> <span class="p">[(</span><span class="s">&#39;ping_queue&#39;</span><span class="p">,</span> <span class="s">&#39;ping_rk&#39;</span><span class="p">)])]</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Instance the receiver</span>
</span><span class='line'><span class="n">receiver</span> <span class="o">=</span> <span class="n">PingReceiver</span><span class="p">(</span><span class="n">fingerprint</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span> <span class="n">eqks</span><span class="p">,</span>
</span><span class='line'>			<span class="bp">None</span><span class="p">,</span> <span class="n">messaging</span><span class="o">.</span><span class="n">global_vhost</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Instance the scheduler and run the receiver</span>
</span><span class='line'><span class="n">scheduler</span> <span class="o">=</span> <span class="n">microthreads</span><span class="o">.</span><span class="n">MicroScheduler</span><span class="p">()</span>
</span><span class='line'><span class="n">scheduler</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">receiver</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">main</span><span class="p">():</span>
</span><span class='line'>    <span class="k">pass</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>Conclusion</h2>

<p>Postage aims to make it simple to write components in Python to fully exploit the power of RabbitMQ. It is highly customizable, and its handler mechanism keeps the code compact.</p>

<p>Even if the API is already in its third implementation, you can see that it is still not perfect so stay tuned for upcoming versions. Feel free to fork the project, to submit issues or pull request, or to contact me for any question.</p>

<p>Oh, did I remember to tell you to never trust RPC calls? =)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Generators - From Iterators to Cooperative Multitasking - 3]]></title>
    <link href="http://lgiordani.github.io/blog/2013/03/29/python-generators-from-iterators-to-cooperative-multitasking-3/"/>
    <updated>2013-03-29T13:25:00+01:00</updated>
    <id>http://lgiordani.github.io/blog/2013/03/29/python-generators-from-iterators-to-cooperative-multitasking-3</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>In this third issue we move on uncovering how generators can be the foundation of a cooperative multitasking system and show some code that implements it. Before we face this topic we will talk shortly about another interesting use of generators, namely generator expressions chains.</p>

<!--more-->


<h2>Chaining generator expressions</h2>

<p>At PyCon 2008 David M. Beazley, author of Python Essential Reference, made a very interesting speech about the use of generators in system administration, in other words where usually more or less complex bash scripts are involved and in particular where long pipe sequences are used.</p>

<p>David starts from the consideration that generators, producing one element at a time, are chainable, that is a generator expression can encompass another generator expression and so on. This way he shows how to write in a very compact and reusable way components that can act as filters on a data set, thus following the Unix philosophy of building tools that do one thing and do it well, chaining them afterwards to get the needed behaviour.</p>

<p>The slides of this presentation are freely downloadable, so I suggest the interested reader to take a look at it at the following address: <a href="http://www.dabeaz.com/generators-uk/">Generator Tricks for Systems Programmers</a>.</p>

<h2>Microthread: cooperative multitasking</h2>

<p><em>Disclaimer: the concepts and code presented here have been heavily influenced by the Kamaelia project. You can find it <a href="http://www.kamaelia.org">here</a>.</em></p>

<p>Let us move forward to see how (Python) generators allow us to easily build applications based on the concept of cooperative multitasking. I assume the reader is familiar with the concepts of preemption and thread-based multitasking and is aware of the pro and cons of such solutions.</p>

<p><strong>Cooperative multitasking</strong> allows an application to hold the control of the CPU for an arbitrary time lapse, waiting for it to voluntarily release the resource to the scheduler. This is a major break with the modern approach to multitasking, where the scheduler is in charge of stopping and resuming applications without any previous agreement with them.</p>

<p>Since application can now stop on their own initiative every issue related to shared data protection, atomicity and synchronization is greatly simplified if not removed. Applications need however a mechanism to stop running, save their internal state and later resume from the same point.</p>

<p>Generators, indeed, through the <code>yield</code> statement implement this very behaviour, thus they may be used to create a system based on cooperative multitasking, where processes are now called <strong>microthreads</strong> to highlight that they are a lightweight form of thread.</p>

<h4>Microthreads</h4>

<p>Lets look at a simple implementation of such a system. First of all we need a <code>MicroThread</code> object, i.e. an object that can run simultaneously with other similar objects, but in a cooperative way.</p>

<p>```python
class MicroThread(object):</p>

<pre><code>def main(self):
    while 1:
        yield 1
</code></pre>

<p>```</p>

<p>An instance of this object exposes a <code>main()</code> method that, when called, returns a generator. This latter, at each call of its <code>next()</code> method simply returns <code>1</code>, freezing at the same time its execution just after the <code>yield</code> statement, still inside the infinite while loop.</p>

<p>The object can be directly tested</p>

<p>```bash</p>

<blockquote><blockquote><blockquote><p>mt = MicroThread()
g = mt.main()
g
<generator object main at 0xb74331e4>
g.next()
1
```</p></blockquote></blockquote></blockquote>

<p>To make the object more easily inheritable and extendable we can refactor it a little</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (mthread.py)</span> <a href='/downloads/code/python-generators/mthread.py'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">MicroThread</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
</span><span class='line'>        <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</span><span class='line'>            <span class="k">yield</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Such changes let us inherit the class and extend it simply by overriding the <code>create()</code> and <code>step()</code> methods; the first is called as soon as <code>main()</code> is called, acting as a delayed initializer, while the second is executed at each call of <code>next()</code>, just before freezing the code with <code>yield</code>. Pay attention that since <code>create()</code> is called inside the generator function, you have to call <code>next()</code> once to run it after the genrator has been created. So the standard workflow with this object is</p>

<p>```python</p>

<h1>Instance the object</h1>

<p>mt = MicroThread()</p>

<h1>Create the generator</h1>

<p>g = mt.main()</p>

<h1>Initialize it</h1>

<p>g.next()</p>

<h1>Loop over it</h1>

<p>g.next()
g.next()
...
```</p>

<p>Since <code>main()</code> is a generator function it must act as any generator and signal its exhaustion rising a <code>StopIteration</code> exception. The overridden <code>step()</code> method, thus, may raise this exception at any point (even multiple ones) to terminate the microthread.</p>

<h4>Scheduler</h4>

<p>Now we need a scheduler, i.e. the system component that manages running tasks. While in a true multitasking system the scheduler is a big and complex component, in a cooperative environment it can be rather simple: its job is to execute each task and wait till they give control back. In between a task and the following the scheduler can execute other functions, but its basic workflow is very straightforward. Obviously the scheduler shall handle the <code>StopIteration</code> exception possibly raised by a task, removing it from the list of running microthreads.</p>

<p>The core of the scheduler will be something like the following:</p>

<p>```python
for thread in active_microthreads:</p>

<pre><code>try:
    thread.next()
    scheduled_microthreads.append(thread)
except StopIteration:
    pass
</code></pre>

<p>active_microthreads = scheduled_microthreads
scheduled_microthreads = []
```</p>

<p>This snippet encompasses the behaviour described above. We have two lists, <code>active_microthreads</code> with all the tasks that shall be executed in the current loop and <code>scheduled_microthreads</code> with all the tasks that are goig to be executed in the next loop. At each loop of the scheduler all microthreads in <code>active_microthreads</code> are executed, that is they are granted one execution of their <code>next()</code> function. After this the thread is scheduled again, i.e. it is appended to the <code>scheduled_microthreads</code> list. If the thread raises the <code>StopIteration</code> exception during its execution it is simply not scheduled again. When the <code>active_microthreads</code> list is exhausted the loop ends and the scheduled threads list is transferred in the <code>active_threads</code> one; after this the loop starts again.</p>

<p>So the first implementation of the scheduler is the following:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (scheduler.py)</span> <a href='/downloads/code/python-generators/scheduler.py'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">Scheduler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">add_microthread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mthread</span><span class="p">):</span>
</span><span class='line'>        <span class="n">g</span> <span class="o">=</span> <span class="n">mthread</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</span><span class='line'>        <span class="n">g</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="p">:</span>
</span><span class='line'>                <span class="k">try</span><span class="p">:</span>
</span><span class='line'>                    <span class="n">thread</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>                    <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thread</span><span class="p">)</span>
</span><span class='line'>                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
</span><span class='line'>                    <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The <code>__init__()</code> method initializes the two internal lists we talked about above. The <code>add_microthread()</code> method allows us to add a microthread to the scheduler; the method calls <code>main()</code> on each microthread we add to obtain its generator, then calls <code>next()</code> once on this latter to initialize it and finally adds it to the list of scheduled tasks.</p>

<p>The scheduler logic is then implemented in the <code>run()</code> method, which executes the above core code in an infinite while loop.</p>

<p>We can test the microthreads and the scheduler with this simple code</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (test_scheduler.py)</span> <a href='/downloads/code/python-generators/test_scheduler.py'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">mthread</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">scheduler</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">TestMicroThread</span><span class="p">(</span><span class="n">mthread</span><span class="o">.</span><span class="n">MicroThread</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">number</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Number:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span>
</span><span class='line'>        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">mt1</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">mt2</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">mt3</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">ms</span> <span class="o">=</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">Scheduler</span><span class="p">()</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt1</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt2</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Here the <code>TestMicroThread</code> is a microthread but the <code>step()</code> method was reimplemented to print a number and wait 1 second. Three microthreads are instanced and added to the scheduler and the <code>run()</code> method of the scheduler is executed. Not surprisingly the result is the following</p>

<p><code>bash
$ python test_scheduler.py
Number: 1
Number: 2
Number: 3
Number: 1
Number: 2
Number: 3
[...]
</code></p>

<p>The three microthreads are executed in a round-robin fashion, as expected from a cooperative multitasking system.</p>

<p>Note: while all microthreads showed in this article just execute <code>yield 1</code> to freeze the code, <code>yield</code> can return any object, just like the <code>return</code> statement does, and this could be exploited to enhance the communication between microthreads and scheduler.</p>

<h4>Microschedulers</h4>

<p>The scheduler could however be more flexible, specifically it could be converted to a microthread itself. The scheduler, when executed, will return a generator, and each call of its <code>next()</code> method will run one of its microthreads. After this the scheduler will freeze and give control back.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (mscheduler.py)</span> <a href='/downloads/code/python-generators/mscheduler.py'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">MicroScheduler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">add_microthread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mthread</span><span class="p">):</span>
</span><span class='line'>        <span class="n">g</span> <span class="o">=</span> <span class="n">mthread</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</span><span class='line'>        <span class="n">g</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>                <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="p">:</span>
</span><span class='line'>                <span class="k">try</span><span class="p">:</span>
</span><span class='line'>                    <span class="n">thread</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>                    <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thread</span><span class="p">)</span>
</span><span class='line'>                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
</span><span class='line'>                    <span class="k">pass</span>
</span><span class='line'>                <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It is sufficient to rename <code>run()</code> to <code>main()</code>, to match our arbitrary microthread interface, and add some <code>yield</code> statements. The first <code>yield</code> at the beginning of <code>main()</code> terminates the creation part: this scheduler has no <code>create()</code> method, but if present it should be called here. The second <code>yield</code> is called if the scheduler contains no microthreads, since it has nothing to do. The third <code>yield</code> is called after each loop of the microthread running part.</p>

<p>These little changes allow the scheduler to be run into another scheduler, thus enabling us to create a hierarchy to easily build complex systems. At the same time the scheduler can be used as usual simply calling its <code>next()</code> method in a for loop.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (test_mscheduler.py)</span> <a href='/downloads/code/python-generators/test_mscheduler.py'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">mthread</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">mscheduler</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">TestMicroThread</span><span class="p">(</span><span class="n">mthread</span><span class="o">.</span><span class="n">MicroThread</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">number</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Number:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span>
</span><span class='line'>        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">mt1</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">mt2</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">mt3</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">ms</span> <span class="o">=</span> <span class="n">mscheduler</span><span class="o">.</span><span class="n">MicroScheduler</span><span class="p">()</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt1</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt2</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">main</span><span class="p">():</span>
</span><span class='line'>    <span class="k">pass</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This example is obviously very simple. However it shows how simple it is to build components of a cooperative system and let them live together in an execution space. Executing the scheduler in a different way, for example inside another generator, new microthreads can also be added live. This allows to instance system components on the fly to manage specific needs, such as incoming service requests.</p>

<h2>Conclusions</h2>

<p>Obviously this sort of multitasking cannot provide an interactive execution like that used on our desktop OS or on a Web server, where human users must receive an immediate feedback of their actions. But for systems where task must simply be simultaneously executed without timing needs cooperative multitasking is a valuable solution, due to its simplicity.</p>

<p>Another interesting scenario is that of a real multitasking system (ruled by threaded code or by the OS itself) where each task is made of small cooperating components. This way putting multiple functionalities inside a single component becomes a breeze; the code of each functionality could also be splitted in several plugins and loaded on demand.</p>

<p>A package that implements cooperative multitasking with generator based microthreads is <a href="http://www.kamaelia.org">Kamaelia</a>, and this article has been heavily inspired by it. Other solutions you can find interesting are <a href="http://pypi.python.org/pypi/greenlet">greenlet</a>, presently the most used microthread Python library that runs on the standard unmodified Python interpreter and <a href="http://www.stackless.com/">Stackless Python</a>, a fork of Python that natively implements microthreads.</p>

<h2>Updates</h2>

<p>2014-02-17: <a href="https://twitter.com/entropiae">Riccardo</a> spotted an error in the example code after <code>mthread.py</code> and submitted the correct version. Thanks!</p>

<h2>Past articles</h2>

<ul>
<li><a href="/blog/2013/03/25/python-generators-from-iterators-to-cooperative-multitasking">Python Generators - From Iterators to Cooperative Multitasking</a></li>
<li><a href="/blog/2013/03/26/python-generators-from-iterators-to-cooperative-multitasking-2">Python Generators - From Iterators to Cooperative Multitasking 2</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
