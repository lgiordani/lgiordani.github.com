<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | The digital cat]]></title>
  <link href="http://lgiordani.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://lgiordani.github.io/"/>
  <updated>2014-04-07T08:20:25+02:00</updated>
  <id>http://lgiordani.github.io/</id>
  <author>
    <name><![CDATA[Leonardo Giordani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OOP concepts in Python 2.x - Part 2]]></title>
    <link href="http://lgiordani.github.io/blog/2014/03/10/oop-concepts-in-python-2-dot-x-part-2/"/>
    <updated>2014-03-10T18:56:56+01:00</updated>
    <id>http://lgiordani.github.io/blog/2014/03/10/oop-concepts-in-python-2-dot-x-part-2</id>
    <content type="html"><![CDATA[<h2>Abstract</h2>

<p>This post continues the analysis of the Python OOP implementation started with <a href="/blog/2014/03/05/oop-concepts-in-python-2-dot-x-part-1">this post</a>, which I recommend reading before taking on this new one.</p>

<p>This second post discusses the following OOP features in Python:</p>

<ul>
<li>Polymorphism</li>
<li>Classes and instances (again)</li>
<li>Metaclasses</li>
<li>Object creation</li>
</ul>


<p><em>This post refers to the internals of Python 2.x - please note that Python 3.x changes (improves!) some of the features shown here. As soon as I feel comfortable with my Python 3 knowledge, I will post an update.</em></p>

<!--more-->


<h2>Good Morning, Polymorphism</h2>

<p>The term <em>polymorphism</em>, in the OOP lingo, refers to the ability of an object to adapt the code to the type of the data it is processing.</p>

<p>Polymorphism has two major applications in an OOP language. The first is that an object may provide different implementations of one of its methods depending on the type of the input parameters. The second is that code written for a given type of data may be used on data with a derived type, i.e. methods understand the class hierarchy of a type.</p>

<p>In Python polymorphism is one of the key concepts, and we can say that it is a built-in feature. Let us deal with it step by step.</p>

<p>First of all, you know that in Python the type of a variable is not explicitly declared. Beware that this does not mean that Python variables are <em>untyped</em>. On the contrary, everything in Python has a type, it just happens that the type is implicitly assigned. If you remember the last paragraph of the previous post, I stated that in Python variables are just pointers (using a C-like nomenclature), in other words they just tell the language <em>where</em> in memory a variable has been stored. What is stored at that address is not a business of the variable.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>a = 5
a
5
type(a)
<type 'int'>
hex(id(a))
'0x89812b0'
a = "five"
a
'five'
type(a)
<type 'str'>
hex(id(a))
'0xb74bb280L'
```</p></blockquote></blockquote></blockquote>

<p>This little example shows a lot about the Python typing system. The variable <code>a</code> is not statically declared, after all it can contain only one type of data: a memory address. When we assign the number 5 to it, Python stores in <code>a</code> the <em>address</em> of the number 5 (<code>0x89812b0</code> in my case, but your result will be different). The <code>type()</code> built-in function is smart enough to understand that we are not asking about the type of <code>a</code> (which is always a reference), but about the type of the content. When you store another value in <code>a</code>, the string <code>"five"</code>, Python shamelessly replaces the previous content of the variable with the new address.</p>

<p>So, thanks to the reference system, Python type system is both <em>strong</em> and <em>dynamic</em>. The exact definition of those two concepts is not universal, so if you are interested be ready to dive into a broad matter. However, in Python, the meaning of those two words is the following:</p>

<ul>
<li>type system is <em>strong</em> because everything has a well-defined type, that you can check with the <code>type()</code> built-in</li>
<li>type system is <em>dynamic</em> since the type of a variable is not explicitly declared, but changes with the content</li>
</ul>


<p>Onward! We just scratched the surface of the whole thing.</p>

<p>To explore the subject a little more, try to define the simplest function in Python (apart from an empty function)</p>

<p>``` python
def echo(a):</p>

<pre><code>return a
</code></pre>

<p>```</p>

<p>Pretty straightforward, isn't it? Well, if you come from a statically compiled language such as C or C++ you should be at least puzzled. What is <code>a</code>? I mean: what type of data does it contain? Moreover, how can Python know what it is returning if there is no type specification?</p>

<p>Again, if you recall the references stuff everything becomes clear: that function accepts a reference and returns a reference. In other words we just defined a sort of universal function, that does the same thing regardless of the input.</p>

<p>This is exactly the problem that polymorphism wants to solve. We want to describe an action regardless of the type of objects, and this is what we do when we talk among humans. When you describe how to move an object by pushing it, you may explain it using a box, but you expect the person you are addressing to be able to repeat the action even if you need to move a pen, or a book, or a bottle.</p>

<p>There are two main strategies you can apply to get code that performs the same operation regardless of the input types.</p>

<p>The first approach is to cover all cases, and this is a typical approach of procedural languages. If you need to sum two numbers that can be integers, float or complex, you just need to write three <code>sum()</code> functions, one bound to the integer type, the second bound to the float type and the third bound to the complex type, and to have some language feature that takes charge of choosing the correct implementation depending on the input type. This logic can be implemented by a compiler (if the language is statically typed) or by a runtime environment (if the language is dynamically typed) and is the approach chosen by C++. The disadvantage of this solution is that it requires the programmer to forecast all the possible situations: what if I need to sum an integer with a float? What if I need to sum two lists? (Please note that C++ is not so poorly designed, and the operator overloading technique allows to manage such cases, but the base polymorphism strategy of that language is the one exposed here).</p>

<p>The second strategy, the one implemented by Python, is simply to require the input objects to solve the problem for you. In other words you <em>ask the data itself to perform the operation</em>, reversing the problem. Instead of writing a bunch on functions that sum all the possible types in every possible combination you just write one function that requires the input data to sum, trusting that they know how to do it. Does it sound complex? It is not.</p>

<p>Let's look at the Python implementation of the <code>+</code> operator. When we write <code>c = a + b</code>, Python actually executes <code>c = a.__add__(b)</code>. As you can see the sum operation is delegated to the first input variable. So if we write</p>

<p>``` python
def sum(a, b):</p>

<pre><code>return a + b
</code></pre>

<p>```</p>

<p>there is no need to specify the type of the two input variables. The object <code>a</code> (the object contained in the variable <code>a</code>) shall be able to sum with the object <code>b</code>. This is a very beautiful and simple implementation of the polymorphism concept. Python functions are polymorphic simply because they accept everything and trust the input data to be able to perform some actions.</p>

<p>Let us consider another simple example before moving on. The built-in <code>len()</code> function returns the length of the input object. For example</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>l = [1, 2, 3]
len(l)
3
s = "Just a sentence"
len(s)
15
```</p></blockquote></blockquote></blockquote>

<p>As you can see it is perfectly polymorphic: you can feed both a list or a string to it and it just computes its length. Does it work with any type? let's check</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>d = {'a': 1, 'b': 2}
len(d)
2
i = 5
len(i)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: object of type 'int' has no len()
```</p></blockquote></blockquote></blockquote>

<p>Ouch! Seems that the <code>len()</code> function is smart enough to deal with dictionaries, but not with integers. Well, after all, the length of an integer is not defined.</p>

<p>Indeed this is exactly the point of Python polymorphism: <em>the integer type does not define a length operation</em>. While you blame the <code>len()</code> function, the <code>int</code> type is at fault. The <code>len()</code> function just calls the <code>__len__()</code> method of the input object, as you can see from this code</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>l.<strong>len</strong>()
3
s.<strong>len</strong>()
15
d.<strong>len</strong>()
2
i.<strong>len</strong>()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'int' object has no attribute '<strong>len</strong>'
```</p></blockquote></blockquote></blockquote>

<p>but the <code>'int' object</code> does not define any <code>__len__()</code> method.</p>

<p>So, to sum up what we discovered until here, I would say that <em>Python polymorphism is based on delegation</em>. In the following sections we will talk about the <a href="http://docs.python.org/2/glossary.html#term-eafp">EAFP</a> Python principle, and you will see that the delegation principle is somehow ubiquitous in this language.</p>

<h2>Type Hard</h2>

<p>Another real-life concept that polymorphism wants to bring into a programming language is the ability to walk the class hierarchy, that is <em>to run code on specialized types</em>. This is a complex sentence to say something we are used to do every day, and an example will clarify the matter.</p>

<p>You know how to open a door, it is something you learned in your early years. Under an OOP point of view you are an object (sorry, no humiliation intended) which is capable of interacting with a wood rectangle rotating on hinges. When you can open a door, however, you can also open a window, which, after all, is a specialized type of wood-rectangle-with-hinges, hopefully with some glass in it too. You are also able to open the car door, which is also a specialized type (this one is a mix between a standard door and a window). This shows that, once you know how to interact with the most generic type (basic door) you can also interact with specialized types (window, car door) as soon as they act like the ancestor type (e.g. as soon as they rotate on hinges).</p>

<p>This directly translates into OOP languages: polymorphism requires that <em>code written for a given type may also be run on derived types</em>. For example, a list (a generic list object, not a Python one) that can contain "numbers" shall be able to accept integers because they <em>are</em> numbers. The list could specify an ordering operation which requires the numbers to be able to compare each other. So, as soon as integers specify a way to compare each other they can be inserted into the list and ordered.</p>

<p>Statically compiled languages shall provide specific language features to implement this part of the polymorphism concept. In C++, for example, the language needs to introduce the concept of pointer compatibility between parent and child classes.</p>

<p>In Python there is no need to provide special language features to implement subtype polymorphism. As we already discovered Python functions accept any variable without checking the type and rely on the variable itself to provide the correct methods. But you already know that a subtype must provide the methods of the parent type, either redefining them or through implicit delegation, so as you can see Python implements subtype polymorphism from the very beginning.</p>

<p>I think this is one of the most important things to understand when working with this language. Python is not really interested in the actual type of the variables you are working with. It is interested in how those variables act, that is it just wants the variable <em>to provide the right methods</em>. So, if you come from statically typed languages, you need to make a special effort to think about <em>acting like</em> instead of <em>being</em>. This is what we called "duck typing".</p>

<p>Time to do an example. Let us define a <code>Room</code> class</p>

<p>``` python
class Room(object):</p>

<pre><code>def __init__(self, door):
    self.door = door

def open(self):
    self.door.open()

def close(self):
    self.door.close()

def is_open(self):
    return self.door.is_open()
</code></pre>

<p>```</p>

<p>A very simple class, as you can see, just enough to exemplify polymorphism. The <code>Room</code> class accepts a <code>door</code> variable, and the type of this variable is not specified. Duck typing in action: the actual type of <code>door</code> is not declared, there is no "acceptance test" built in the language. Indeed, the incoming variable shall export the following methods that are used in the <code>Room</code> class: <code>open()</code>, <code>close()</code>, <code>is_open()</code>. So we can build the following classes</p>

<p>``` python
class Door(object):</p>

<pre><code>def __init__(self):
    self.status = "closed"

def open(self):
    self.status = "open"

def close(self):
    self.status = "closed"

def is_open(self):
    return self.status == "open"
</code></pre>

<p>class BooleanDoor(object):</p>

<pre><code>def __init__(self):
    self.status = True

def open(self):
    self.status = True

def close(self):
    self.status = False

def is_open(self):
    return self.status
</code></pre>

<p>```</p>

<p>Both represent a door that can be open or closed, and they implement the concept in two different ways: the first class relies on strings, while the second leverages booleans. Despite <em>being</em> two different types, both <em>act</em> the same way, so both can be used to build a <code>Room</code> object.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door = Door()
bool_door = BooleanDoor()
room = Room(door)
bool_room = Room(bool_door)</p>

<p>room.open()
print room.is_open()
True
room.close()
print room.is_open()
False</p>

<p>bool_room.open()
print bool_room.is_open()
True
bool_room.close()
print bool_room.is_open()
False
```</p></blockquote></blockquote></blockquote>

<h4>File Like Us</h4>

<p>File-like objects are a concrete and very useful example of polymorphism in Python. A file-like object is a class (or the instance of a class) that acts like a file, i.e. it provides those methods a file object exposes.</p>

<p>Say for example that you code a class that parses an XML tree, and that you expect the XML code to be contained in a file. So your class accepts a file in its <code>__init__()</code> method, and reads the content from it</p>

<p>``` python
class XMLReader(object):</p>

<pre><code>def __init__(xmlfile):
    xmlfile.open()
    self.content = xmlfile.read()
    xmlfile.close()
</code></pre>

<p>[...]
```</p>

<p>The class works well until your application shall be modified to receive XML content from a network stream. To use the class without modifying it you shall write the stream in a temporary file and load this latter, but this sounds a little overkill. So you plan to change the class to accept a string, but this way you shall change every single code that uses the class to read a file, since now you shall open, read and close the file on your own, outside the class.</p>

<p>Polymorphism offers a better way. Why not store the incoming stream inside an object that <em>acts like</em> a file, even if it is not an actual one? If you check the StringIO module you will find that such an object has been already invented and provided in the standard Python library.</p>

<p>Other very useful file-like classes are those contained in the <code>gzip</code>, <code>bz2</code>, and <code>zipfile</code> modules (just to name some of the most used), which provide objects that allow you to manage compressed files just like plain files, hiding the decompression/compression machinery.</p>

<h2>Unforgiveness</h2>

<p>EAFP is a Python acronym that stands for <em>easier to ask for forgiveness than permission</em>. This coding style is highly pushed in the Python community because it completely relies on the duck typing concept, thus fitting well with the language philosophy.</p>

<p>The concept behind EAFP is fairly easy: instead of checking if an object has a given attribute or method before actually accessing or using it, just trust the object to provide what you need and manage the error case. This can be probably better understood by looking at some code. According to EAFP, instead of writing</p>

<p>``` python
if hasattr(someobj, 'open'):</p>

<pre><code>[...]
</code></pre>

<p>else:</p>

<pre><code>[...]
</code></pre>

<p>```</p>

<p>you shall write</p>

<p>``` python
try:</p>

<pre><code>someobj.open()
[...]
</code></pre>

<p>except AttributeError:</p>

<pre><code>[...]
</code></pre>

<p>```</p>

<p>As you can see, the second snippet directly uses the method and deals with the possible <code>AttributeError</code> exception (by the way: managing exceptions is one of the top Black Magic Topics in Python, more on it in a future post. A very quick preview: I think we may learn something from Erlang - check <a href="/blog/2013/05/30/error-handling-in-erlang-a-primer/">this</a>).</p>

<p>Why is this coding style pushed so much in the Python community? I think the main reason is that through EAFP you <em>think</em> polymorphically: you are not interested in knowing if the object <em>has</em> the <code>open</code> attribute, you are interested in knowing if the object can satisfy your request, that is to perform the <code>open()</code> method call.</p>

<h2>Intermezzo</h2>

<p>Are you still with me? Good. Now go, make yourself a cup of tea and fasten belts: the Python roller coaster is about to start.</p>

<p>We will leave the polymorphism palace for a while to explore other parts of the Python OOP world. Don't worry, however, it is just to lay some foundation before diving another time into the matter.</p>

<h2>The Type Brothers</h2>

<p>The first step into the most intimate secrets of Python objects comes from two components we already met in the first post: <code>type</code> and <code>object</code>. These two things are the very fundamental elements of Python OOP system, so it is worth spending some time to understand how they work and relate each other.</p>

<p>First of all recall that in Python <em>everything is an object</em>, that is everything inherits from <code>object</code>. Thus, <code>object</code> seems to be the deepest thing you can find digging into Python veriables. Let's check this</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>a = 5
type(a)
<type 'int'>
a.<strong>class</strong>
<type 'int'>
a.<strong>class</strong>.<strong>bases</strong>
(<type 'object'>,)
object.<strong>bases</strong>
()
```</p></blockquote></blockquote></blockquote>

<p>The variable <code>a</code> is an instance of the <code>int</code> class, and this latter inherits from <code>object</code>, which inherits from nothing. This demonstrates that <code>object</code> is at the top of the class hierarchy. However, as you can see, both <code>int</code> and <code>object</code> are called <em>types</em> (<code>&lt;type 'int'&gt;</code>, <code>&lt;type 'object'&gt;</code>), which in Python is a pure alias of the word <em>class</em>. Indeed, while <code>a</code> is an instance of the <code>int</code> class, <code>int</code> itself is an instance of another class, <em>a class that is instanced to build classes</em></p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>type(a)
<type 'int'>
type(int)
<type 'type'>
type(float)
<type 'type'>
type(dict)
<type 'type'>
```</p></blockquote></blockquote></blockquote>

<p>Since in Python everything is an object, everything is the instance of a class, even classes. Well, <code>type</code> is the class that is instanced to get classes. So remember this: <code>object</code> is the base of every object, <code>type</code> is the class of every type. Sounds puzzling? It is not your fault, don't worry. However, just to strike you with the finishing move, this is what Python is built on</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>type(object)
<type 'type'>
type.<strong>bases</strong>
(<type 'object'>,)
```</p></blockquote></blockquote></blockquote>

<p>If you are not about to faint at this point chances are that you are Guido van Rossum of one of his friends down at the Python core development team (in this case let me thank you for your beautiful creation). You may get another cup of tea, if you need it.</p>

<p>Jokes apart, at the very base of Python type system there are two things, <code>object</code> and <code>type</code>, which are inseparable. The previous code shows that <code>object</code> is an instance of <code>type</code>, and <code>type</code> inherits from <code>object</code>. Take your time to understand this subtle concept, as it is very important for the upcoming discussion about metaclasses.</p>

<p>When you think you grasped the <code>type</code>/<code>object</code> matter read this and start thinking again</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>type(type)
<type 'type'>
```</p></blockquote></blockquote></blockquote>

<p>Hint: type is a class (i.e. a type). =)</p>

<h2>The Metaclasses Take Python</h2>

<p>You are now familiar with Python classes. You know that a class is used to create an instance, and that the structure of this latter is ruled by the source class and all its parent classes (until you reach <code>object</code>).</p>

<p>Since classes are objects too, you know that a class itself is an instance of a (super)class, and this class is <code>type</code>. That is, as already stated, <code>type</code> is the class that is used to build classes.</p>

<p>So for example you know that a class may be instanced, i.e. it can be called and by calling it you obtain another object that is linked with the class. What prepares the class for being called? What gives the class all its methods? In Python the class in charge of performing such tasks is called <em>metaclass</em>, and <code>type</code> is the default metaclass of all classes.</p>

<p>The point of exposing this structure of Python objects is that you may change the way classes are built. As you know, <code>type</code> is an object, so it can be subclassed just like any other class. Once you get a subclass of <code>type</code> you need to instruct your class to use it as the metaclass instead of type, and you can do this by setting the <code>__metaclass__</code> attribute.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>class MyType(type):
...  pass
...
class MySpecialClass(object):
...  <strong>metaclass</strong> = MyType
...
msp = MySpecialClass()
type(msp)
<class '__main__.MySpecialClass'>
type(MySpecialClass)
<class '__main__.MyType'>
type(MyType)
<type 'type'>
```</p></blockquote></blockquote></blockquote>

<h4>Metaclasses 2: Singleton Day</h4>

<p>Metaclasses are a very advanced topic in Python, but they have many practical uses. For example, by means of a custom metaclass you may log any time a class is instanced, which can be important for applications that shall keep a low memory usage or have to monitor it.</p>

<p>I am going to show here a very simple example of metaclass, the Singleton. Singleton is a well known design pattern, and many description of it may be found on the Internet. It has also been heavily criticized mostly because its bad behaviour when subclassed, but here I do not want to introduce it for its technological value, but for its simplicity (so please do not question the choice, it is just an example). Check the links at the bottom if you are interested in this topic.</p>

<p>Singleton has one purpose: to return the same instance every time it is instanced, like a sort of object-oriented global variable. So we need to build a class that does not work like standard classes, which return a new instance every time they are called.</p>

<p>"Build a class"? This is a task for metaclasses. The following implementation comes from <a href="http://python-3-patterns-idioms-test.readthedocs.org/en/latest/Metaprogramming.html#intercepting-class-creation">Python 3 Patterns, Recipes and Idioms</a>, but is also valid for Python 2.x</p>

<p>``` python
class Singleton(type):</p>

<pre><code>instance = None
def __call__(cls, *args, **kw):
    if not cls.instance:
         cls.instance = super(Singleton, cls).__call__(*args, **kw)
    return cls.instance
</code></pre>

<p>```</p>

<p>We are defining a new type, which inherits from <code>type</code> to provide all bells and whistles of Python classes. We override the <code>__call__</code> method, that is a special method invoked when we call the class, i.e. when we instance it. The new method wraps the original method of <code>type</code> by calling it only when the <code>instance</code> attribute is not set, i.e. the first time the class is instanced, otherwise it just returns the recorded instance. As you can see this is a very basic cache class, the only trick is that it is applied to the creation of instances.</p>

<p>To test the new type we need to define a new class that uses it as its metaclass</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>class ASingleton(object):
...     <strong>metaclass</strong> = Singleton
...
a = ASingleton()
b = ASingleton()
a is b
True
hex(id(a))
'0xb6aae28cL'
hex(id(b))
'0xb6aae28cL'
```</p></blockquote></blockquote></blockquote>

<p>By using the <code>is</code> operator we test that the two objects are the very same structure in memory, that is their ids are the same, as explicitly shown. What actually happens is that when you issue <code>a = ASingleton()</code> the <code>ASingleton</code> class runs its <code>__call__()</code> method, which is taken from the <code>Singleton</code> type behind the class. That method recognizes that no instance has been created (<code>Singleton.instance</code> is <code>None</code>) and acts just like any standard class does. When you issue <code>b = ASingleton()</code> the very same things happen, but since <code>Singleton.instance</code> is now different from <code>None</code> its value (the previous instance) is directly returned.</p>

<p>Metaclasses are a very powerful programming tool and leveraging them you can achieve very complex behaviours with a small effort. Their use is a must every time you are actually metaprogramming, that is you are writing code that has to drive the way your code works. Good examples are creational patterns (injecting custom class attributes depending on some configuration), testing, debugging, and performance monitoring.</p>

<h2>Coming to Instance</h2>

<p>Before introducing you to a very smart use of metaclasses by talking about Abstract Base Classes (read: to save some topics for the third part of this series), I want to dive into the object creation procedure in Python, that is what happens when you instance a class. In the previous post this procedure was described only partially, by looking at the <code>__init_()</code> method.</p>

<p>In the first post I recalled the object-oriented concept of <em>constructor</em>, which is a special method of the class that is automatically called when the instance is created. The class may also define a destructor, which is called when the object is destroyed. In languages without a garbage collection mechanism such as C++ the destructor shall be carefully designed. In Python the destructor may be defined through the <code>__del__()</code> method, but it is hardly used.</p>

<p>The constructor mechanism in Python is on the contrary very important, and it is implemented by two methods, instead of just one: <code>__new__()</code> and <code>__init__()</code>. The tasks of the two methods are very clear and distinct: <code>__new__()</code> shall perform actions needed when <em>creating</em> a new instance while <code>__init__</code> deals with object <em>initialization</em>.</p>

<p>Since in Python you do not need to declare attributes due to its dynamic nature, <code>__new__()</code> is rarely defined by programmers, who may rely on <code>__init__</code> to perform the majority of the usual tasks. Typical uses of <code>__new__()</code> are very similar to those listed in the previous section, since it allows to trigger some code whenever your class is instanced.</p>

<p>The standard way to override <code>__new__()</code> is</p>

<p>``` python
class MyClass(object):</p>

<pre><code>def __new__(cls, *args, **kwds):
    obj = super(MyClass, cls).__new__(cls, *args, **kwds)
    [put your code here]
    return obj
</code></pre>

<p>```</p>

<p>just like you usually do with <code>__init__()</code>. When your class inherits from <code>object</code> you do not need to call the parent method (<code>object.__init__()</code>) because it is empty.</p>

<p>Remember that <code>__new__()</code> is not forced to return an instance of the class in which it is defined, even if you shall have very good reasons to break this behaviour. Anyway, <code>__init__()</code> will be called only if you return an instance of the container class. Please also note that <code>__new__()</code>, unlike <code>__init__()</code>, accepts the class as its first parameter. The name is not important in Python, and you can also call it <code>self</code>, but it is worth using <code>cls</code> to remember that it is not an instance.</p>

<h2>Final words</h2>

<p>Next post will introduce Abstract Base Classes as the major topic. Slots are another topic which for many people is buried into the Tome of Python Secrets and is worth uncovering. Stay tuned! You can <a href="https://twitter.com/tw_lgiordani/">follow me on Twitter</a> if you want to get the latest news from the blog.</p>

<h2>Movie Trivia</h2>

<p>This time section titles come from the following movies: <em>Good Morning, Vietnam</em>, <em>Die Hard</em>, <em>Spies Like Us</em>, <em>Unforgiven</em>, <em>The Blues Brothers</em>, <em>The Muppets Take Manhattan</em>, <em>Terminator 2: Judgement Day</em>, <em>Coming to America</em></p>

<h2>Sources</h2>

<p>Some sources for the content of this post. Thank you authors!</p>

<ul>
<li><a href="http://docs.python.org/2/tutorial/classes.html">The official Python documentation</a> and the Python source code.</li>
<li><a href="http://www.cafepy.com/article/python_types_and_objects/">Python Types and Objects - by Shalabh Chaturvedi</a></li>
<li><a href="http://www.amazon.com/Python-Nutshell-Second-Edition-In/dp/0596100469/">Python in a Nutshell - by Alex Martelli</a></li>
<li><a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/">Design Patterns: Elements of Reusable Object-Oriented Software - by Gamma, Helm, Johnson, Vlissides</a></li>
<li><a href="http://python-3-patterns-idioms-test.readthedocs.org/en/latest/">Python 3 Patterns, Recipes and Idioms</a></li>
<li><a href="http://www.aleax.it/5ep.html">Singleton and Borg patterns - by Alex Martelli</a></li>
<li>Many <a href="http://stackoverflow.com/questions/tagged/python">Stackoverflow</a> questions and answers</li>
</ul>


<h2>Feedback</h2>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>

<h2>Previous articles</h2>

<ul>
<li><a href="/blog/2014/03/05/oop-concepts-in-python-2-dot-x-part-1">OOP Concepts in Python 2.x - Part 1</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OOP concepts in Python 2.x - Part 1]]></title>
    <link href="http://lgiordani.github.io/blog/2014/03/05/oop-concepts-in-python-2-dot-x-part-1/"/>
    <updated>2014-03-05T12:46:06+01:00</updated>
    <id>http://lgiordani.github.io/blog/2014/03/05/oop-concepts-in-python-2-dot-x-part-1</id>
    <content type="html"><![CDATA[<h2>Abstract</h2>

<p>Object-oriented programming (OOP) has been the leading programming paradigm for several decades now, starting from the initial attempts back in the 60s to some of the most important languages used nowadays. Being a set of programming concepts and design methodologies, OOP can never be said to be "correctly" or "fully" implemented by a language: indeed there are as many implementations as languages.</p>

<p>So one of the most interesting aspects of OOP languages is to understand how they implement those concepts. In this post I am going to try and start analyzing the OOP implementation of the Python language. Due to the richness of the topic, however, I consider this attempt just like a set of thoughts for Python beginners trying to find their way into this beautiful (and sometimes peculiar) language.</p>

<p>This first post covers the following topics:</p>

<ul>
<li>Objects and types</li>
<li>Classes and instances</li>
<li>Object members: methods and attributes</li>
<li>Delegation: inheritance and composition</li>
</ul>


<p><em>This post refers to the internals of Python 2.x - please note that Python 3.x changes (improves!) some of the features shown here. As soon as I feel comfortable with my Python 3 knowledge, I will post an update.</em></p>

<!--more-->


<h2>Back to the Object</h2>

<p>Computer science deals with data and with procedures to manipulate that data. Everything, from the earliest Fortran programs to the latest mobile apps is about data and their manipulation.</p>

<p>So if data are the ingredients and procedures are the recipes, it seems (and can be) reasonable to keep them separate.</p>

<p>Let's do some procedural programming in Python</p>

<p>``` python</p>

<h1>This is some data</h1>

<p>data = (13, 63, 5, 378, 58, 40)</p>

<h1>This is a procedure that computes the average</h1>

<p>def avg(d):</p>

<pre><code>return sum(d)/len(d)
</code></pre>

<p>print avg(data)
```</p>

<p>As you can see the procedure is quite good and general: the procedure is run on a sequence of data, and it returns the average of the sequence items. So far, so good: computing the average of some numbers leaves the numbers untouched and creates new data.</p>

<p>The observation of the everyday world, however, shows that <em>complex data mutate</em>: an electrical device is on or off, a door is open or closed, the content of a bookshelf in your room changes as you buy new books.</p>

<p>You can still manage it keeping data and procedures separate, for example</p>

<p>``` python</p>

<h1>These are two numbered doors, initially closed</h1>

<p>door1 = [1, 'closed']
door2 = [2, 'closed']</p>

<h1>This procedure opens a door</h1>

<p>def open_door(door):</p>

<pre><code>door[1] = 'open'
</code></pre>

<p>open_door(door1)
print door1
```</p>

<p>I described a door as a structure containing a number and the status of the door. The procedure knows how this structure is made and may alter it.</p>

<p>This also works like a charm. Some problems arise, however, when we start building specialized types of data. What happens, for example, when I introduce a "lockable door" data type, which can be opened only when it is not locked? Let's see</p>

<p>``` python</p>

<h1>These are two standard doors, initially closed</h1>

<p>door1 = [1, 'closed']
door2 = [2, 'closed']</p>

<h1>This is a lockable door, initially closed and unlocked</h1>

<p>ldoor1 = [1, 'closed', 'unlocked']</p>

<h1>This procedure opens a standard door</h1>

<p>def open_door(door):</p>

<pre><code>door[1] = 'open'
</code></pre>

<h1>This procedure opens a lockable door</h1>

<p>def open_ldoor(door):</p>

<pre><code>if door[2] == 'unlocked`:
    door[1] = `open`
</code></pre>

<p>open_door(door1)
print door1</p>

<p>open_ldoor(ldoor1)
print ldoor1</p>

<p>```</p>

<p>Everything still works, no surprises in this code. However, as you can see, I had to find a different name for the procedure that opens a locked door since its implementation differs from the procedure that opens a standard door. But, wait... I'm still opening a door, the action is the same, and it just changes the status of the door itself. So why shall I remember that a locked door shall be opened with <code>open_ldoor()</code> instead of <code>open_door()</code> if the verb is the same?</p>

<p>Chances are that this separation between data and procedures doesn't perfectly fit some situations. The key problem is that the "open" action is not actually <em>using</em> the door; rather it is <em>changing its state</em>. So, just like the volume control buttons of your phone, which are <em>on</em> your phone, the "open" procedure should stick to the "door" data.</p>

<p>This is exactly what leads to the concept of <em>object</em>: an object, in the OOP context, is a structure holding data <em>and</em> procedures operating on them.</p>

<h2>What About Type?</h2>

<p>When you talk about data you immediately need to introduce the concept of <em>type</em>. This concept may have two meanings that are worth being mentioned in computer science: the <em>behavioural</em> and the <em>structural</em> one.</p>

<p>The behavioural meaning represents the fact that you know what something is by describing how it acts. This is the foundation of the so-called "duck typing" (here "typing" means "to give a type" and not "to type on a keyboard"): if it <del>types</del> acts like a duck, it <em>is</em> a duck.</p>

<p>The structural meaning identifies the type of something by looking at its internal structure. So two things that act in the same way but are internally different are of different type.</p>

<p>Both points of view can be valid, and different languages may implement and emphasize one meaning of type or the other, and even both.</p>

<h2>Class Games</h2>

<p>Objects in Python may be built describing their structure through a <em>class</em>. A class is the programming representation of a generic object, such as "a book", "a car", "a door": when I talk about "a door" everyone can understand what I'm saying, without the need of referring to a specific door in the room.</p>

<p>In Python, the type of an object is represented by the class used to build the object: that is, in Python the word <em>type</em> has the same meaning of the word <em>class</em>.</p>

<p>For example, one of the built-in classes of Python is <code>int</code>, which represents an integer number</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>a = 6
print a
6
print type(a)
<type 'int'>
print a.<strong>class</strong>
<type 'int'>
```</p></blockquote></blockquote></blockquote>

<p>As you can see, the built-in function <code>type()</code> returns the content of the <em>magic attribute</em> <code>__class__</code> (magic here means that its value is managed by Python itself offstage). The type of the variable <code>a</code>, or its class, is <code>int</code>. (This is a very inaccurate description of this rather complex topic, so remember that we are just scratching the surface).</p>

<p>Once you have a class you can <em>instantiate</em> it to get a concrete object (an <em>instance</em>) of that type, i.e. an objects built according to the structure of that class. The Python syntax to instantiate a class is the same of a function call</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>b = int()
type(b)
<type 'int'>
```</p></blockquote></blockquote></blockquote>

<p>When you create an instance, you can pass some values, according to the class definition, to <em>initialize</em> it.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>b = int()
print b
0
c = int(7)
print c
7
```</p></blockquote></blockquote></blockquote>

<p>In this example, the <code>int</code> class creates an integer with value 0 when called without arguments, otherwise it uses the given argument to initialize the newly created object.</p>

<p>Let us write a class that represents a door to match the procedural examples done in the first section</p>

<p>``` python
class Door(object):</p>

<pre><code>def __init__(self, number, status):
    self.number = number
    self.status = status

def open(self):
    self.status = 'open'

def close(self):
    self.status = 'closed'
</code></pre>

<p>```</p>

<p>The <code>class</code> keyword defines a new class named <code>Door</code>; everything indented under <code>class</code> is part of the class. The functions you write inside the object are called <em>methods</em> and don't differ at all from standard functions; the name changes only to highlight the fact that those functions now are part of an object.</p>

<p>Methods of a class must accept as first argument a special value called <code>self</code> (the name is a convention but please never break it).</p>

<p>The class can be given a special method called <code>__init__()</code> which is run when the class is instantiated, receiving the arguments passed when calling the class; the general name of such a method, in the OOP context, is <em>constructor</em>, even if the <code>__init__()</code> method is not the only part of this mechanism in Python.</p>

<p>The <code>self.number</code> and <code>self.status</code> variables are called <em>attributes</em> of the object. In Python, methods and attributes are both <em>members</em> of the object and are accessible with the dotted syntax; the difference between attributes and methods is that the latter can be called (in Python lingo you say that a method is a <em>callable</em>).</p>

<p>As you can see the <code>__init__()</code> method shall create and initialize the attributes since they are not declared elsewhere.</p>

<p>The class can be used to create a concrete object</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1 = Door(1, 'closed')
type(door1)
<class '__main__.Door'>
print door1.number
1
print door1.status
closed
```</p></blockquote></blockquote></blockquote>

<p>Now <code>door1</code> is an instance of the <code>Door</code> class; <code>type()</code> returns the class as <code>__main__.Door</code> since the class was defined directly in the interactive shell, that is in the current main module. To call a method of an object, that is to run one of its internal functions, you just access it as an attribute with the dotted syntax and call it like a standard function.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.open()
print door1.number
1
print door1.status
open
```</p></blockquote></blockquote></blockquote>

<p>In this case, the <code>open()</code> method of the <code>door1</code> instance has been called. No arguments have been passed to the <code>open()</code> method, but if you review the class declaration, you see that it was declared to accept an argument (<code>self</code>). When you call a method of an instance, Python automatically passes the instance itself to the method as the first argument.</p>

<p>You can create as many instances as needed and they are completely unrelated each other. That is the changes you make on one instance do not reflect on another instance of the same class.</p>

<h4>Recap</h4>

<p>Objects are described by a <em>class</em>, which can generate one or more <em>instances</em>, unrelated each other. A class contains <em>methods</em>, which are functions, and they accept at least one argument called <code>self</code>, which is the actual instance on which the method has been called. A special method, <code>__init__()</code> deals with the initialization of the object, seting the initial value of the <em>attributes</em>.</p>

<h2>Python Classes Strike Again</h2>

<p>The Python implementation of classes has some peculiarities. The bare truth is that in Python the class of an object is an object itself. You can check this by issuing <code>type()</code> on the class</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>type(door1)
<class '__main__.Door'>
print type(Door)
<type 'type'>
```</p></blockquote></blockquote></blockquote>

<p>This shows that the <code>Door</code> class is an object, an instance of the <code>type</code> class.</p>

<p>This concept is not so difficult to grasp as it can seem at first sight: in the real world we deal with concepts using them like <em>things</em>: for example we can talk about the concept of "door", telling people how a door looks like and how it works. So in our everyday experience the <em>type</em> of an object is an object itself. In Python this can be expressed by saying that <em>everything is an object</em>.</p>

<p>If the class is an instance it is a concrete object and is stored somewhere in memory. Let us leverage the <em>inspection</em> capabilities of Python and its <code>id()</code> function to check the status of our objects. The <code>id()</code> built-in function returns the memory position of an object.</p>

<p>First of all, let's check that the two objects are stored at different addresses</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>hex(id(door1))
'0x7fa4c818bad0'
hex(id(door2))
'0x7fa4c818b890'
```</p></blockquote></blockquote></blockquote>

<p>This confirms that the two instances are separate and unrelated.
<strong>Please note that your values are very likely to be different from the ones I got.</strong></p>

<p>However if we use <code>id()</code> on the class of the two instances we discover that the class is <em>exactly</em> the same</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>hex(id(door1.<strong>class</strong>))
'0x766800'
hex(id(door2.<strong>class</strong>))
'0x766800'
```</p></blockquote></blockquote></blockquote>

<p>Well this is very important. In Python, a class is not just the schema used to build an object. Rather, the class is a shared living object, which code is accessed at run time.</p>

<p>As we already tested, however, attributes are not stored in the class but in every instance, due to the fact that <code>__init__()</code> works on <code>self</code> when creating them. Classes, however, can be given attributes like any other object; with a terrific effort of imagination, let's call them <em>class attributes</em>.</p>

<p>As you can expect, class attributes are shared among the class instances just like their container</p>

<p>``` python
class Door(object):</p>

<pre><code>colour = 'brown'

def __init__(self, number, status):
    self.number = number
    self.status = status

def open(self):
    self.status = 'open'

def close(self):
    self.status = 'closed'
</code></pre>

<p>```</p>

<p>The <code>colour</code> attribute here is not created using <code>self</code>, and any change of its value reflects on all instances</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1 = Door(1, 'closed')
door2 = Door(2, 'closed')
Door.colour
'brown'
door1.colour
'brown'
door2.colour
'brown'
Door.colour = 'white'
Door.colour
'white'
door1.colour
'white'
door2.colour
'white'
hex(id(Door.colour))
'0xb74c5420L'
hex(id(door1.colour))
'0xb74c5420L'
hex(id(door2.colour))
'0xb74c5420L'
```</p></blockquote></blockquote></blockquote>

<h2>Raiders of the Lost Attribute</h2>

<p>Any Python object is automatically given a <code>__dict__</code> attribute, which contains its list of attributes. Let's investigate what this dictionary contains for our example objects:</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>Door.<strong>dict</strong>
dict_proxy({'<strong>module</strong>': '<strong>main</strong>',</p>

<pre><code>'colour': 'brown',
'__weakref__': &lt;attribute '__weakref__' of 'Door' objects&gt;,
'__dict__': &lt;attribute '__dict__' of 'Door' objects&gt;,
'close': &lt;function close at 0xb6a8a56c&gt;,
'open': &lt;function open at 0xb6a8a534&gt;,
'__doc__': None,
'__init__': &lt;function __init__ at 0xb6a8a48c&gt;})
</code></pre>

<p>door1.<strong>dict</strong>
{'status': 'closed', 'number': 1}
```</p></blockquote></blockquote></blockquote>

<p>Leaving aside the difference between a dictionary and a <code>dict_proxy</code> object, you can see that the <code>colour</code> attribute is listed among the <code>Door</code> class attributes, while <code>status</code> and <code>number</code> are listed for the instance.</p>

<p>How comes that we can call <code>door1.colour</code>, if that attribute is not listed for that instance? This is a job performed by the magic <code>__getattribute__()</code> method; in Python the dotted syntax automatically invokes this method so when we write <code>door1.colour</code>, Python executes <code>door1.__getattribute__('colour')</code>. That method performs the  <em>attribute  lookup</em> action, i.e. finds the value of the attribute by looking in different places.</p>

<p>The standard implementation of <code>__getattribute__()</code> searches first the internal dictionary (<code>__dict__</code>) of an object, then the type of the object itself; in this case <code>door1.__getattribute__('colour')</code> executes first <code>door1.__dict__['colour']</code> and then <code>door1.__class__.__dict__['colour']</code></p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.<strong>dict</strong>['colour']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'colour'
door1.<strong>class</strong>.<strong>dict</strong>['colour']
'brown'
```</p></blockquote></blockquote></blockquote>

<p>Indeed, if we check the objects equality through the <code>is</code> operator we can confirm that both <code>door1.colour</code> and <code>Door.colour</code> are exactly the same object</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.colour is Door.colour
True
```</p></blockquote></blockquote></blockquote>

<p>When we try to assign a value to a class attribute directly on an instance, we just put in the <code>__dict__</code> of the instance a value with that name, and this value masks the class attribute since it is found first by <code>__getattribute__()</code>. As you can see from the examples of the previous section, this is different from changing the value of the attribute on the class itself.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.colour = 'white'
door1.<strong>dict</strong>['colour']
'white'
door1.<strong>class</strong>.<strong>dict</strong>['colour']
'brown'
Door.colour = 'red'
door1.<strong>dict</strong>['colour']
'white'
door1.<strong>class</strong>.<strong>dict</strong>['colour']
'red'
```</p></blockquote></blockquote></blockquote>

<h2>Revenge of the Methods</h2>

<p>Let's play the same game with methods. First of all you can see that, just like class attributes, methods are listed only in the class <code>__dict__</code>. Chances are that they behave the same as attributes when we get them</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.open is Door.open
False
```</p></blockquote></blockquote></blockquote>

<p>Whoops. Let us further investigate the matter</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>Door.<strong>dict</strong>['open']
<function open at 0xb73ee10c>
Door.open
<unbound method Door.open>
door1.open
<bound method Door.open of <__main__.Door object at 0xb73f956c>>
```</p></blockquote></blockquote></blockquote>

<p>So, the class method is listed in the members dictionary as <em>function</em>. So far, so good. The same method, taken directly from the class is returned as <em>unbound method</em>, while taking it from the instance it changes to <em>bound method</em>. Well, a <em>function</em> is a procedure you named and defined with the <code>def</code> statement. When you refer to a function as part of a class you get an unbound method. The name <em>method</em> simply means "a function inside a class", according to the usual OOP definitions, while <em>unbound</em> signals that the method is not bound to any instance. As you can see, as soon as you access the method from an instance, the method becomes <em>bound</em>.</p>

<p>Why does Python bother with methods being bound or unbound? And how does Python transform an unbound method into a bound one?</p>

<p>First of all, if you try to call an unbound method you get an error</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>Door.open()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unbound method open() must be called with</p>

<pre><code>Door instance as first argument (got nothing instead)
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>so by default Python considers methods as functions that shall operate on instances, and calling them from the class leaves the interpreter puzzled. Let us try to pass the instance as suggested by the exception message</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>Door.open(door1)
door1.status
'open'
```</p></blockquote></blockquote></blockquote>

<p>Python does not complain here, and the method works as expected. So <code>Door.open(door1)</code> is the same as <code>door1.open()</code>. Again, under the hood, <code>__getattribute__()</code> is working to make everything work and when we call <code>door1.open()</code>, Python actually calls <code>door1.__class__.open(door1)</code>. However, <code>door1.__class__.open</code> is an unbound method, so there is something more that converts it into a bound method that Python can safely call.</p>

<p>When you access a member of an object, Python calls <code>__getattribute__()</code> to satisfy the request. This magic method, however, conforms to a procedure known as <em>descriptor protocol</em>. For the read access <code>__getattribute__()</code> checks if the object has a <code>__get__()</code> method and calls this latter. So for function the conversion from an unbound into a bound method is made by such a mechanism. Let us review it by means of an example.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.<strong>class</strong>.<strong>dict</strong>['open']
<function open at 0xb73ee10c>
```</p></blockquote></blockquote></blockquote>

<p>This syntax retrieves the function defined in the class; the function knows nothing about objects, but it <em>is</em> an object (remember "everything is an object"). So we can look inside it with the <code>dir()</code> built-in function</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>dir(door1.<strong>class</strong>.<strong>dict</strong>['open'])
['<strong>call</strong>', '<strong>class</strong>', '<strong>closure</strong>', '<strong>code</strong>', '<strong>defaults</strong>',
 '<strong>delattr</strong>', '<strong>dict</strong>', '<strong>doc</strong>', '<strong>format</strong>', '<strong>get</strong>',
 '<strong>getattribute</strong>', '<strong>globals</strong>', '<strong>hash</strong>', '<strong>init</strong>',
 '<strong>module</strong>', '<strong>name</strong>', '<strong>new</strong>', '<strong>reduce</strong>', '<strong>reduce_ex</strong>',
 '<strong>repr</strong>', '<strong>setattr</strong>', '<strong>sizeof</strong>', '<strong>str</strong>', '<strong>subclasshook</strong>',
 'func_closure', 'func_code', 'func_defaults', 'func_dict', 'func_doc',
 'func_globals', 'func_name']
door1.<strong>class</strong>.<strong>dict</strong>['open'].<strong>get</strong>
&lt;method-wrapper '<strong>get</strong>' of function object at 0xb73ee10c>
```</p></blockquote></blockquote></blockquote>

<p>As you can see, a <code>__get__</code> method is listed among the members of the function, and Python recognizes it as a <em>method-wrapper</em>. This method shall connect the <code>open</code> function to the <code>door1</code> instance, so we can call it passing the instance alone</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.<strong>class</strong>.<strong>dict</strong>['open'].<strong>get</strong>(door1)
<bound method ?.open of <__main__.Door object at 0xb73f956c>>
```</p></blockquote></blockquote></blockquote>

<p>Ok, something is missing. Indeed <code>__get__()</code> in this case also accepts the <em>owner</em> class, i.e. the class we are trying to get the attribute from. So the correct form is</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.<strong>class</strong>.<strong>dict</strong>['open'].<strong>get</strong>(door1, Door)
<bound method Door.open of <__main__.Door object at 0xb73f956c>>
```</p></blockquote></blockquote></blockquote>

<h2>When methods met classes</h2>

<p>If we use <code>type()</code> on an unbound method, we get an interesting result</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.<strong>class</strong>.<strong>dict</strong>['open']
<function open at 0xb6aa548c>
type(door1.<strong>class</strong>.open)
<type 'instancemethod'>
```</p></blockquote></blockquote></blockquote>

<p>The method is an <em>instance method</em>; as we discovered, it shall be bound to an instance to work, so the name is a good choice. Does this imply that we can also define a <em>class method</em>? Indeed we can, through the <code>classmethod</code> decorator</p>

<p>``` python
class Door(object):</p>

<pre><code>colour = 'brown'

def __init__(self, number, status):
    self.number = number
    self.status = status

@classmethod
def knock(cls):
    print "Knock!"

def open(self):
    self.status = 'open'

def close(self):
    self.status = 'closed'
</code></pre>

<p>```</p>

<p>Such a definition makes the method callable on both the instance and the class</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.knock()
Knock!
Door.knock()
Knock!
door1.knock
<bound method type.knock of <class '__main__.Door'>>
Door.knock
<bound method type.knock of <class '__main__.Door'>>
```</p></blockquote></blockquote></blockquote>

<p>And this is possible since, as you can see, both the class method and the instance method are bound. The class method is bound to the class itself, while the instance method is bound to the instance of the class. What about the type of the method?</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>door1.<strong>class</strong>.<strong>dict</strong>['knock']
<classmethod object at 0xb6a8db6c>
type(door1.<strong>class</strong>.knock)
<type 'instancemethod'>
```</p></blockquote></blockquote></blockquote>

<p>Puzzled? Don't be confused! When you look in the <code>__dict__</code> you are not going through the <code>__getattribute__()</code> and <code>__get__()</code> machinery, so you get the plain unprocessed attribute. With standard methods you find <code>function</code> objects in the members dictionary, while for class methods you find <code>classmethod</code> objects.</p>

<p>On the other side, when you check the type of <code>door1.__class__.knock</code> you implicitly invoke <code>__get__()</code>, which binds the method to the class.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>type(door1.<strong>class</strong>.<strong>dict</strong>['knock'].<strong>get</strong>(door1, Door))
<type 'instancemethod'>
type(door1.<strong>class</strong>.<strong>dict</strong>['knock'])
<type 'classmethod'>
```</p></blockquote></blockquote></blockquote>

<p>After all, it is no surprise that a class method is bound since a class is an instance of <code>type</code>.</p>

<h2>Intermezzo</h2>

<p>I realize now that I introduced this post as "a set of thoughts for Python beginners". Sorry. If you are reading this, however, chances are that you are still alive. Calm down. Breathe. Relaxed? Ready to go? Let's dive into delegation!</p>

<h2>The Delegation Run</h2>

<p>If classes are objects what is the difference between types and instances? When I talk about "my cat" I am referring to a concrete instance of the "cat" concept, which is a <em>subtype</em> of "animal". So, despite being both objects, while types can be <em>specialized</em>, instances cannot.</p>

<p>Usually an object B is said to be a specialization of an object A when:</p>

<ul>
<li>B has all the features of A</li>
<li>B can provide new features</li>
<li>B can perform some or all the tasks performed by A in a different way</li>
</ul>


<p>Those targets are very general and valid for any system and the key to achieve them with the maximum reuse of already existing components is <em>delegation</em>. Delegation means that an object shall perform only what it knows best, and leave the rest to other objects.</p>

<p>Delegation can be implemented with two different mechanisms: <em>composition</em> and <em>inheritance</em>. Sadly, very often inheritance is listed among the pillars of OOP techniques, forgetting that it is an implementation of the more generic and fundamental mechanism of delegation; perhaps a better nomenclature for the two techniques could be <em>explicit delegation</em> (composition) and <em>implicit delegation</em> (inheritance). Please note that, again, when talking about composition and inheritance we are talking about focusing on a behavioural or structural delegation. Another way to think about the difference between composition and inheritance is to consider if the object <em>knows</em> who can satisfy your request or if the object <em>is</em> the one that satisfy the request.</p>

<p>Please, please, please do not forget composition: in many cases, composition can lead you to a simpler system, with benefits on maintainability and changeability.</p>

<p>Usually composition is said to be a very generic technique that needs no special syntax, while inheritance and its rules are strongly dependent on the language of choice. Actually, the strong dynamic nature of Python softens the boundary line between the two techniques.</p>

<h2>Inheritance Now</h2>

<p>In Python a class can be declared as an <em>extension</em> of one or more different classes, through the <em>class inheritance</em> mechanism. The child class (the one that inherits) internally has the same structure of the parent class (the one that is inherited), and for the case of multiple inheritance the language has very specific rules to manage possible conflicts or redefinitions among the parent classes. A very simple example of inheritance is</p>

<p>``` python
class SecurityDoor(Door):</p>

<pre><code>pass
</code></pre>

<p>```</p>

<p>where we declare a new class <code>SecurityDoor</code> that, at the moment, is a perfect copy of the <code>Door</code> class. Let us investigate what happens when we access attributes and methods. First we instance the class</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>sdoor = SecurityDoor(1, 'closed')
```</p></blockquote></blockquote></blockquote>

<p>The first check we can do is that class attributes are still global and shared</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>SecurityDoor.colour is Door.colour
True
sdoor.colour is Door.colour
True
```</p></blockquote></blockquote></blockquote>

<p>This shows us that Python tries to resolve instance members not only looking into the class the instance comes from, but also investigating the parent classes. In this case <code>sdoor.colour</code> becomes <code>SecurityDoor.colour</code>, that in turn becomes <code>Door.colour</code>. <code>SecurityDoor</code> <em>is</em> a <code>Door</code>.</p>

<p>If we investigate the content of <code>__dict__</code> we can catch a glimpse of the inheritance mechanism in action</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>sdoor.<strong>dict</strong>
{'status': 'closed', 'number': 1}
sdoor.<strong>class</strong>.<strong>dict</strong>
dict_proxy({'<strong>module</strong>': '<strong>main</strong>', '<strong>doc</strong>': None})
Door.<strong>dict</strong>
dict_proxy({'knock': <classmethod object at 0xb6a8db6c>,</p>

<pre><code>'__module__': '__main__',
'__weakref__': &lt;attribute '__weakref__' of 'Door' objects&gt;,
'__dict__': &lt;attribute '__dict__' of 'Door' objects&gt;,
'close': &lt;function close at 0xb6aa5454&gt;,
'colour': 'brown',
'open': &lt;function open at 0xb6aa53e4&gt;,
'__doc__': None,
'__init__': &lt;function __init__ at 0xb6aa51ec&gt;})
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>As you can see the content of <code>__dict__</code> for <code>SecurityDoor</code> is very narrow compared to that of <code>Door</code>. The inheritance mechanism takes care of the missing elements by climbing up the classes tree. Where does Python get the parent classes? A class always contains a <code>__bases__</code> tuple that lists them</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>SecurityDoor.<strong>bases</strong>
(<class '__main__.Door'>,)
```</p></blockquote></blockquote></blockquote>

<p>So an example of what Python does to resolve a class method call through the inheritance tree is</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>sdoor.<strong>class</strong>.<strong>bases</strong>[0].<strong>dict</strong>['knock'].<strong>get</strong>(sdoor, SecurityDoor)
<bound method type.knock of <class '__main__.SecurityDoor'>>
sdoor.knock
<bound method type.knock of <class '__main__.SecurityDoor'>>
```</p></blockquote></blockquote></blockquote>

<p>Please note that this is just an example that does not consider multiple inheritance.</p>

<p>Let us try now to override some methods and attributes. In Python you can <em>override</em> (redefine) a parent class member simply by redefining it in the child class.</p>

<p>``` python
class SecurityDoor(Door):</p>

<pre><code>colour = 'gray'
locked = True

def open(self):
    if not self.locked:
        self.status = 'open'
</code></pre>

<p>```</p>

<p>As you can forecast, the overridden members now are present in the <code>__dict__</code> of the <code>SecurityDoor</code> class</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>SecurityDoor.<strong>dict</strong>
dict_proxy({'locked': True,</p>

<pre><code>'__module__': '__main__',
'open': &lt;function open at 0xb73d8844&gt;,
'colour': 'gray',
'__doc__': None})
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>So when you override a member, the one you put in the child class is used instead of the one in the parent class simply because the former is found before the latter while climbing the class hierarchy. This also shows you that Python does not implicitly call the parent implementation when you override a method. So, overriding is a way to block implicit delegation.</p>

<p>If we want to call the parent implementation we have to do it explicitly. In the former example we could write</p>

<p>``` python
class SecurityDoor(Door):</p>

<pre><code>colour = 'gray'
locked = True

def open(self):
    if self.locked:
        return
    Door.open(self)
</code></pre>

<p>```</p>

<p>You can easily test that this implementation is working correctly. This form of explicit parent delegation is heavily discouraged, however.</p>

<p>The first reason is because of the very high coupling that results from explicitly naming the parent class again when calling the method; if you decide to use a new parent class you have to manually propagate the change to every method that calls it. Moreover, since in Python the class hierarchy can be dynamically changed (i.e. at runtime), this form of explicit delegation could be not only annoying but wrong.</p>

<p>The second reason is that in general you need to deal with multiple inheritance, where you do not know a priori which parent class implements the original form of the method you are overriding.</p>

<p>To solve these issues, Python supplies the <code>super()</code> built-in function, that climbs the class hierarchy and returns the correct class that shall be called. The syntax for calling <code>super()</code> is</p>

<p>``` python
class SecurityDoor(Door):</p>

<pre><code>colour = 'gray'
locked = True

def open(self):
    if self.locked:
        return
    super(SecurityDoor, self).open(self)
</code></pre>

<p>```</p>

<p>As you can see you have to explicitly pass the class you are in and the current instance. This is a (indeed very light) form of repetition that has been fixed in Python 3.x.</p>

<h2>Enter the Composition</h2>

<p>Composition means that an object knows another object, and explicitly delegates some tasks to it. While inheritance is implicit, composition is explicit: in Python, however, things are far more interesting than this =).</p>

<p>First of all let us implement classic composition, which simply makes an object part of the other as an attribute</p>

<p>``` python
class SecurityDoor(object):</p>

<pre><code>colour = 'gray'
locked = True

def __init__(self, number, status):
    self.door = Door(number, status)

def open(self):
    if self.locked:
        return
    self.door.open()

def close(self):
    self.door.close()
</code></pre>

<p>```</p>

<p>The primary goal of composition is to relax the coupling between objects. This little example shows that now <code>SecurityDoor</code> is an <code>object</code> and no more a <code>Door</code>, which means that the internal structure of <code>Door</code> is not copied. For this very simple example both <code>Door</code> and <code>SecurityDoor</code> are not big classes, but in a real system objects can very complex; this means that their allocation consumes a lot of memory and if a system contains thousands or millions of objects that could be an issue.</p>

<p>As you can see, however, our solution is far from perfect.</p>

<p>The composed <code>SecurityDoor</code> has to redefine the <code>colour</code> attribute since the concept of delegation applies only to methods and not to attributes, doesn't it? Well, no. Python provides a very high degree of indirection for objects manipulation and attribute access is one of the most useful. As you already discovered, accessing attributes is ruled by a special method called <code>__getattribute__()</code> that is called whenever an attribute of the object is accessed. Overriding <code>__getattribute__()</code>, however, is overkill; it is a very complex method, and, being called on every attribute access, any change makes the whole thing slower.</p>

<p>The method we have to leverage to delegate attribute access is <code>__getattr__()</code>, which is a special method that is called whenever the requested attribute is not found in the object. So basically it is the right place to dispatch all attribute and method access our object cannot handle. In the previous example</p>

<p>``` python
class SecurityDoor(object):</p>

<pre><code>locked = True

def __init__(self, number, status):
    self.door = Door(number, status)

def open(self):
    if self.locked:
        return
    self.door.open()

def __getattr__(self, attr):
    return getattr(self.door, attr)
</code></pre>

<p>```</p>

<p>Using <code>__getattr__()</code> blends the separation line between inheritance and composition since after all the former is a form of automatic delegation of every member access.</p>

<p>``` python
class ComposedDoor(object):</p>

<pre><code>def __init__(self, number, status):
    self.door = Door(number, status)

def __getattr__(self, attr):
    return getattr(self.door, attr)
</code></pre>

<p>```</p>

<p>As this last example shows, delegating every member access through <code>__getattr__()</code> is very simple. Pay attention to <code>getattr()</code> which is different from <code>__getattr__()</code>. The former is a built-in that is equivalent to the dotted syntax, i.e. <code>getattr(obj, 'someattr')</code> is the same as <code>obj.someattr</code>, but you have to use it since the name of the attribute is contained in a string.</p>

<p>Composition provides a superior way to manage delegation since it can selectively delegate the access, even mask some attributes or methods, while inheritance cannot. In Python you also avoid the memory problems that might arise when you put many objects inside another; Python handles everything through its reference, i.e. through a pointer to the memory position of the thing, so the size of an attribute is constant and very limited.</p>

<h2>Final words</h2>

<p>There is much more that can be said about the Python implementation of objects, classes, and friends. Just to name a couple of things, the object creation mechanism and the relationship between <code>object</code> and <code>type</code> have not been explained. Hopefully, there will be space in a later post. In the second post, however, I'll start talking about polymorphism, Abstract Base Classes, and metaclasses. Stay tuned!</p>

<h2>Movie Trivia</h2>

<p>If you are wondering why section titles are so weird, chances are that you missed some good movies to watch while you are not coding =). The movies are: <em>Back to the Future</em>, <em>What About Bob?</em>, <em>Wargames</em>, <em>The Empire Strikes Back</em>, <em>Raiders of the Lost Ark</em>, <em>Revenge of the Nerds</em>, <em>When Harry Met Sally</em>, <em>Apocalypse Now</em>, <em>Enter the Dragon</em>.</p>

<h2>Sources</h2>

<p>Some sources for the content of this post. Thank you authors!</p>

<ul>
<li><a href="http://docs.python.org/2/tutorial/classes.html">The official Python documentation</a> and the Python source code.</li>
<li><a href="http://www.cafepy.com/article/python_types_and_objects/">Python Types and Objects - by Shalabh Chaturvedi</a></li>
<li><a href="http://rhettinger.wordpress.com/2011/05/26/super-considered-super/">Pythons super() considered super! - by Raymond Hettinger</a></li>
<li><a href="http://www.aleax.it/gdd_pydp.pdf">Design Patterns in Python - by Alex Martelli</a></li>
<li>Many <a href="http://stackoverflow.com/questions/tagged/python">Stackoverflow</a> questions and answers</li>
</ul>


<h2>Updates</h2>

<p>2014-03-08: "When methods met classes" section had a typo: the sentence "The class method is bound to the class itself, while the instance method is bound to the class of the instance." is "while the instance method is bound to instance of the class.". Thanks <a href="https://plus.google.com/u/0/116309787480950087834/posts">Mohcin Shah</a> for spotting it!</p>

<p>2014-03-10: Fixed link to Alex Martelli's presentation.</p>

<h2>Feedback</h2>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>

<h2>Next articles</h2>

<ul>
<li><a href="/blog/2014/03/10/oop-concepts-in-python-2-dot-x-part-2">OOP Concepts in Python 2.x - Part 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Digging up Django class-based views - 3]]></title>
    <link href="http://lgiordani.github.io/blog/2014/02/14/digging-up-django-class-based-views-3/"/>
    <updated>2014-02-14T16:13:41+01:00</updated>
    <id>http://lgiordani.github.io/blog/2014/02/14/digging-up-django-class-based-views-3</id>
    <content type="html"><![CDATA[<p><em>This post refers to Django 1.5. Please be warned that some of the matters discussed here, some solutions or the given code can be outdated by more recent Django versions</em></p>

<p>In the first two issues of this short series we wandered around the basic concepts of class-based views in Django, and started understanding and using two of the basic generic views Django makes available to you: <code>ListView</code> and <code>DetailView</code>. Both are views that read some data from the database and show them on a rendered template.</p>

<p>This third issue wants to introduce the reader to the class-based version of Django forms. This post is not meant to be a full introduction to the Django form library; rather, I want to show how class-based generic views implement the CUD part of the CRUD operations (Create, Read, Update, Delete), the Read one being implemented by "standard" generic views.</p>

<!--more-->


<h2>A very basic example</h2>

<p>To start working with CBFs (class-based forms) let's say we are working with a <code>StickyNote</code> class which represents a simple text note with a date:</p>

<p>``` python
class StickyNote(models.Model):</p>

<pre><code>timestamp = models.DateTimeField()
text = models.TextField(blank=True, null=True)
</code></pre>

<p>```</p>

<p>One of the first things we usually want to do is to build a form that allows the user to create a new entry in the database, in this case a new sticky note. The functional version of such a form would be the following:</p>

<p>```python
def note_add(request):</p>

<pre><code>form = StickyNoteForm(request.POST or None)
if form.is_valid():
    new_note = form.save()
    new_note.save()
return render_to_response('note_add.html')
</code></pre>

<p>urlpatterns = patterns('',</p>

<pre><code>url(r'^note_add/$', 'note_add'),
</code></pre>

<p>)
```</p>

<p>which is not too complex to grasp. Note that I left aside some imports; the <code>StickNoteForm</code> class is built using a <a href="https://docs.djangoproject.com/en/1.5/topics/forms/modelforms/">model form</a>. Since you <a href="https://docs.djangoproject.com/en/1.5/topics/forms/">already know</a> how functional form views work, let's compare it with the same view expressed with a class:</p>

<p>``` python
class NoteAdd(CreateView):</p>

<pre><code>model = StickyNote
</code></pre>

<p>```</p>

<p>It is no surprise that most of the code went away, thanks to inheritance. As happened in the first two posts with standard views, the class mechanism provides us with a bunch of code that lives somewhere in the class hierarchy and works behind the scenes. Our mission is now to uncover that code to figure out how exactly CBFs work and how we can change them to perform what we need.</p>

<p>To make the post easier to follow, please always remember that "class-based form" is a short name for "class-based form view". That is, CBFs are views, so their job is to process incoming HTTP requests and return a HTTP response. Form views do this in a slightly different way than the standard ones, mostly due to the different nature of POST requests compared with GET ones. Let us take a look at this concept before moving on.</p>

<h2>HTTP requests: GET and POST</h2>

<p><em>Please note that this is a broad subject and that the present section wants only to be a very quick review of the main concepts that are related to Django CBFs</em></p>

<p>HTTP requests come in different forms, depending on the <strong>method</strong> they carry. Those methods are called <strong>HTTP verbs</strong> and the two most used ones are <strong>GET</strong> and <strong>POST</strong>. The GET method tells the server that the client wants to retrieve a resource (the one connected with the relative URL) and shall have no side effects (such as changing the resource). The POST method is used to send some data to the server, the given URL being the <em>resource</em> that shall handle the data.</p>

<p>As you can see, the definition of POST is very broad: the server accepts the incoming data and is allowed to perform any type of action with it, such as creating a new entity, editing or deleting one or more of them, and so on.</p>

<p>Keep in mind that forms are not the same thing as POST request. As a matter of fact, they are connected just incidentally: a form is a way to collect data from a user browsing a HTML page while POST is the way that data is transmitted to the server. You do not need to have a form to make a POST request, you just need some data to send. HTML forms are just a useful way to send POST requests, but not the only one.</p>

<h2>Form views</h2>

<p>Why are form views different from standard views? The answer can be found looking at the flow of a typical data submission on a Web site:</p>

<ol>
<li>The user browses a web page (GET)</li>
<li>The server answers the GET request with a page containing a form</li>
<li>The user fills the form and submits it (POST)</li>
<li>The server receives and processes data</li>
</ol>


<p>As you can see the procedure involves a double interaction with the server: the first request GETs the page, the second POSTs the data. So you need to build a view that answers the GET request and a view that answers the POST one.</p>

<p>Since most of the time the URL we use to POST data is the same URL we used to GET the page, we need to build a view that accepts both methods. This is the main reason of the pattern you are used to see in functional form views in Django. <a href="https://docs.djangoproject.com/en/1.5/topics/forms/">The official Django documentation</a> on the subject uses this snippet of code</p>

<p>``` python
def contact(request):</p>

<pre><code>if request.method == 'POST': # If the form has been submitted...
    form = ContactForm(request.POST) # A form bound to the POST data
    if form.is_valid(): # All validation rules pass
        # Process the data in form.cleaned_data
        # ...
    return HttpResponseRedirect('/thanks/') # Redirect after POST
else:
    form = ContactForm() # An unbound form

return render(request, 'contact.html', {
    'form': form,
})
</code></pre>

<p>```</p>

<p>As you can see the first conditional path deals with the data submission (POST) while the else part deals with the usual case of a GET request.</p>

<p>Now it is time to dig into the class-based forms that Django provides us to understand how they deal with this double interaction.</p>

<p>Let us start with the <code>CreateView</code> class we used in our simple example, which is defined in <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L202">views/generic/edit.py#202</a>. It is an almost empty class that inherits from <code>SingleObjectTemplateResponseMixin</code> and from <code>BaseCreateView</code>. The first class deals with the template selected to render the response and we can leave it aside for the moment. The second class, on the other hand, can be found a couple of lines above, at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L187">views/generic/edit.py#L187</a>, and implements two methods which names are self explaining, <code>get()</code> and <code>post()</code>.</p>

<h4>Processing GET and POST requests</h4>

<p>We already met the <code>get()</code> method in the <a href="/blog/2013/12/11/digging-up-django-class-based-views-2">past article</a> when we talked about the <code>dispatch()</code> method of the <code>View</code> class. A quick recap of its purpose: this method is called when the incoming HTTP request carries the GET verb and is used to process the request itself. Not surprisingly, the <code>post()</code> method is called when the incoming request is a POST one. The two methods are already defined by an ancestor of the <code>BaseCreateView</code> class, namely <code>ProcessFormView</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L145">views/generic/edit.py#L145</a>). It is useful to take a peek at the source code of this last class:</p>

<p>``` python
class ProcessFormView(View):</p>

<pre><code>"""
A mixin that renders a form on GET and processes it on POST.
"""
def get(self, request, *args, **kwargs):
    """
    Handles GET requests and instantiates a blank version of the form.
    """
    form_class = self.get_form_class()
    form = self.get_form(form_class)
    return self.render_to_response(self.get_context_data(form=form))

def post(self, request, *args, **kwargs):
    """
    Handles POST requests, instantiating a form instance with the passed
    POST variables and then checked for validity.
    """
    form_class = self.get_form_class()
    form = self.get_form(form_class)
    if form.is_valid():
        return self.form_valid(form)
    else:
        return self.form_invalid(form)
</code></pre>

<p>```</p>

<p>As you can see the two methods are pretty straightforward. They both retrieve the class of the form with <code>get_form_class()</code> and instance it with <code>get_form()</code> (more on them later). The <code>get()</code> method then just calls the <code>render_to_response()</code> method to render a template, passing the context produced by the <code>get_context_data()</code> method. Note that the context receives the form as built by the <code>get_form()</code> method.</p>

<p>The <code>post()</code> method does not directly render the template since it has to process incoming data before doing this last step. Instead the validation of the form is performed through its <code>is_valid()</code> method and the two methods <code>form_valid()</code> and <code>form_invalid()</code> are called depending on the result of the test. See the <a href="https://docs.djangoproject.com/en/1.5/ref/forms/validation/">official documentation</a> for more information about form validation.</p>

<p>Please note that the behaviour of these classes follows the same pattern of that used in <code>ListView</code> and <code>DetailView</code> as described in the previous two posts.</p>

<p>The <code>ProcessFormView</code> class inherits from <code>View</code>, which was already described in depth in the first two posts of this series; there you can find the <code>as_view()</code> and <code>dispatch()</code> method that are the foundation of the CBVs system.</p>

<h2>The form workflow - part I</h2>

<p>The inheritance path that starts with <code>ProcessFormView</code> spans all the classes that deal with the incoming request, telling GET and POST methods apart. The second inheritance path we can follow from <code>BaseCreateView</code> leads to <code>ModelFormMixin</code>, which is defined at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L75">views/generic/edit.py#L75</a>. This path contains the classes that implement the form management methods. The first two methods that deal with the form are <code>get_form_class()</code> and <code>get_form()</code> that we encountered when discussing the <code>get()</code> and <code>post()</code> methods.</p>

<p>The <code>get_form_class()</code> tries to get the form model from the <code>self.form_class</code> attribute, and if this is not defined tries to extract the model from the <code>self.model</code> or from the queryset. Then it returns a suitable modelform, using a factory defined in <a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/models.py">forms/models.py</a>.</p>

<p>The <code>get_form()</code> method is defined in <code>FormMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L10">views/generic/edit.py#L10</a>) and instances the form class with the keywords returned by <code>get_form_kwargs()</code>, implemented in <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L100">views/generic/edit.py#L100</a>. This last method is quite important as we are going to discover in a short while, since it has a big role in the double interaction that happens with POST requests.</p>

<p>The first implementation of the <code>get_form_kwargs()</code> method that we find in the ancestors tree is in <code>ModelFormMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L100">views/generic/edit.py#L100</a>), but this immediately calls the same method defined in <code>FormMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L10">views/generic/edit.py#L10</a>). The code is</p>

<p>``` python
def get_form_kwargs(self):</p>

<pre><code>kwargs = {'initial': self.get_initial()}
if self.request.method in ('POST', 'PUT'):
    kwargs.update({
        'data': self.request.POST,
        'files': self.request.FILES,
    })
return kwargs
</code></pre>

<p>```</p>

<p>The first value of the form keywords dictionary is the copy of the <code>self.initial</code> dictionary, returned by <code>get_initial()</code> as stated by <a href="https://docs.djangoproject.com/en/1.5/ref/forms/api/#dynamic-initial-values">the official documentation</a>. Then, if the method of the request being processed is POST or PUT, the keywords are updated with the content of the request itself, i.e. posted data and uploaded files. This is used to initialize the form object itself as you can see at <a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/forms.py#L77">forms/forms.py#L77</a>, and I am going to describe this mechanism later.</p>

<p>After this method returns its dictionary, the execution continues in <code>ModelFormMixin</code>. The code of that method is</p>

<p>``` python
def get_form_kwargs(self):</p>

<pre><code>kwargs = super(ModelFormMixin, self).get_form_kwargs()
kwargs.update({'instance': self.object})
return kwargs
</code></pre>

<p>```</p>

<p>that just adds <code>self.object</code> under the <code>instance</code> key of the keywords dictionary. We already met <code>self.object</code> when discussing <code>DetailView</code>, where it contained the result of the queryset, i.e. the object being shown by the view.</p>

<p>What is <code>self.object</code> now? Among the ancestors of our <code>CreateView</code> class, <code>BaseCreateView</code> defines <code>self.object</code> as <code>None</code> so for the moment we can leave it aside. It will come to the rescue later, when we will discuss update and deletion forms, so do not forget it.</p>

<p>The last things we find in the <code>get()</code> method, just after <code>get_form_class()</code> and <code>get_form()</code>, is <code>get_context_data()</code>. As happened in <code>ListView</code> and <code>DetailView</code>, this method builds a dictionary (the context) that is used to render a template. You can find the implementation of <code>get_context_data()</code> at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L130">views/generic/edit.py#L130</a>. As you can see, since <code>self.object</code> has been set to <code>None</code>, the context contains only the instanced form under the <code>form</code> keyword (inserted at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L155">views/generic/edit.py#L155</a>).</p>

<p>Let's recap the process until here.</p>

<ol>
<li>The URL dispatcher requests with GET a page containing a form.</li>
<li>The <code>get()</code> method of <code>ProcessFormView</code> finds the form class of choice through <code>get_form_class()</code></li>
<li>The form class is instanced by <code>get_form()</code> with the values contained in the <code>self.initial</code> dictionary</li>
<li>At this point a template is rendered with a context returned by <code>get_context_data()</code> as usual. The context contains the form.</li>
</ol>


<h2>The form workflow - part II</h2>

<p>Now the user obtained the requested page and is facing an empty form. Once the form has been filled, he or she clicks the submit button and a new HTTP request reaches the server, this time carrying the POST method and a set of data taken from the input fields of the form itself. Our view shall now handle the second interaction step, the one that in functional views is usually managed by the part starting with <code>if request.method == 'POST':</code>.</p>

<p>As we already know, the incoming request is processed by the <code>post()</code> method of <code>ProcessFormView</code>, which works like the <code>get()</code> method in its first part, calling <code>get_form_class()</code> and <code>get_form()</code>. This latter method now deals with a POST request, so the code of <code>get_form_kwargs()</code> in <code>FormMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L10">views/generic/edit.py#L10</a>) adds to the keywords dictionary the submitted data with the <code>data</code> key and the uploaded files under the <code>files</code> key. Why does Django do this? Well, as you can see at <a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/forms.py#L77">forms/forms.py#L77</a> a Django form can be instanced with an optional <code>data</code> keyword, which is stored inside the form object for the subsequent validation phase.</p>

<p>So now the form is bound (that is, it contains some data or files - see <a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/forms.py#L80">forms/forms.py#L80</a>). The <code>post()</code> method now tests the result of <code>is_valid()</code> and acts accordingly calling either <code>form_valid()</code> or <code>form_invalid()</code>. Pay attention that, while <code>is_valid()</code> is a method of the form itself, the two latter methods belong to the <code>BaseCreateView</code>, defined by the same ancestor classes that implement <code>get_form_kwargs()</code>, <code>ModelFormMixin</code> and <code>FormMixin</code>.</p>

<p>The former class implements it at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L123">views/generic/edit.py#L123</a> and puts the result of <code>form.save()</code> into <code>self.object</code>. Remember that <code>self.object</code> is appended to the context under the <code>object</code> key by the <code>get_context_data()</code> method, as shown in the previous section. The <code>form.save()</code> method for modelforms is defined by <code>BaseModelForm</code> at <a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/models.py#L357">forms/models.py#L357</a> and basically saves the instance of the Django model connected with the modelform, that is implements the actual creation at the base of the <code>CreateView</code> form view. As <code>form.save()</code> returns the object saved to the database, it makes sense to store it in <code>self.object</code> and pass it to the template.</p>

<p>The execution of <code>form_valid()</code> continues with the implementation in the <code>FormMixin</code> class at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L61">views/generic/edit.py#L61</a>. This method returns a <code>HttpResponseRedirect</code> object, which is the way you make the browser point to the given URL in Django. In this case the URL is given by <code>self.get_success_url()</code> which tries to return <code>self.success_url</code> if defined, otherwise returns the result of <code>get_absolute_url()</code> for the fresh-made object.</p>

<p>On the other hand, <code>form_invalid()</code> at <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L67">views/generic/edit.py#L67</a> deals with the case of a form containing some errors and simply calls <code>render_to_response()</code> passing it the context with the compiled form under the <code>form</code> key.</p>

<h2>Update and Delete operations</h2>

<p>This rather rich code tour unveiled the inner mechanism of the <code>CreateView</code> class, which can be used to create a new object in the database. The <code>UpdateView</code> and <code>DeleteView</code> classes follow a similar path, with minor changes to perform the different action they are implementing.</p>

<p><code>UpdateView</code> wants to show the form already filled with values, so it instances <code>self.object</code> before processing the request (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L210">views/generic/edit.py#L210</a>). This makes the object available in the keywords dictionary under the <code>instance</code> key (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L105">views/generic/edit.py#L105</a>), which is used by modelforms to initialize the data (<a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/models.py#L244">forms/models.py#L244</a>). The <code>form.save()</code> method of <code>BaseModelForm</code> is smart enough to understand if the object has been created or just changed (<a href="https://github.com/django/django/blob/stable/1.5.x/django/forms/models.py#L365">forms/models.py#L365</a> so the <code>post()</code> method of <code>UpdateView</code> works just like the one of <code>CreateView</code>.</p>

<p><code>DeleteView</code> is a bit different from <code>CreateView</code> and <code>UpdateView</code>. As <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-editing/#deleteview">the official documentation</a> states, if called with a GET method it shows a confirmation page that POSTs to the same URL. So, as for the GET requests, <code>DeleteView</code> just uses the <code>get()</code> method defined by its ancestor <code>BaseDetailView</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/detail.py#L103">views/generic/detail.py#L103</a>), which renders the template putting the object in the context. When called with a POST request, the view uses the <code>post()</code> method defined by <code>DeletionMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L233">views/generic/edit.py#L233</a>, which in turn just calls the <code>delete()</code> method of the same class (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L239">views/generic/edit.py#L239</a>). This performs the deletion on the database and redirects to the success URL.</p>

<h2>Conclusion</h2>

<p>As you can see, the structure behind the current implementation of Django class-based form views is rather complex. This allows the user to achieve complex behaviours like the CUD operations just by defining a couple of classes as I did in the simple example at the beginning of the post. Most of the time, however, such a simplification makes it difficult for the programmer to understand how to achieve the desired changes to the class behaviour. So the purpose of this big tour I made inside the Django source code was to give an insight of what methods are called in the lifetime of your HTTP request so that you can better identify what methods you need to override.</p>

<p>When performing special actions that fall outside the standard CUD operations you better inherit from <code>FormView</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/edit.py#L181">views/generic/edit.py#L181</a>). The first thing to do is to check if and how you need to customize the <code>get()</code> and <code>post()</code> methods; remember that you either need to implement the full behaviour of those methods or make you changes and call the parent implementation. If this is not enough for your application consider overriding one of the more dedicated methods, such as <code>get_form_kwargs()</code> or <code>form_valid()</code>.</p>

<p>This post ends the series "Digging Up Django Class-based Views". Stay tuned for other <a href="/blog/categories/django/">upcoming articles on Django</a>!</p>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post or to ask for an in-depth analysis of some topic. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>

<h2>Previous articles</h2>

<ul>
<li><p><a href="/blog/2013/10/28/digging-up-django-class-based-views-1">Digging Up Django Class-based Views - 1</a></p></li>
<li><p><a href="/blog/2013/12/11/digging-up-django-class-based-views-2">Digging Up Django Class-based Views - 2</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Digging up Django class-based views - 2]]></title>
    <link href="http://lgiordani.github.io/blog/2013/12/11/digging-up-django-class-based-views-2/"/>
    <updated>2013-12-11T09:00:00+01:00</updated>
    <id>http://lgiordani.github.io/blog/2013/12/11/digging-up-django-class-based-views-2</id>
    <content type="html"><![CDATA[<h2>Abstract</h2>

<p><em>This post refers to Django 1.5. Please be warned that some of the matters discussed here, some solutions or the given code can be outdated by more recent Django versions</em></p>

<p>In the first installment of this short series, I introduced the theory behind Django class-based views and the reason why in this context classes are more powerful than pure functions. I also introduced one of the generic views Django provides out-of-the-box, which is <code>ListView</code>.</p>

<p>In this second post I want to talk about the second most used generic view, <code>DetailView</code>, and about custom querysets and arguments. Last, I'm going to introduce unspecialized class-based views that allow you to build more complex Web pages. To fully understand <code>DetailView</code>, however, you need to grasp two essential concepts, namely <strong>querysets</strong> and <strong>view parameters</strong>. So I'm sorry for the learn-by-doing readers, but this time too I'm going to start with some pure programming topics.</p>

<!--more-->


<h2>QuerySets or the art of extracting information</h2>

<p>One of the most important parts of Django is the ORM (Object Relational Mapper), which allows you to access the underlying database just like a collection of Python objects. As you know, Django provides you tools to simplify the construction of DB queries; they are <strong>managers</strong> (the <code>.objects</code> attribute of any models, for example) and <strong>query methods</strong> (<code>get()</code>, <code>filter()</code>, and friends). Pay attention because things here are slightly more magical than you can think at a first glance.</p>

<p>When you use one of the methods of a manager you get as a result a <code>QuerySet</code>, which most of the time is used as a list, but is more than this. You can find <a href="https://docs.djangoproject.com/en/1.5/topics/db/queries/">here</a> and <a href="https://docs.djangoproject.com/en/1.5/ref/models/querysets/">here</a> the official documentation about queries and QuerySets, a very recommended reading.</p>

<p>What I want to stress here is that QuesySets are not evaluated until you perform an action that access the content like slicing or iterating on it. This means that we can build QuerySets, pass them to functions, store them, and even build them programmatically or metaprogramming them without the DB being hit. If you think at QuerySets as recipes you are not far from the truth: they are objects that store how you want to retrieve the data of your interest. Actually retriving them is another part of the game. This separation between the definition of something and its execution is called <strong>lazy evaluation</strong>.</p>

<p>Let me give you a very trivial example to show why the lazy evaluation of QuerySets is important.</p>

<p>``` python
[...]</p>

<p>def get_oldest_three(queryset):</p>

<pre><code>return queryset.order_by['id'][0:2]
</code></pre>

<p>old_books = get_oldest_three(Book.objects.all())
old_hardcover_books = \</p>

<pre><code>get_oldest_three(Book.objects.filter('type=Book.HARDCOVER'))
</code></pre>

<p>```</p>

<p>As you can see the <code>get_oldest_three()</code> method is just filtering an incoming QuerySet (which can be of any type); it simply orders the objects and gets the first three inserted in the DB. The important thing here is that we are using QuerySets like pure 'algorithms', or descriptions of a procedure. When creating the <code>old_books</code> variable we are just telling the <code>get_oldest_three()</code> method "Hey, this is the way I extract the data I'm interested in. May you please refine it and return the actual data?"</p>

<p>Being such flexible objects, QuerySets are an important part of generic views, so keep them warm for the upcoming banquet.</p>

<h2>Being flexible: parametric views</h2>

<p>URLs are the API of our Web site or service. This can be more or less evident for the user that browses through the pages, but from the programmer's point of view URLs are the entry points of a computer system. As such, they are not very different from the API of a library: here, static pages are just like constants, or functions that always return that same value (such as a configuration parameter), while dynamic pages are like functions that process incoming data (parameters) and return a result.</p>

<p>So Web URLs can accept parameters, and our underlying view shall do the same. You basically have three methods to convey parameters from the user's browser to your server using HTTP. The first method is named <a href="http://en.wikipedia.org/wiki/Query_string">query string</a> and lists parameters directly in the URL through a universal syntax. The second method is storing parameters in the HTTP request body, which is what POST requests do. We will discuss this method in a later post about forms.</p>

<p>The first method has one big drawback: most of the time URLs are long (and sometimes <em>too</em> long), and difficult to use as a real API. To soften this effect the concept of <a href="http://en.wikipedia.org/wiki/Clean_URL">clean URL</a> arose, and this is the way Django follows natively (though, if you want, you can also stick to the query string method).</p>

<p>Now, <a href="https://docs.djangoproject.com/en/1.5/topics/http/urls/">you know</a> that you can collect parameters contained in the URL parsing it with a regular expression; what we need to discover is how class-based views receive and process them.</p>

<p>In the previous post we already discussed the <code>as_view()</code> method that shall instance the class and return the result of <code>dispatch()</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L46">views/generic/base.py#L46</a>).</p>

<p>``` python</p>

<pre><code>@classonlymethod
def as_view(cls, **initkwargs):
    """
    Main entry point for a request-response process.
    """
    # sanitize keyword arguments
    for key in initkwargs:
        if key in cls.http_method_names:
            raise TypeError("You tried to pass in the %s method name as a "
                            "keyword argument to %s(). Don't do that."
                            % (key, cls.__name__))
        if not hasattr(cls, key):
            raise TypeError("%s() received an invalid keyword %r. as_view "
                            "only accepts arguments that are already "
                            "attributes of the class." % (cls.__name__, key))

    def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        if hasattr(self, 'get') and not hasattr(self, 'head'):
            self.head = self.get
        self.request = request
        self.args = args
        self.kwargs = kwargs
        return self.dispatch(request, *args, **kwargs)

    # take name and docstring from class
    update_wrapper(view, cls, updated=())

    # and possible attributes set by decorators
    # like csrf_exempt from dispatch
    update_wrapper(view, cls.dispatch, assigned=())
    return view
</code></pre>

<p>```</p>

<p>Now look at what the <code>view()</code> wrapper function actually does with the instanced class (here line 21, <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L65">views/generic/base.py#L65</a>); not surprisingly it takes the <code>request</code>, <code>args</code> and <code>kwargs</code> passed by the URLconf passes and converts them into as many class attributes with the same names.</p>

<p>This means that <em>everywhere in our CBVs</em> we can access the original call parameters simply reading <code>self.request</code>, <code>self.args</code> and <code>self.kwargs</code>, where <code>*args</code> and <code>**kwargs</code> are the unnamed and named values extracted by the URLconf regular expression.</p>

<h2>Details</h2>

<p>Just after listing things, one of the most useful things a Web site does is giving details about objects. Obviously any e-commerce site is made for the most part by pages that list products and show product details, but also a blog is made of one or more pages with a list of posts and a page for each of them. So building a detailed view of the content of our database is worth learning.</p>

<p>To help us in this task Django provides <code>DetailView</code>, which indeed deals, as the name suggests, with the details of what we get from the DB. While <code>ListView</code>'s basic behaviour is to extract the list of all objects with a given model, <code>DetailView</code> extracts a single object. How does it know what object shall be extracted?</p>

<p>When <code>dispatch()</code> is called on an incoming HTTP request the only thing it does is to look at the <code>method</code> attribute, which for <code>HttpRequest</code> objects contains the name of the HTTP verb used (e.g. <code>'GET'</code>); then <code>dispatch()</code> looks for a method of the class with the lowercase name of the verb (e.g. <code>'GET'</code> --> <code>get()</code>) (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L78">views/generic/base.py#L78</a>). This handler is then called with the same parameters of <code>dispatch()</code>, namely the <code>request</code> itself, <code>*args</code> and <code>**kwargs</code>.</p>

<p><code>DetailView</code> has no body and inherits everything from two classes; the second one, <code>BaseDetailView</code>, implements the <code>get()</code> method (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/detail.py#L107">views/generic/detail.py#L107</a>).</p>

<p>``` python
def get(self, request, *args, **kwargs):</p>

<pre><code>self.object = self.get_object()
context = self.get_context_data(object=self.object)
return self.render_to_response(context)
</code></pre>

<p>```</p>

<p>As you can see this method extracts the single object it shall represent calling <code>self.get_object()</code>, then calls <code>self.get_context_data()</code> (that we met in the previous post) and last the familiar <code>self.render_to_response()</code> that is the class equivalent of the well know Django function. The method <code>self.get_object()</code> is provided by <code>BaseDetailView</code>'s ancestor <code>SingleObjectMixin</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/detail.py#L10">generic/detail.py#L10</a>): the most important parts of its code, for the sake of our present topic are</p>

<p>``` python
def get_object(self, queryset=None):</p>

<pre><code>if queryset is None:
    queryset = self.get_queryset()

pk = self.kwargs.get(self.pk_url_kwarg, None)
if pk is not None:
    queryset = queryset.filter(pk=pk)

obj = queryset.get()

return obj
</code></pre>

<p>```</p>

<p><strong>Warning</strong>: I removed many lines from the previous function to improve readability; please check the original source code for the complete implementation.</p>

<p>The code shows where <code>DetailView</code> gets the queryset from; the <code>get_queryset()</code> method is provided by <code>SingleObjectMixin</code> itself and basically returns <code>self.queryset</code> if present, otherwise returns all objects of the given model (acting just like <code>ListView</code> does). This <code>queryset</code> is then refined by a <code>filter()</code> and last by a <code>get()</code>. Here <code>get()</code> is not used directly (I think) to manage the different error cases and raise the correct exceptions.</p>

<p>The parameter <code>pk</code> used in <code>filter()</code> comes directly from <code>self.kwargs</code>, so it is taken directly from the URL. Since this is a core concept of views in general I want to look at this part carefully.</p>

<p>Our <code>DetailView</code> is called by an URLconf that provides a regular expression to parse the URL, for example <code>url(r'^(?P&lt;pk&gt;\d+)/$',</code>. This regex extracts a parameter and gives it the name <code>pk</code>, so <code>kwargs</code> of the view will contain <code>pk</code> as key and the actual number in the URL as value. For example the URL <code>123/</code> will result in <code>{'pk': 123}</code>. The default behaviour of <code>DetailView</code> is to look for a <code>pk</code> key and use it to perform the filtering of the queryset, since <code>self.pk_url_kwarg</code> is <code>'pk'</code>.</p>

<p>So if we want to change the name of the parameter we can simply define the <code>pk_url_kwarg</code> of our class and provide a regex that extract the primary key with the new name. For example <code>url(r'^(?P&lt;key&gt;\d+)/$',</code> extracts it with the name <code>key</code>, so we will define <code>pk_url_kwarg = 'key'</code> in our class.</p>

<p>From this quick exploration we learned that a class inheriting from <code>DetailView</code>:</p>

<ul>
<li>provides a context with the <code>object</code> key initialized to a single object</li>
<li><strong>must</strong> be configured with a <code>model</code> class attribute, to know what objects to extract</li>
<li><strong>can</strong> be configured with a <code>queryset</code> class attribute, to refine the set of objects where the single object is extracted from</li>
<li><strong>must</strong> be called from a URL that includes a regexp that extracts the primary key of the searched object as <code>pk</code></li>
<li><strong>can</strong> be configured to use a different name for the primary key through the <code>pk_url_kwarg</code> class attribute</li>
</ul>


<p>The basic use of <code>DetailView</code> is thus exemplified by the following code.</p>

<p>``` python
class BookDetail(DetailView):</p>

<pre><code>model = Book
</code></pre>

<p>urlpatterns = patterns('',</p>

<pre><code>url(r'^(?P&lt;pk&gt;\d+)/$',
    BookDetail.as_view(),
    name='detail'),
)
</code></pre>

<p>```</p>

<p>The view extracts a single object with the <code>Book</code> model; the regex is configured with the standard <code>pk</code> name.</p>

<p>As shown for <code>ListView</code> in the previous post, any CBV uses <code>get_context_data()</code> to return the context dictionary to the rendering engine. So views that inherit from <code>DetailView</code> can add data to the context following the same pattern</p>

<p>``` python
class BookDetail(DetailView):</p>

<pre><code>model = Book

def get_context_data(self, **kwargs):
    context = super(BookDetail, self).get_context_data(**kwargs)
    context['similar'] = get_similar_books(self.object)
    return context
</code></pre>

<p>urlpatterns = patterns('',</p>

<pre><code>url(r'^(?P&lt;pk&gt;\d+)/$',
    BookDetail.as_view(),
    name='detail'),
)
</code></pre>

<p>```</p>

<p>As explained before, you can access the object being shown through <code>self.object</code>, which in the above example is passed to a service function we implemented somewhere in our code.</p>

<h2>Using the base views</h2>

<p>Sometimes, when dealing with complex pages, the generic display CBVs that Django provides are not the right choice. This usually becomes evident when you start overriding method to prevent the view to perform its standard behaviour. As an instance say that you want to show detailed information of more than one object: probably DetailView will soon show its limits, being built to show only one object.</p>

<p>In all those cases that cannot be easily solved by one of the generic display CBVs, your way goes through other classes: <code>RedirectView</code>, <code>TemplateView</code>, and <code>View</code>. The documentation for these base views is <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/base/">here</a>, while the source code is in <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py">views/generic/base.py</a>.</p>

<p>I'm not going to fully describe those views; I want however to briefly point out some peculiarities.</p>

<p><code>View</code> is by now an old friend of us; we met it when we discussed the <code>as_view()</code> and <code>dispatch()</code> method. It is the most generic view class and can be leveraged to perform very specialized tasks such as rendering pages without templates (for example when returning JSON data in AJAX techniques).</p>

<p><code>TemplateView</code> is the best choice to render pages from a template keeping in the meanwhile freedom as regards the context content. Chances are that this is going to be the view you will use the most after <code>ListView</code> and <code>DetailView</code>. Basically you just need to inherit from it and define the <code>get_context_data()</code> method. As you can see from the <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L147">source code</a> <code>TemplateView</code> answers to GET requests only.</p>

<p><code>RedirectView</code>, as the name implies, is used to redirect a request. The redirection mechanism is very simple: its <code>get()</code> method returns a <code>HttpResponseRedirect</code> to the URL defined by the <code>url</code> class attribute. The class exhibits a very interesting behaviour (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L195">views/generic/base.py#L195</a>) when called through HTTP methods other than GET (namely HEAD, POST, OPTIONS, DELETE, and PUT): it "converts" the method to GET simply calling <code>get()</code> from the respective method (<code>head()</code>, <code>post()</code>, and so on). In the next post I'll show how to leverage this simple technique to show the user a prefilled form.</p>

<h2>Date-based views</h2>

<p>Django provides other class-based views that simplify dealing with objects extracted or ordered by date. As a programmer, you know that dealing with dates is sometimes at least awkward; the views in <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/dates.py">views/generic/dates.py</a> aims to help you to tame your date-based objects; any object that contains a date (e.g. post date for articles, birth date for people, log date for messages, etc) can be processed by these views. You can find the official documentation <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-date-based/">here</a>.</p>

<p>Remember that date-based views are CBVs, so they are based on <code>View</code>, just like <code>ListView</code> or <code>TemplateView</code>. So, apart from their specialization on date processing, they behave the same (<code>get_context_data()</code>, <code>get()</code>, <code>dispatch()</code>, and so on).</p>

<h2>Conclusion</h2>

<p>In this post we covered <code>DetailView</code> in deep and, more quickly, all the remaining base and data-based views. In the next post we will step into the rich (and strange) world of forms.</p>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post or to ask for an in-depth analysis of some topic. <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> is the best place to submit corrections.</p>

<h2>Previous articles</h2>

<ul>
<li><a href="/blog/2013/10/28/digging-up-django-class-based-views-1">Digging Up Django Class-based Views - 1</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Digging up Django class-based views - 1]]></title>
    <link href="http://lgiordani.github.io/blog/2013/10/28/digging-up-django-class-based-views-1/"/>
    <updated>2013-10-28T08:43:00+01:00</updated>
    <id>http://lgiordani.github.io/blog/2013/10/28/digging-up-django-class-based-views-1</id>
    <content type="html"><![CDATA[<h2>Abstract</h2>

<p><em>This post refers to Django 1.5. Please be warned that some of the matters discussed here, some solutions or the given code can be outdated by more recent Django versions</em></p>

<p>Django programmers that started with versions prior to 1.3 are used to deal with views as functions, and they learned how to process even complex forms in a procedural way. From the release 1.3, Django introduced class-based views (CBVs) and ported its powerful generic views to this new paradigm (class-based generic views, or CBGVs).</p>

<p>This change, however, has not been harmless for Django novices: the django-users mailing list and StackOverflow are full of questions about views and classes, and the official documentation on this topic is still a little unorganized. Well, open source things are always ready to be improved, aren't they? This post aims to share some thoughts and insights about CBVs, and hopefully it can also lead to an improvement of the official documentation.</p>

<p>I want to thank all Django developers for their work. Despite the previous criticism on documentation, this post wants to be a thanksgiving for their efforts.</p>

<!--more-->


<p>Feel free to comment <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">here</a> or to submit issues <a href="https://github.com/lgiordani/lgiordani.github.com/issues">here</a>.</p>

<h2>What are CBVs?</h2>

<p>Class-based views are, indeed, (Django) views based on (Python) classes. Until here, it makes sense, hopefully. This means that, to master them, you need to understand both Django views and Python classes, so let's give a quick definition of them.</p>

<p>A Django view is a piece of code that processes an HTTP request and returns an HTTP response. Oh yes, nothing more, nothing less.
A Python class is the implementation of the Object-Oriented concept of class in the Python language.</p>

<p>So a view just need to be a <a href="http://docs.python.org/2/library/functions.html#callable">callable</a>, and this includes functions and classes. Thus, to understand the advantages of class-based views over function-based views we shall discuss the merits of classes over functions. This latter sentence could be the title of a 10 volumes book on programming (followed by another 10 volumes book titled "Merits of functions over classes"), so I am just going to scratch the surface of the matter.</p>

<h2>Starting off with Python classes</h2>

<p>The main point of a class is implementing encapsulation: they represent a way of coupling data and functions. Doing this, a class loses the dynamic essence of a procedure, which exists only while it is running, and becomes a living entity, something that sits there, caring for its data, and reacts when we call its functions (methods).</p>

<p>A good analogy for a class is a finite-state machine: once the class has been initialized, methods are what we use to make it move between states. If we do not call methods, the class simply waits there without complaining.</p>

<p>As an example, let's look at a very simple procedure that takes a list and extracts the even numbers from it.</p>

<p>``` python
def extract_even_numbers(alist):</p>

<pre><code>return [i for i in alist if i%2 == 0]
</code></pre>

<p>```</p>

<p>The example is very trivial, but I think there is always time to tangle up the code, so let us start with simple things. A class version of this function could be written as</p>

<p>```python
class EvenExtractor(object):</p>

<pre><code>def __init__(self, alist):
    self.l = alist

def extract(self):
    return [i for i in self.l if i%2 == 0]
</code></pre>

<p>```</p>

<p>Seems to be the same thing, doesn't it? Indeed the difference is subtle but remarkable. Now the extractor has two parts, the first being the initialization and the second being the actual extraction, and we can have the class in one of three states: before initialization (<code>e = EvenExtractor</code>), after initialization (<code>e = EvenExtractor(range(120))</code>), and after extraction (<code>l = e.extract()</code>. Being a finite-state machine we can interact with it before moving from a state to another. For example</p>

<p><code>python
e = EvenExtractor(range(120)) # State B
e.l = range(60)
e.extract() # State C
</code></p>

<p>Well, despite the very simple example the point is: by converting the procedure to a class we obtained a rich tool that can execute its job step by step and, in general, can work in a non linear way.</p>

<h2>Playing with genetics</h2>

<p>The real power of classes used as finite-state machines lies in the concept of <a href="http://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29">inheritance</a>. Inheritance is a mechanism through which a class can copy another class and then change only the parts that have to behave differently. Please note that here we talk about classes and not instances, so the copy action here refers to the structure of the class, not the actual data contained in it. Inheritance is a mean to mimic the behaviour of a class.</p>

<p>(Sidenote: <em>I am a strong supporter of an OO design principle that states "Favour composition over inheritance" (and favor "favor" over "favour" for US audience). I read too many OOP introductions that stress too much the inheritance mechanism and leave composition aside, raising a generation of OOP programmers that, instead of building systems populated by many small collaborating objects create nightmares infested by giant all-purpose things that sometimes resemble an operating system more than a system component. Given that, inheritance plays an important role in OOP, and here we find a very good example of its real benefit.</em>)</p>

<p>Let's continue the above example, first by enriching the EvenExtractor class:</p>

<p>``` python
class EvenExtractor(object):</p>

<pre><code>def __init__(self, alist):
    self.l = [int(elem) for elem in alist]

def extract(self):
    return [i for i in self.l if i%2 == 0]
</code></pre>

<p>```</p>

<p>Now the class performs an important action in its initialization phase, converting all elements of the input list to integers, and we can happily use it in our Next Big Project. Some days after this change we realize that we could also profitably use a class that extracts odd elements form a list. Being good object oriented programmers we write</p>

<p>```  python
class OddExtractor(EvenExtractor):</p>

<pre><code>def extract(self):
    return [i for i in self.l if i%2 != 0]
</code></pre>

<p>```</p>

<p>and call it a day. Indeed, through the inheritance mechanism expressed by that <code>(EvenExtractor)</code> signature of the new class, we defined something that is exactly the same thing as <code>EvenExtractor</code>, with the same methods and attributes, but with a different name. Then we changed the behaviour of the new class but only for the extraction part by <a href="http://en.wikipedia.org/wiki/Method_overriding">overriding the method</a>.</p>

<p>To summarize the lesson: using classes and inheritance you can build finite-state machines that are easily customizable to suit your exact needs. This obviously is just one of the many points of view under which you can consider classes, but it is the one we need to understand Django CBVs.</p>

<h2>Back to Django</h2>

<p>Finally! You couldn't take Python classes anymore, could you? Sorry, we are dealing with them further, but for the moment let us move to Django to look at a practical use of what we learned in the previous sections.</p>

<p>A Django view is a perfect example of a finite-state machine. It takes an incoming request and makes it flow through different processing steps until a final response is produced, which is then sent back to the user. So, for the love of definitions, say that CBVs are the Django mechanism to allow the programmer to write their views leveraging the tools made available by the object-oriented paradigm. In this context (pun intended) CBGVs are the "batteries included" of Django views: (class-based) generic views are powerful tools that the framework gives you to accomplish the most usual tasks, and sometimes even the unusual ones.</p>

<p>Let's dig into one of the examples of the official Django docs; <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#listview">here</a> you find the API of the beloved <code>ListView</code>, a generic view to deal with a list of things (extracted from the database).</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article
</code></pre>

<p>```</p>

<p>This example assumes that <code>articles</code> is your application and <code>Article</code> is one of its models.</p>

<p>This short piece of code leverages the full power of inheritance. Indeed we just derived <code>ArticleListView</code> from <code>ListView</code> and changed the class attribute <code>model</code>: how can this work? How can this class process incoming requests and what are the outputs? The official documentation states "While this view is executing, self.object_list will contain the list of objects (usually, but not necessarily a queryset) that the view is operating upon."; this leaves many dark corners, however, and if you are a novice, chances are that you are already lost.</p>

<p>Since <code>ArticleListView</code> derives from <code>ListView</code>, the latter is the class we have to analyze to understand how data are processed. To do this you need to look at the <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#django.views.generic.list.ListView">documentation</a>, and if something is still unclear you can freely look at the <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/list.py">source code</a>. As already said I find a little difficult to find a clear way through the docs, so I'll try to summarize here what I learned. In the following paragraphs you will find links like (<a href="">SC</a>) which point to the source code, if you want to read it by yourself.</p>

<h4>URL dispatchers and views</h4>

<p>A CBV cannot directly be used in your URL dispatcher; instead you have to give the result of the <code>as_view()</code> method (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L31">SC</a>), which basically defines a function that instances the class (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L46">SC</a>) and calls the <code>dispatch()</code> method (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L47">SC</a>); then the function is returned to be used in the URL dispatcher (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L55">SC</a>). As a user, we are interested only in the fact that the <em>entry point</em> of the class, i.e. the method called when a request hits the URL linked with it, is <code>dispatch()</code>.</p>

<p>Let's use this knowledge to print out a string on the console each time a request is served by our CBV. I'm running through this (indeed simple) task step by step since it shows exactly how you have to deal with CBVs when solving real problems.</p>

<p>If we define the <code>ArticleListView</code> class this way</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article

def dispatch(self, request, *args, **kwargs):
    super(ArticleListView, self).dispatch(request, *args, **kwargs)
</code></pre>

<p>```</p>

<p>the class does not change its behaviour. What we did was to override the <code>dispatch()</code> method with a call to the parent's method, i.e. we explicitly wrote what Python does by default. You can find detailed information about <code>super()</code> <a href="http://docs.python.org/2/library/functions.html#super">here</a>. Please be also sure to understand the star and double star notation to define variable number of arguments; the official documentation is <a href="http://docs.python.org/2.7/tutorial/controlflow.html#more-on-defining-functions">here</a>.</p>

<p>Since views are automatically called by the framework, this latter expects them to comply with a very specific API, so when overriding a method you have to obey its signature. The signature of <code>dispatch()</code> can be found <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/base/#django.views.generic.base.View.dispatch">here</a>; by the way, this documentation of <code>dispatch()</code> gives you good hints about the internal working mechanism of CBVs.</p>

<p>The <code>dispatch()</code> method receives a <code>request</code> argument, which type is <code>HttpRequest</code> (<a href="https://docs.djangoproject.com/en/1.5/ref/request-response/#httprequest-objects">documentation</a>), and we can print it on the console with the standard <code>print()</code> function</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article

def dispatch(self, request, *args, **kwargs):
    print(request)
    super(ArticleListView, self).dispatch(request, *args, **kwargs)
</code></pre>

<p>```</p>

<p>This prints the content of the <code>request</code> object on the standard output of the Python code, that is on the standard output of the server that is running the Django project. If you are running the Django development server, you will find the output on the text console where you issued the <code>django-admin.py runserver</code> command (or <code>manage.py runserver</code>).</p>

<p>This, in a nutshell, is the standard way of dealing with framework classes, and thus with Django's CBGVs: inherit from a predefined class, identify which methods you need to change, override them complying with their signature and calling the parent's code somewhere in the new code.</p>

<p>The full list of methods <code>ListView</code> uses when processing incoming requests is listed on its <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#listview">official documentation page</a> in the "Method Flowchart" section; in the "Ancestors (MRO)" section you can see that <code>ListView</code> itself inherits from a good number of other classes. MRO stands for Method Resolution Order and has to deal with multiple inheritance: if you are eager to deal with one of the most intricate Python topics feel free to read <a href="http://docs.python.org/2/tutorial/classes.html#multiple-inheritance">here</a>.</p>

<h4>Incoming GET requests</h4>

<p>Back to our <code>ArticleListView</code>. The <code>dispatch()</code> method of the parent reads the <code>method</code> attribute of the <code>request</code> object and selects a handler to process the request itself (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L57">SC</a>): this means that if <code>request.method</code> is <code>'GET'</code>, which is the HTTP way to say that we are <em>reading</em> a resource, <code>dispatch()</code> will call the <code>get()</code> method of the class.</p>

<p>The <code>get()</code> method of <code>ListView</code> comes from its <code>BaseListView</code> ancestor (<a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#django.views.generic.list.BaseListView">documentation</a>, <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/list.py#L114">source code</a>). This function is the one that contains the functional view code, so if you are accustomed to function-based views you'll find yourself at home here. As you can see, the function basically fills the attribute <code>self.object_list</code> with the result of the method <code>self.get_queryset()</code>, creates a context calling the method <code>self.get_context_data()</code> and calls the class version of <code>render_to_response()</code>, namely <code>self.render_to_response()</code>.</p>

<p>Are you still with me? Don't give up, we are nearly at the end (with ListView). The method <code>self.get_queryset()</code> comes from the <code>MultipleObjectMixin</code> ancestor of <code>ListView</code> (<a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/mixins-multiple-object/#multipleobjectmixin">documentation</a>, <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/list.py#L11">source code</a>) and simply gets all objects of a given model (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/list.py#L29">SC</a>) issuing <code>queryset = self.model._default_manager.all()</code>. The value of <code>self.model</code> is what we configured in our class when we wrote <code>model = Article</code>.</p>

<p>That's all. Our <code>ArticleListView</code> class extracts all <code>Article</code> objects from the database, and calls a template passing a context that contains a single variable, <code>object_list</code>, instanced with the list of extracted objects.</p>

<h4>Templates and contexts</h4>

<p>Are you satisfied? I'm actually still curious about the template and the context. Let's see what we can find about these topics. First of all, when the class calls <code>self.render_to_response()</code> it uses the code that comes from its <code>TemplateResponseMixin</code> ancestor (<a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/mixins-simple/#templateresponsemixin">documentation</a>, <a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L81">source code</a>); the method calls some other functions but its basic behaviour is to create a response using a template and a context. The template, again through a series of calls which you can follow by yourself, comes from <code>self.template_name</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L109">SC</a>); while <code>TemplateResponseMixin</code> defines it <code>None</code> (<a href="https://github.com/django/django/blob/stable/1.5.x/django/views/generic/base.py#L85">SC</a>), <code>ListView</code> does some magic through ancestors (<a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/list.py#L128">SC</a>) to return a template which name derives from the given model. So, in short, our <code>ArticleListView</code>, defining an <code>Article</code> model, automatically uses a template that is called <code>article_list.html</code>.</p>

<p>May we change this behaviour? Of course! This is, after all, the point of using classes instead of functions: easily customize the behaviour. We can change the definition of our class like:</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article
template_name = 'sometemplate.html'
</code></pre>

<p>```</p>

<p>What does this exactly do? When the <code>self.render_to_response()</code> method looks for <code>self.template_name</code> this attribute has a value, so there is no need to call the predefined methods and <code>sometemplate.html</code> becomes the name of the template used to render the response. This follows a very useful pattern of object-oriented programming; if you are interested I can write something about this topic.</p>

<p>As regards the context, remember that it is only a dictionary of values you want to access when compiling the template. Variable names inside the context (as thus inside the template), data format and data content are completely up to you. When using CBGVs, however, you will find in your context some variables that have been created by the ancestors of your view, as happens for <code>object_list</code>. What if you want to show a page with the list of all Articles, but you want to add a value to the context?</p>

<p>Nothing is easier: you just need to override the function that produces the context and change its behaviour. Say, for example, that we want to show the number of total readers of our site, along with the list of articles. Assuming that a <code>Reader</code> model is available we can write</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article, Reader</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article

def get_context_data(self, **kwargs):
    context = super(ArticleListView, self).get_context_data(**kwargs)
    context['readers'] = Reader.objects.count()
    return context
</code></pre>

<p>```</p>

<p>As always, when overriding a method we first call the ancestor's one, so that we get the result expected from a normal behaviour of the method, then we add out customizations.</p>

<h2>Conclusion</h2>

<p>In this first post I tried to uncover some of the mysteries behind CBVs and CBGVs in Django, by showing step by step what happens to a GET request that hits a class-based view. Hopefully the matter has now been demystified a little!</p>

<p>In the next posts I will discuss DetailView, the generic view to show detail about an object, how to create custom CBVs and how to use CBVs to process forms, i.e. POST requests.</p>

<p>Let me know if this post helped you in understanding the matter and feel free to point out any error or to ask questions.</p>

<h2>Updates</h2>

<p>2013-10-29: As pointed out by <a href="http://www.reddit.com/user/mbrochh">mbrochh</a> on Reddit, there is a very useful resource for Django programmers: <a href="http://ccbv.co.uk/">Classy Class-Based Views</a>. It is a comprensive index of all CBGVs with ancestors and method signatures. Make sure to have it in you Django bookmarks!</p>

<p>2013-10-29: I fixed a couple of typos when overriding <code>dispatch()</code>. Thanks to Tom Evans for spotting them.</p>

<p>2013-10-30: Fixed the <code>__init__()</code> method of <code>EvenExtractor</code>, that was missing the <code>self</code> parameter. Thanks <a href="http://www.reddit.com/user/meatypocket">meatypocket</a>.</p>

<h2>Next articles</h2>

<ul>
<li><a href="/blog/2013/12/11/digging-up-django-class-based-views-2">Digging Up Django Class-based Views - 2</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
