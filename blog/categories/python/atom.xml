<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | The digital cat]]></title>
  <link href="http://lgiordani.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://lgiordani.github.io/"/>
  <updated>2013-10-30T08:41:41+01:00</updated>
  <id>http://lgiordani.github.io/</id>
  <author>
    <name><![CDATA[Leonardo Giordani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Digging up Django class-based views - 1]]></title>
    <link href="http://lgiordani.github.io/blog/2013/10/28/digging-up-django-class-based-views-1/"/>
    <updated>2013-10-28T08:43:00+01:00</updated>
    <id>http://lgiordani.github.io/blog/2013/10/28/digging-up-django-class-based-views-1</id>
    <content type="html"><![CDATA[<h2>Abstract</h2>

<p><em>This post refers to Django 1.5. Please be warned that some of the matters discussed here, some solutions or the given code can be outdated by more recent Django versions</em></p>

<p>Django programmers that started with versions prior to 1.3 are used to deal with views as functions, and they learned how to process even complex forms in a procedural way. From the release 1.3, Django introduced class-based views (CBVs) and ported its powerful generic views to this new paradigm (class-based generic views, or CBGVs).</p>

<p>This change, however, has not been harmless for Django novices: the django-users mailing list and StackOverflow are full of questions about views and classes, and the official documentation on this topic is still a little unorganized. Well, open source things are always ready to be improved, aren't they? This post aims to share some thoughts and insights about CBVs, and hopefully it can also lead to an improvement of the official documentation.</p>

<p>I want to thank all Django developers for their work. Despite the previous criticism on documentation, this post wants to be a thanksgiving for their efforts.</p>

<!--more-->


<p>Feel free to comment <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">here</a> or to submit issues <a href="https://github.com/lgiordani/lgiordani.github.com/issues">here</a>.</p>

<h2>What are CBVs?</h2>

<p>Class-based views are, indeed, (Django) views based on (Python) classes. Until here, it makes sense, hopefully. This means that, to master them, you need to understand both Django views and Python classes, so let's give a quick definition of them.</p>

<p>A Django view is a piece of code that processes an HTTP request and returns an HTTP response. Oh yes, nothing more, nothing less.
A Python class is the implementation of the Object-Oriented concept of class in the Python language.</p>

<p>So a view just need to be a <a href="http://docs.python.org/2/library/functions.html#callable">callable</a>, and this includes functions and classes. Thus, to understand the advantages of class-based views over function-based views we shall discuss the merits of classes over functions. This latter sentence could be the title of a 10 volumes book on programming (followed by another 10 volumes book titled "Merits of functions over classes"), so I am just going to scratch the surface of the matter.</p>

<h2>Starting off with Python classes</h2>

<p>The main point of a class is implementing encapsulation: they represent a way of coupling data and functions. Doing this, a class loses the dynamic essence of a procedure, which exists only while it is running, and becomes a living entity, something that sits there, caring for its data, and reacts when we call its functions (methods).</p>

<p>A good analogy for a class is a finite-state machine: once the class has been initialized, methods are what we use to make it move between states. If we do not call methods, the class simply waits there without complaining.</p>

<p>As an example, let's look at a very simple procedure that takes a list and extracts the even numbers from it.</p>

<p>``` python
def extract_even_numbers(alist):</p>

<pre><code>return [i for i in alist if i%2 == 0]
</code></pre>

<p>```</p>

<p>The example is very trivial, but I think there is always time to tangle up the code, so let us start with simple things. A class version of this function could be written as</p>

<p>```python
class EvenExtractor(object):</p>

<pre><code>def __init__(self, alist):
    self.l = alist

def extract(self):
    return [i for i in self.l if i%2 == 0]
</code></pre>

<p>```</p>

<p>Seems to be the same thing, doesn't it? Indeed the difference is subtle but remarkable. Now the extractor has two parts, the first being the initialization and the second being the actual extraction, and we can have the class in one of three states: before initialization (<code>e = EvenExtractor</code>), after initialization (<code>e = EvenExtractor(range(120))</code>), and after extraction (<code>l = e.extract()</code>. Being a finite-state machine we can interact with it before moving from a state to another. For example</p>

<p><code>python
e = EvenExtractor(range(120)) # State B
e.l = range(60)
e.extract() # State C
</code></p>

<p>Well, despite the very simple example the point is: by converting the procedure to a class we obtained a rich tool that can execute its job step by step and, in general, can work in a non linear way.</p>

<h2>Playing with genetics</h2>

<p>The real power of classes used as finite-state machines lies in the concept of <a href="http://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29">inheritance</a>. Inheritance is a mechanism through which a class can copy another class and then change only the parts that have to behave differently. Please note that here we talk about classes and not instances, so the copy action here refers to the structure of the class, not the actual data contained in it. Inheritance is a mean to mimic the behaviour of a class.</p>

<p>(Sidenote: <em>I am a strong supporter of an OO design principle that states "Favour composition over inheritance" (and favor "favor" over "favour" for US audience). I read too many OOP introductions that stress too much the inheritance mechanism and leave composition aside, raising a generation of OOP programmers that, instead of building systems populated by many small collaborating objects create nightmares infested by giant all-purpose things that sometimes resemble an operating system more than a system component. Given that, inheritance plays an important role in OOP, and here we find a very good example of its real benefit.</em>)</p>

<p>Let's continue the above example, first by enriching the EvenExtractor class:</p>

<p>``` python
class EvenExtractor(object):</p>

<pre><code>def __init__(self, alist):
    self.l = [int(elem) for elem in alist]

def extract(self):
    return [i for i in self.l if i%2 == 0]
</code></pre>

<p>```</p>

<p>Now the class performs an important action in its initialization phase, converting all elements of the input list to integers, and we can happily use it in our Next Big Project™. Some days after this change we realize that we could also profitably use a class that extracts odd elements form a list. Being good object oriented programmers we write</p>

<p>```  python
class OddExtractor(EvenExtractor):</p>

<pre><code>def extract(self):
    return [i for i in self.l if i%2 != 0]
</code></pre>

<p>```</p>

<p>and call it a day. Indeed, through the inheritance mechanism expressed by that <code>(EvenExtractor)</code> signature of the new class, we defined something that is exactly the same thing as <code>EvenExtractor</code>, with the same methods and attributes, but with a different name. Then we changed the behaviour of the new class but only for the extraction part by <a href="http://en.wikipedia.org/wiki/Method_overriding">overriding the method</a>.</p>

<p>To summarize the lesson: using classes and inheritance you can build finite-state machines that are easily customizable to suit your exact needs. This obviously is just one of the many points of view under which you can consider classes, but it is the one we need to understand Django CBVs.</p>

<h2>Back to Django</h2>

<p>Finally! You couldn't take Python classes anymore, could you? Sorry, we are dealing with them further, but for the moment let us move to Django to look at a practical use of what we learned in the previous sections.</p>

<p>A Django view is a perfect example of a finite-state machine. It takes an incoming request and makes it flow through different processing steps until a final response is produced, which is then sent back to the user. So, for the love of definitions, say that CBVs are the Django mechanism to allow the programmer to write their views leveraging the tools made available by the object-oriented paradigm. In this context (pun intended) CBGVs are the "batteries included" of Django views: (class-based) generic views are powerful tools that the framework gives you to accomplish the most usual tasks, and sometimes even the unusual ones.</p>

<p>Let's dig into one of the examples of the official Django docs; <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#listview">here</a> you find the API of the beloved <code>ListView</code>, a generic view to deal with a list of things (extracted from the database).</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article
</code></pre>

<p>```</p>

<p>This example assumes that <code>articles</code> is your application and <code>Article</code> is one of its models.</p>

<p>This short piece of code leverages the full power of inheritance. Indeed we just derived <code>ArticleListView</code> from <code>ListView</code> and changed the class attribute <code>model</code>: how can this work? How can this class process incoming requests and what are the outputs? The official documentation states "While this view is executing, self.object_list will contain the list of objects (usually, but not necessarily a queryset) that the view is operating upon."; this leaves many dark corners, however, and if you are a novice, chances are that you are already lost.</p>

<p>Since <code>ArticleListView</code> derives from <code>ListView</code>, the latter is the class we have to analyze to understand how data are processed. To do this you need to look at the <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#django.views.generic.list.ListView">documentation</a>, and if something is still unclear you can freely look at the <a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/list.py">source code</a>. As already said I find a little difficult to find a clear way through the docs, so I'll try to summarize here what I learned. In the following paragraphs you will find links like (<a href="">SC</a>) which point to the source code, if you want to read it by yourself.</p>

<h4>URL dispatchers and views</h4>

<p>A CBV cannot directly be used in your URL dispatcher; instead you have to give the result of the <code>as_view()</code> method (<a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/base.py#L31">SC</a>), which basically defines a function that instances the class (<a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/base.py#L46">SC</a>) and calls the <code>dispatch()</code> method (<a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/base.py#L47">SC</a>); then the function is returned to be used in the URL dispatcher (<a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/base.py#L55">SC</a>). As a user, we are interested only in the fact that the <em>entry point</em> of the class, i.e. the method called when a request hits the URL linked with it, is <code>dispatch()</code>.</p>

<p>Let's use this knowledge to print out a string on the console each time a request is served by our CBV. I'm running through this (indeed simple) task step by step since it shows exactly how you have to deal with CBVs when solving real problems.</p>

<p>If we define the <code>ArticleListView</code> class this way</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article

def dispatch(self, request, *args, **kwargs):
    super(ArticleListView, self).dispatch(request, *args, **kwargs)
</code></pre>

<p>```</p>

<p>the class does not change its behaviour. What we did was to override the <code>dispatch()</code> method with a call to the parent's method, i.e. we explicitly wrote what Python does by default. You can find detailed information about <code>super()</code> <a href="http://docs.python.org/2/library/functions.html#super">here</a>. Please be also sure to understand the star and double star notation to define variable number of arguments; the official documentation is <a href="http://docs.python.org/2.7/tutorial/controlflow.html#more-on-defining-functions">here</a>.</p>

<p>Since views are automatically called by the framework, this latter expects them to comply with a very specific API, so when overriding a method you have to obey its signature. The signature of <code>dispatch()</code> can be found <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/base/#django.views.generic.base.View.dispatch">here</a>; by the way, this documentation of <code>dispatch()</code> gives you good hints about the internal working mechanism of CBVs.</p>

<p>The <code>dispatch()</code> method receives a <code>request</code> argument, which type is <code>HttpRequest</code> (<a href="https://docs.djangoproject.com/en/1.5/ref/request-response/#httprequest-objects">documentation</a>), and we can print it on the console with the standard <code>print()</code> function</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article

def dispatch(self, request, *args, **kwargs):
    print(request)
    super(ArticleListView, self).dispatch(request, *args, **kwargs)
</code></pre>

<p>```</p>

<p>This prints the content of the <code>request</code> object on the standard output of the Python code, that is on the standard output of the server that is running the Django project. If you are running the Django development server, you will find the output on the text console where you issued the <code>django-admin.py runserver</code> command (or <code>manage.py runserver</code>).</p>

<p>This, in a nutshell, is the standard way of dealing with framework classes, and thus with Django's CBGVs: inherit from a predefined class, identify which methods you need to change, override them complying with their signature and calling the parent's code somewhere in the new code.</p>

<p>The full list of methods <code>ListView</code> uses when processing incoming requests is listed on its <a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#listview">official documentation page</a> in the "Method Flowchart" section; in the "Ancestors (MRO)" section you can see that <code>ListView</code> itself inherits from a good number of other classes. MRO stands for Method Resolution Order and has to deal with multiple inheritance: if you are eager to deal with one of the most intricate Python topics feel free to read <a href="http://docs.python.org/2/tutorial/classes.html#multiple-inheritance">here</a>.</p>

<h4>Incoming GET requests</h4>

<p>Back to our <code>ArticleListView</code>. The <code>dispatch()</code> method of the parent reads the <code>method</code> attribute of the <code>request</code> object and selects a handler to process the request itself (<a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/base.py#L57">SC</a>): this means that if <code>request.method</code> is <code>'GET'</code>, which is the HTTP way to say that we are <em>reading</em> a resource, <code>dispatch()</code> will call the <code>get()</code> method of the class.</p>

<p>The <code>get()</code> method of <code>ListView</code> comes from its <code>BaseListView</code> ancestor (<a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/#django.views.generic.list.BaseListView">documentation</a>, <a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/list.py#L114">source code</a>). This function is the one that contains the functional view code, so if you are accustomed to function-based views you'll find yourself at home here. As you can see, the function basically fills the attribute <code>self.object_list</code> with the result of the method <code>self.get_queryset()</code>, creates a context calling the method <code>self.get_context_data()</code> and calls the class version of <code>render_to_response()</code>, namely <code>self.render_to_response()</code>.</p>

<p>Are you still with me? Don't give up, we are nearly at the end (with ListView). The method <code>self.get_queryset()</code> comes from the <code>MultipleObjectMixin</code> ancestor of <code>ListView</code> (<a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/mixins-multiple-object/#multipleobjectmixin">documentation</a>, <a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/list.py#L11">source code</a>) and simply gets all objects of a given model (<a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/list.py#L29">SC</a>) issuing <code>queryset = self.model._default_manager.all()</code>. The value of <code>self.model</code> is what we configured in our class when we wrote <code>model = Article</code>.</p>

<p>That's all. Our <code>ArticleListView</code> class extracts all <code>Article</code> objects from the database, and calls a template passing a context that contains a single variable, <code>object_list</code>, instanced with the list of extracted objects.</p>

<h4>Templates and contexts</h4>

<p>Are you satisfied? I'm actually still curious about the template and the context. Let's see what we can find about these topics. First of all, when the class calls <code>self.render_to_response()</code> it uses the code that comes from its <code>TemplateResponseMixin</code> ancestor (<a href="https://docs.djangoproject.com/en/1.5/ref/class-based-views/mixins-simple/#templateresponsemixin">documentation</a>, <a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/base.py#L81">source code</a>); the method calls some other functions but its basic behaviour is to create a response using a template and a context. The template, again through a series of calls which you can follow by yourself, comes from <code>self.template_name</code> (<a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/base.py#L109">SC</a>); while <code>TemplateResponseMixin</code> defines it <code>None</code> (<a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/base.py#L85">SC</a>), <code>ListView</code> does some magic through ancestors (<a href="https://github.com/django/django/blob/stable/1.3.x/django/views/generic/list.py#L128">SC</a>) to return a template which name derives from the given model. So, in short, our <code>ArticleListView</code>, defining an <code>Article</code> model, automatically uses a template that is called <code>article_list.html</code>.</p>

<p>May we change this behaviour? Of course! This is, after all, the point of using classes instead of functions: easily customize the behaviour. We can change the definition of out class like:</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article
template_name = 'sometemplate.html'
</code></pre>

<p>```</p>

<p>What does this exactly do? When the <code>self.render_to_response()</code> method looks for <code>self.template_name</code> this attribute has a value, so there is no need to call the predefined methods and <code>sometemplate.html</code> becomes the name of the template used to render the response. This follows a very useful pattern of object-oriented programming; if you are interested I can write something about this topic.</p>

<p>As regards the context, remember that it is only a dictionary of values you want to access when compiling the template. Variable names inside the context (as thus inside the template), data format and data content are completely up to you. When using CBGVs, however, you will find in your context some variables that have been created by the ancestors of your view, as happens for <code>object_list</code>. What if you want to show a page with the list of all Articles, but you want to add a value to the context?</p>

<p>Nothing is easier: you just need to override the function that produces the context and change its behaviour. Say, for example, that we want to show the number of total readers of our site, along with the list of articles. Assuming that a <code>Reader</code> model is available we can write</p>

<p>``` python
from django.views.generic.list import ListView
from articles.models import Article, Reader</p>

<p>class ArticleListView(ListView):</p>

<pre><code>model = Article

def get_context_data(self, **kwargs):
    context = super(ArticleListView, self).get_context_data(**kwargs)
    context['readers'] = Reader.objects.count()
    return context
</code></pre>

<p>```</p>

<p>As always, when overriding a method we first call the ancestor's one, so that we get the result expected from a normal behaviour of the method, then we add out customizations.</p>

<h2>Conclusion</h2>

<p>In this first post I tried to uncover some of the mysteries behind CBVs and CBGVs in Django, by showing step by step what happens to a GET request that hits a class-based view. Hopefully the matter has now been demystified a little!</p>

<p>In the next posts I will discuss DetailView, the generic view to show detail about an object, how to create custom CBVs and hot to use CBVs to process forms, i.e. POST requests.</p>

<p>Let me know if this post helped you in understanding the matter and feel free to point out any error or to ask questions.</p>

<h2>Updates</h2>

<p>2013-10-29: As pointed out by <a href="http://www.reddit.com/user/mbrochh">mbrochh</a> on Reddit, there is a very useful resource for Django programmers: <a href="http://ccbv.co.uk/">Classy Class-Based Views</a>. It is a comprensive index of all CBGVs with ancestors and method signatures. Make sure to have it in you Django bookmarks!</p>

<p>2013-10-29: I fixed a couple of typos when overriding <code>dispatch()</code>. Thanks to Tom Evans for spotting them.</p>

<p>2013-10-30: Fixed the <code>__init__()</code> method of <code>EvenExtractor</code>, that was missing the <code>self</code> parameter. Thanks <a href="http://www.reddit.com/user/meatypocket">meatypocket</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postage - a RabbitMQ-based component Python library]]></title>
    <link href="http://lgiordani.github.io/blog/2013/07/25/postage-a-rabbitmq-based-component-python-library/"/>
    <updated>2013-07-25T15:50:00+02:00</updated>
    <id>http://lgiordani.github.io/blog/2013/07/25/postage-a-rabbitmq-based-component-python-library</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/pika/pika">Pika</a> is a wonderful pure Python implementation of the AMQP protocol. Using it you can exploit the full power of your RabbitMQ installation from your Python code.</p>

<p>When using pika to develop a component-based system I tried to write some code to simplify its use: the result is <a href="https://github.com/lgiordani/postage">Postage</a>, a Python library that provides higher level structures such as a message format, components fingerprint, rich producer and consumers.</p>

<p>Most notably it provides a handler mechanism for consumers that makes message processing a breeze.</p>

<p>Postage is freely available under the GPL2. It is based on the pika BlockingConnection since I had no experience with other adapters. If you want to hack it, feel free to <a href="https://github.com/lgiordani/postage">fork it on Github</a> and submit a pull request.</p>

<!--more-->


<h2>A simple ping example</h2>

<p>I'll describe here a very simple example of a producer/consumer system using Postage; I'll write a server that answers ping messages and a program that sends them. First I will implement a simple server that receives ping messages without answering, to introduce the reader to the base structures, then I will evolve it.</p>

<p>To execute the program you need a working RabbitMQ system, check the RabbitMQ documentation to install and run it. Postage assumes that your system is configured with the standard values (a "/" virtualhost, "guest" user and password). If not check <a href="https://github.com/lgiordani/postage#environment-variables">this paragraph</a> of the documentation.</p>

<h4>Setting up the exchange</h4>

<p>Put the following code in a <code>facilities.py</code> file:</p>

<p>``` python
from postage import messaging</p>

<p>class PingExchange(messaging.Exchange):</p>

<pre><code>"""This is the exchange that receives ping messages."""
name = "ping-exchange"
exchange_type = "direct"
passive = False
durable = True
auto_delete = False
</code></pre>

<p>```</p>

<p>This imports the messaging part of Postage and declares a <code>PingExchange</code>, which is a simple direct RabbitMQ exchange, which name is <code>ping-exchange</code>. Remember that in a AMQP system exchanges are unique by name and virtualhost, i.e. given a virtualhost the name of the exchange uniquely identifies it.</p>

<h4>Setting up the producer</h4>

<p>Just below the exchange object we declare a producer, a class that can send a given set of messages:</p>

<p>``` python
class PingProducer(messaging.GenericProducer):</p>

<pre><code>eks = [(PingExchange, 'ping_rk')]

def build_message_ping(self):
    return messaging.MessageCommand('ping')
</code></pre>

<p>```</p>

<p>First of all our producer inherits from <code>GenericProducer</code>, a rich object that manages low-level stuff such as connection to the AMQP broker (RabbitMQ), exchange declaration and message creation.</p>

<p>The <code>eks</code> class attribute is a list of exchange/routing key couples (tuples); we list here all the exchanges that will receive our messages when the object will send them and for each exchange we give a routing key. Recall that routing keys are used to label messages so that the exchange can route them to the subscribing queues (according to the rules of the exchange type). Here, we declare that the messages of our producer are going to be sent to the <code>PingExchange</code> exchange with the <code>ping_rk</code> routing key.</p>

<p>Then we declare a <code>build_message_ping()</code> method, which simply builds a new message and returns it. This latter is a command message that in Postage lingo means a message that contains an action the receiver shall execute (a fire-and-forget call).</p>

<h4>The producer</h4>

<p>The program that sends ping messages is very straightforward; it shall declare a message producer and use it to send the message. Create the <code>send_ping.py</code> file and write the following code</p>

<p>``` python
from postage import messaging
import facilities</p>

<p>fingerprint = messaging.Fingerprint(name="ping_sender")</p>

<p>```</p>

<p>After the usual imports, I create a fingerprint for this program. As explained in <a href="https://github.com/lgiordani/postage#fingerprint">the documentation</a>, a fingerprint is a collection of useful information about the component that sends messages. It can be easily customized since all Postage objects expect it to be a dictionary, so any object that behaves like a dictionary works. The standard <code>Fingerprint</code> provided by Postage collects some useful properties from the OS and the RabbitMQ installation; here we customize the <code>name</code> value that otherwise would be set to <code>None</code>. The fingerprint, once loaded in a producer, will be automatically attached to any message the producer will send.</p>

<p>``` python
producer = facilities.PingProducer(fingerprint.as_dict())
producer.message_ping()</p>

<p>```</p>

<p>The <code>PingProducer</code> we declared in <code>facilities.py</code> is instanced, and its <code>message_ping()</code> method is invoked.
If you review the above paragraph you will notice that you never defined a <code>message_ping()</code> method; this is automatically implemented by the <code>GenericProducer</code> class from the <code>build_message_ping()</code> method. The class performs many actions under the hood: it executes some code to set up the correct RabbitMQ structures, calls your method to get the actual message data, attaches the fingerprint to the message, and serializes the message data. Eventually, the producer sends the message to the exchange defined in the class (<code>PingExchange</code>) with the linked routing key (<code>ping_rk</code>).</p>

<h4>The server program</h4>

<p>Now we will write a component that receives ping command messages and performs some action accordingly. Open a <code>receive_ping.py</code> file and write the following code</p>

<p>``` python
from postage import messaging
from postage import microthreads</p>

<p>import facilities</p>

<p>fingerprint = messaging.Fingerprint(name="ping_receiver")
```</p>

<p>that loads the modules we need and builds the fingerprint of this application. Creating a receiver means declaring a class that inherits from <code>MessageProcessor</code> and implements a method for each incoming message we want to process.</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>@messaging.MessageHandler('command', 'ping')
def msg_ping(self, content):
    print "Got a ping!"
</code></pre>

<p>```</p>

<p>As you can see here the <code>msg_ping()</code> method is declared as a handler for the command message <code>ping</code>; the name of the method is arbitrary, but it has to accept one parameter, namely the content of the incoming message (more on this later). In this case, when the object receives a ping message it just prints out a string.</p>

<p>``` python
eqks = [(facilities.PingExchange, [('ping_queue', 'ping_rk')])]
receiver = PingReceiver(fingerprint.as_dict(), eqks,</p>

<pre><code>                    None, messaging.global_vhost)
</code></pre>

<p>```</p>

<p>To start the receiver we have to connect it to an exchange; recall that the AMQP mechanism requires you to declare a queue and to connect it to an exchange through a key, which format depends on the exchange type. Being the <code>PingExchange</code> a direct exchange we want to connect to it with the exact routing key we want to match, that is <code>ping_rk</code>. The <code>eqks</code> structure is rather complex and may result overblown in such a simple context: it is a list of tuples in the form <code>(exchange_class, qk_list)</code> that links the given exchange class to a list of queues; this latter list contains tuples in the form <code>(queue_name, key)</code>. Each queue listed here connects to the exchange and fetches messages that match the linked key.</p>

<p>In this case, we simply subscribe the <code>facilities.PingExchange</code> exchange with a <code>ping_queue</code> queue receiving messages routed with the <code>ping_rk</code> key.</p>

<p>The receiver is then instanced. The arguments we pass are the fingerprint dictionary, the eqks we just discussed, a HUP tuple (Host, User, Password) to connect to RabbitMQ and the RabbitMQ virtualhost we want to use. In this case, we stick to the <a href="https://github.com/lgiordani/postage#environment-variables">default HUP</a> and to the default virtualhost.</p>

<p>``` python
scheduler = microthreads.MicroScheduler()
scheduler.add_microthread(receiver)</p>

<p>for i in scheduler.main():</p>

<pre><code>pass
</code></pre>

<p>```</p>

<p>This code creates a scheduler and adds the receiver, which is a <code>microthreads.Microthread</code>, then starts the execution loop.</p>

<h4>Execution</h4>

<p>Open two different shells on your system and execute the receiver in the first</p>

<p><code>text
$ python receive_ping.py
postage.messaging: global_vhost set to /
</code></p>

<p>and the sender in the second</p>

<p><code>text
$ python send_ping.py
postage.messaging: global_vhost set to /
$  
</code></p>

<p>The receiver shall at this point notify that a message has been sent</p>

<p><code>text
$ python receive_ping.py
postage.messaging: global_vhost set to /
Got a ping!
</code></p>

<p>which is what we expected. You can stop the receiver with <code>Ctrl-C</code>, this kills the Pika connection somehow abruptly, but I am not going to implement in this article a good signal management.</p>

<h4>Adding message parameters</h4>

<p>Now we want to add a parameter to the message we send, namely the time at which the message was sent. To do this we make some changes to <code>facilities.py</code></p>

<p>``` python
import time</p>

<p>[...]</p>

<p>class PingProducer(messaging.GenericProducer):</p>

<pre><code>eks = [(PingExchange, 'ping_rk')]

def build_message_ping(self):
    return messaging.MessageCommand('ping')

def build_message_timed_ping(self):
    return messaging.MessageCommand('timed_ping',
                                    parameters={'time':time.time()})
</code></pre>

<p>```</p>

<p>As you can see I just added the <code>build_message_timed_ping()</code> method, which sends a <code>timed_ping</code> command, but this time I added a <code>parameters</code> dictionary that encompasses all the parameters of the command. Remember that all the structures you put in a message are serialized in JSON by default so they must be processable by <code>json.dumps()</code>; if you need to send very complex structures you can customize Postage to use another encoder, either a customized JSON or a completely different one; see <a href="https://github.com/lgiordani/postage#encoder">the documentation</a>.</p>

<p>The receiver has to be modified accordingly:</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>@messaging.MessageHandler('command', 'ping')
def msg_ping(self, content):
    print "Got a ping!"

@messaging.MessageHandler('command', 'timed_ping')
def msg_timed_ping(self, content):
    print "Got a timed ping! Time is %s" %(content['parameters']['time'])
</code></pre>

<p>```</p>

<p>Here the new method, <code>msg_timed_ping()</code>, prints a different message extracting the parameters from the message content.
Last, you need to add the actual call that sends the message to <code>send_ping.py</code>:</p>

<p><code>python
producer = facilities.PingProducer(fingerprint.as_dict())
producer.message_ping()
producer.message_timed_ping()
</code></p>

<p>The execution shows that everything works as expected</p>

<p><code>text
$ python receive_ping.py
postage.messaging: global_vhost set to /
Got a ping!
Got a timed ping! Time is 1374826309.06
</code></p>

<h4>Adding call parameters</h4>

<p>If you want to allow the user to pass a parameter when sending the message, you just need to accept and use it in your <code>build_message_NAME()</code> method. In <code>facilities.py</code> add:</p>

<p>``` python
class PingProducer(messaging.GenericProducer):</p>

<pre><code>[...]
def build_message_custom_ping(self, custom_value):
    return messaging.MessageCommand('custom_ping',
                                parameters={'custom_value':custom_value})
</code></pre>

<p>```</p>

<p>Add a handler in the receiver (<code>receive_ping.py</code>):</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>[...]
@messaging.MessageHandler('command', 'custom_ping')
def msg_custom_ping(self, content):
    print "Got a custom ping! The custom value is %s"\
          %(content['parameters']['custom_value'])
</code></pre>

<p>```</p>

<p>And exploit it when sending the message (<code>send_ping.py</code>):</p>

<p><code>python
producer.message_custom_ping(("Just ping me", 1))
</code></p>

<p>When you execute it you get:</p>

<p><code>text
$ python receive_ping.py
postage.messaging: global_vhost set to /
Got a ping!
Got a timed ping! Time is 1374832738.18
Got a custom ping! The custom value is [u'Just ping me', 1]
</code></p>

<p>Pay attention to JSON, which does not tell apart tuples from lists.</p>

<h4>RPC calls to the rescue</h4>

<p>The ping mechanism is not really working until the server answers the message. To answer incoming messages we can implement two different strategies; the first is the asynchronous one, which leverages fire-and-forget messages, the second uses RPC calls. While the first is simpler to implement at a system level (you just send messages as usual), it is complex on the user side since it requires the programmer to structure the whole program in an asynchronous way. The second approach, resembling usual function calls, is easier to understand and include in a program; it has many downsides and caveats, however, so do not abuse it.</p>

<p>For the sake of simplicity let us implement a RPC version of the ping mechanism. First we add a specific message to the producer</p>

<p>``` python
class PingProducer(messaging.GenericProducer):</p>

<pre><code>[...]
def build_rpc_ping(self):
    return messaging.RpcCommand('ping')
</code></pre>

<p>```</p>

<p>Things are not very different from the previous cases here: we use the <code>build_rpc_NAME()</code> form of the method then we return an RpcCommand, instead of a MessageCommand. Beware that, alas!, nomenclature here is a little misleading: both are messages in the sense of "something that will be sent on the AMQP network", but while MessageCommand does not expect an answer, RpcCommand does.</p>

<p>I want to point out that the name of the message is <code>ping</code> just like the previous one; Postage tells the two messages apart using the name (<code>ping</code>), the type (<code>command</code>) and the category (<code>rpc</code> or <code>message</code>), although this latter is somewhat concealed.</p>

<p>The receiver needs a new handler to process the incoming RPC <code>ping</code> message:</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>[...]
@messaging.RpcHandler('command', 'ping')
def msg_rpc_ping(self, content, reply_func):
    print "Got a ping! Answering..."
    reply_func(messaging.MessageResult('Pong'))
</code></pre>

<p>```</p>

<p>Accordingly, there is an RPC version of <code>MessageHandler</code>, <code>RpcHandler</code>. The method has to accept an additional parameter that is a reply function; this latter can be called at any time from the method, allowing it to perform some cleanup after answering if needed. In this case, it simply sends a <code>MessageResult</code> object back with <code>'Pong'</code> as value.</p>

<p>In <code>send_ping.py</code> you can now make a remote call:</p>

<p>``` python
answer = producer.rpc_ping()</p>

<p>if answer.body['content']['type'] == 'success':</p>

<pre><code>print "Answer: %s" %(answer.body['content']['value'])
</code></pre>

<p>elif answer.body['content']['type'] == 'exception':</p>

<pre><code>print "An exception occoured! (%s)" %(answer.body['content']['value'])
</code></pre>

<p>```</p>

<p>The first part is straightforward: you call the RPC just like a local function. What you get is always a <code>MessageResult</code> object or derived (<code>MessageResultError</code> or <code>MessageResultException</code>). Be warned that the API here is awkward, to be indulgent. I wrote it, but probably the good-coder-in-me (TM) was on holiday that time; <a href="https://github.com/lgiordani/postage/issues/1">I am going to fix it</a> in a short time.</p>

<p>Anyway, you have to check the answer to be sure that the call was successful; never, never, never trust RPC calls, network is in the middle and everything can happen (yes, even someone tripping over the network cable).</p>

<p>If the receiver is unreachable the producer waits some time and then tries the call again: by default it waits 30 seconds and tries again 4 times; after all that it returns a <code>MessageResultException</code> containing a <code>TimeoutError</code> exception. You can try it changing the decorator of <code>msg_rpc_ping()</code> to match <code>ping_other</code> (or whatever) instead of <code>ping</code>. After two minutes, you will get your exception. You can easily customize these values by setting the value of <code>GenericProducer.rpc_timeout</code> and <code>GenericProducer.max_retry</code>.</p>

<h4>Handlers unleashed</h4>

<p>Message handlers are powerful, but there is a couple of tricks more in Postage. The first one is <code>MessageHandlerFullBody</code> that you can use exactly like <code>MessageHandler</code>; the difference is that the decorated method does not receive the message content (the <code>content</code> key of the body) but the full body. You can leverage this to access the underlying message structure: this allows you to access the fingerprint included in the message, which contains precious information about the process that sent the message. Let's show how it works; add a new handler to the receiver:</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>[...]
@messaging.MessageHandlerFullBody('command', 'ping')
def msg_ping_full(self, body):
    fingerprint = body['fingerprint']
    print "Got a ping from %s running on %s with pid %s"\
          %(fingerprint['name'], fingerprint['host'], fingerprint['pid'])
</code></pre>

<p>```</p>

<p>Here, we handle the <code>ping</code> command, just like the method <code>msg_ping()</code> does; indeed nothing stops you to write more than a handler for a given message, but remember that they are processed in random order. Obviously we need to give the decorated method a different name, otherwise the second one will redefine the first one. Being decorated with <code>MessageHandlerFullBody</code> the method receives the full body of the message and can access the fingerprint.</p>

<p>Executing it we get:</p>

<p><code>text
$ python receive_ping.py
postage.messaging: global_vhost set to staging
Got a ping from ping_sender running on yoda with pid 26812
Got a ping!
</code></p>

<p>As we expected both handlers have been activated by the incoming message, and, not surprisingly, they have been processed out of order.</p>

<p>The second trick handlers have in store for you is the Handler class. Instead of decorating a method you can define a class that inherits from <code>Handler</code> and decorate that; this class shall at least define a <code>call()</code> method without arguments (aside from <code>self</code>) that will be executed when the relative message arrives. This class can access <code>self.data</code>, which is the data passed by the decorator (either the message content or the full body), <code>self.reply_func</code> that defaults to <code>None</code> for non-RPC messages, and <code>self.processor</code> that is the underlying <code>MessageProcessor</code> object hosting the handler.</p>

<p>To show how it works let's add another handler to the receiver:</p>

<p>``` python
class PingReceiver(messaging.MessageProcessor):</p>

<pre><code>[...]
@messaging.MessageHandler('command', 'ping')
class MsgPing(messaging.Handler):
    def call(self):
        print "Got a ping - processed by %s hosted by %s"\
              %(self.__class__, self.processor.__class__)
</code></pre>

<p>```</p>

<p>You can see that the definition of a basic handler class is pretty simple. When executed this gives the following:</p>

<p>``` text
$ python receive_ping.py
postage.messaging: global_vhost set to staging
Got a ping - processed by <class '__main__.MsgPing'></p>

<pre><code>         hosted by &lt;class '__main__.PingReceiver'&gt;
</code></pre>

<p>Got a ping from ping_sender running on yoda with pid 27596
Got a ping!
```</p>

<p>Leveraging the full body access and the class handlers you can write advanced filters on incoming messages, and add interesting features like runtime configuration of your handlers or configuration through incoming messages.</p>

<h2>Full code</h2>

<p>This is the full code of the discussed examples.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (facilities.py)</span> <a href='/downloads/code/postage/facilities.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">postage</span> <span class="kn">import</span> <span class="n">messaging</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PingExchange</span><span class="p">(</span><span class="n">messaging</span><span class="o">.</span><span class="n">Exchange</span><span class="p">):</span>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;This is the exchange that receives ping messages.&quot;&quot;&quot;</span>
</span><span class='line'>    <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ping-exchange&quot;</span>
</span><span class='line'>    <span class="n">exchange_type</span> <span class="o">=</span> <span class="s">&quot;direct&quot;</span>
</span><span class='line'>    <span class="n">passive</span> <span class="o">=</span> <span class="bp">False</span>
</span><span class='line'>    <span class="n">durable</span> <span class="o">=</span> <span class="bp">True</span>
</span><span class='line'>    <span class="n">auto_delete</span> <span class="o">=</span> <span class="bp">False</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PingProducer</span><span class="p">(</span><span class="n">messaging</span><span class="o">.</span><span class="n">GenericProducer</span><span class="p">):</span>
</span><span class='line'>    <span class="c"># Send messages to this exchange with this routing key</span>
</span><span class='line'>    <span class="n">eks</span> <span class="o">=</span> <span class="p">[(</span><span class="n">PingExchange</span><span class="p">,</span> <span class="s">&#39;ping_rk&#39;</span><span class="p">)]</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Send a &#39;ping&#39; command</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">build_message_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">messaging</span><span class="o">.</span><span class="n">MessageCommand</span><span class="p">(</span><span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Send a &#39;timed_ping&#39; command</span>
</span><span class='line'>    <span class="c"># Parameters: time</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">build_message_timed_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">messaging</span><span class="o">.</span><span class="n">MessageCommand</span><span class="p">(</span><span class="s">&#39;timed_ping&#39;</span><span class="p">,</span>
</span><span class='line'>	    <span class="n">parameters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">:</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()})</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Send a &#39;custom_ping&#39; command</span>
</span><span class='line'>    <span class="c"># Parameters: custom_value</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">build_message_custom_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">custom_value</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">messaging</span><span class="o">.</span><span class="n">MessageCommand</span><span class="p">(</span><span class="s">&#39;custom_ping&#39;</span><span class="p">,</span>
</span><span class='line'>	    <span class="n">parameters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;custom_value&#39;</span><span class="p">:</span><span class="n">custom_value</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Send a &#39;ping&#39; RPC command</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">build_rpc_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">messaging</span><span class="o">.</span><span class="n">RpcCommand</span><span class="p">(</span><span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (send_ping.py)</span> <a href='/downloads/code/postage/send_ping.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">postage</span> <span class="kn">import</span> <span class="n">messaging</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">facilities</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Build the fingerprint of this application</span>
</span><span class='line'><span class="n">fingerprint</span> <span class="o">=</span> <span class="n">messaging</span><span class="o">.</span><span class="n">Fingerprint</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;ping_sender&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Instance the ping producer</span>
</span><span class='line'><span class="n">producer</span> <span class="o">=</span> <span class="n">facilities</span><span class="o">.</span><span class="n">PingProducer</span><span class="p">(</span><span class="n">fingerprint</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Send a &#39;ping&#39; command</span>
</span><span class='line'><span class="n">producer</span><span class="o">.</span><span class="n">message_ping</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Send a &#39;timed_ping&#39; command</span>
</span><span class='line'><span class="n">producer</span><span class="o">.</span><span class="n">message_timed_ping</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Send a &#39;custom_ping&#39; command</span>
</span><span class='line'><span class="n">producer</span><span class="o">.</span><span class="n">message_custom_ping</span><span class="p">((</span><span class="s">&quot;Just ping me&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Send a &#39;ping&#39; RPC call</span>
</span><span class='line'><span class="n">answer</span> <span class="o">=</span> <span class="n">producer</span><span class="o">.</span><span class="n">rpc_ping</span><span class="p">()</span>
</span><span class='line'><span class="k">if</span> <span class="n">answer</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="s">&#39;content&#39;</span><span class="p">][</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;success&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;Answer: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">answer</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="s">&#39;content&#39;</span><span class="p">][</span><span class="s">&#39;value&#39;</span><span class="p">])</span>
</span><span class='line'><span class="k">elif</span> <span class="n">answer</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="s">&#39;content&#39;</span><span class="p">][</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;exception&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;An exception occoured! (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">answer</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="s">&#39;content&#39;</span><span class="p">][</span><span class="s">&#39;value&#39;</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (receive_ping.py)</span> <a href='/downloads/code/postage/receive_ping.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">postage</span> <span class="kn">import</span> <span class="n">messaging</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">postage</span> <span class="kn">import</span> <span class="n">microthreads</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">facilities</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Build the fingerprint of this application</span>
</span><span class='line'><span class="n">fingerprint</span> <span class="o">=</span> <span class="n">messaging</span><span class="o">.</span><span class="n">Fingerprint</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;ping_receiver&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PingReceiver</span><span class="p">(</span><span class="n">messaging</span><span class="o">.</span><span class="n">MessageProcessor</span><span class="p">):</span>
</span><span class='line'>    <span class="c"># Process an incoming &#39;ping&#39; command</span>
</span><span class='line'>    <span class="nd">@messaging.MessageHandler</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">msg_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Got a ping!&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Process an incoming &#39;timed_ping&#39; command</span>
</span><span class='line'>    <span class="nd">@messaging.MessageHandler</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;timed_ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">msg_timed_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Got a timed ping! Time is </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">content</span><span class="p">[</span><span class="s">&#39;parameters&#39;</span><span class="p">][</span><span class="s">&#39;time&#39;</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Process an incoming &#39;custom_ping&#39; command</span>
</span><span class='line'>    <span class="nd">@messaging.MessageHandler</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;custom_ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">msg_custom_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Got a custom ping! The custom value is </span><span class="si">%s</span><span class="s">&quot;</span>\
</span><span class='line'>	    <span class="o">%</span><span class="p">(</span><span class="n">content</span><span class="p">[</span><span class="s">&#39;parameters&#39;</span><span class="p">][</span><span class="s">&#39;custom_value&#39;</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Process an incoming &#39;ping&#39; RPC command</span>
</span><span class='line'>    <span class="nd">@messaging.RpcHandler</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">msg_rpc_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">reply_func</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Got a ping! Answering...&quot;</span>
</span><span class='line'>        <span class="n">reply_func</span><span class="p">(</span><span class="n">messaging</span><span class="o">.</span><span class="n">MessageResult</span><span class="p">(</span><span class="s">&#39;Pong&#39;</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Process the full body of an incoming &#39;ping&#39; command</span>
</span><span class='line'>    <span class="nd">@messaging.MessageHandlerFullBody</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">msg_ping_full</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
</span><span class='line'>        <span class="n">fingerprint</span> <span class="o">=</span> <span class="n">body</span><span class="p">[</span><span class="s">&#39;fingerprint&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Got a ping from </span><span class="si">%s</span><span class="s"> running on </span><span class="si">%s</span><span class="s"> with pid </span><span class="si">%s</span><span class="s">&quot;</span>\
</span><span class='line'>	    <span class="o">%</span><span class="p">(</span><span class="n">fingerprint</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">],</span> <span class="n">fingerprint</span><span class="p">[</span><span class="s">&#39;host&#39;</span><span class="p">],</span> <span class="n">fingerprint</span><span class="p">[</span><span class="s">&#39;pid&#39;</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># Process an incoming &#39;ping&#39; command with a class handler</span>
</span><span class='line'>    <span class="nd">@messaging.MessageHandler</span><span class="p">(</span><span class="s">&#39;command&#39;</span><span class="p">,</span> <span class="s">&#39;ping&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">MsgPing</span><span class="p">(</span><span class="n">messaging</span><span class="o">.</span><span class="n">Handler</span><span class="p">):</span>
</span><span class='line'>        <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>            <span class="k">print</span> <span class="s">&quot;Got a ping - processed by </span><span class="si">%s</span><span class="s"> hosted by </span><span class="si">%s</span><span class="s">&quot;</span>\
</span><span class='line'>		<span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Exchange/Queue/Key</span>
</span><span class='line'><span class="n">eqks</span> <span class="o">=</span> <span class="p">[(</span><span class="n">facilities</span><span class="o">.</span><span class="n">PingExchange</span><span class="p">,</span> <span class="p">[(</span><span class="s">&#39;ping_queue&#39;</span><span class="p">,</span> <span class="s">&#39;ping_rk&#39;</span><span class="p">)])]</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Instance the receiver</span>
</span><span class='line'><span class="n">receiver</span> <span class="o">=</span> <span class="n">PingReceiver</span><span class="p">(</span><span class="n">fingerprint</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span> <span class="n">eqks</span><span class="p">,</span>
</span><span class='line'>			<span class="bp">None</span><span class="p">,</span> <span class="n">messaging</span><span class="o">.</span><span class="n">global_vhost</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Instance the scheduler and run the receiver</span>
</span><span class='line'><span class="n">scheduler</span> <span class="o">=</span> <span class="n">microthreads</span><span class="o">.</span><span class="n">MicroScheduler</span><span class="p">()</span>
</span><span class='line'><span class="n">scheduler</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">receiver</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">main</span><span class="p">():</span>
</span><span class='line'>    <span class="k">pass</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>Conclusion</h2>

<p>Postage aims to make it simple to write components in Python to fully exploit the power of RabbitMQ. It is highly customizable, and its handler mechanism keeps the code compact.</p>

<p>Even if the API is already in its third implementation, you can see that it is still not perfect so stay tuned for upcoming versions. Feel free to fork the project, to submit issues or pull request, or to contact me for any question.</p>

<p>Oh, did I remember to tell you to never trust RPC calls? =)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Generators - From Iterators to Cooperative Multitasking - 3]]></title>
    <link href="http://lgiordani.github.io/blog/2013/03/29/python-generators-from-iterators-to-cooperative-multitasking-3/"/>
    <updated>2013-03-29T13:25:00+01:00</updated>
    <id>http://lgiordani.github.io/blog/2013/03/29/python-generators-from-iterators-to-cooperative-multitasking-3</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>In this third issue we move on uncovering how generators can be the foundation of a cooperative multitasking system and show some code that implements it. Before we face this topic we will talk shortly about another interesting use of generators, namely generator expressions chains.</p>

<!--more-->


<h2>Chaining generator expressions</h2>

<p>At PyCon 2008 David M. Beazley, author of “Python Essential Reference”, made a very interesting speech about the use of generators in system administration, in other words where usually more or less complex bash scripts are involved and in particular where long pipe sequences are used.</p>

<p>David starts from the consideration that generators, producing one element at a time, are chainable, that is a generator expression can encompass another generator expression and so on. This way he shows how to write in a very compact and reusable way components that can act as “filters” on a data set, thus following the Unix philosophy of building tools that “do one thing and do it well”, chaining them afterwards to get the needed behaviour.</p>

<p>The slides of this presentation are freely downloadable, so I suggest the interested reader to take a look at it at the following address: <a href="http://www.dabeaz.com/generators-uk/">Generator Tricks for Systems Programmers</a>.</p>

<h2>Microthread: cooperative multitasking</h2>

<p><em>Disclaimer: the concepts and code presented here have been heavily influenced by the Kamaelia project. You can find it <a href="http://www.kamaelia.org">here</a>.</em></p>

<p>Let us move forward to see how (Python) generators allow us to easily build applications based on the concept of cooperative multitasking. I assume the reader is familiar with the concepts of preemption and thread-based multitasking and is aware of the pro and cons of such solutions.</p>

<p><strong>Cooperative multitasking</strong> allows an application to hold the control of the CPU for an arbitrary time lapse, waiting for it to voluntarily release the resource to the scheduler. This is a major break with the modern approach to multitasking, where the scheduler is in charge of stopping and resuming applications without any previous agreement with them.</p>

<p>Since application can now stop on their own initiative every issue related to shared data protection, atomicity and synchronization is greatly simplified if not removed. Applications need however a mechanism to stop running, save their internal state and later resume from the same point.</p>

<p>Generators, indeed, through the <code>yield</code> statement implement this very behaviour, thus they may be used to create a system based on cooperative multitasking, where processes are now called <strong>microthreads</strong> to highlight that they are a lightweight form of thread.</p>

<h4>Microthreads</h4>

<p>Let’s look at a simple implementation of such a system. First of all we need a <code>MicroThread</code> object, i.e. an object that can run simultaneously with other similar objects, but in a cooperative way.</p>

<p>```python
class MicroThread(object):</p>

<pre><code>def main(self):
    while 1:
        yield 1
</code></pre>

<p>```</p>

<p>An instance of this object exposes a <code>main()</code> method that, when called, returns a generator. This latter, at each call of its <code>next()</code> method simply returns <code>1</code>, freezing at the same time its execution just after the <code>yield</code> statement, still inside the infinite while loop.</p>

<p>The object can be directly tested</p>

<p>```bash</p>

<blockquote><blockquote><blockquote><p>mt = MicroThread()
g = mt.main()
g
<generator object main at 0xb74331e4>
g.next()
1
```</p></blockquote></blockquote></blockquote>

<p>To make the object more easily inheritable and extendable we can refactor it a little</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (mthread.py)</span> <a href='/downloads/code/python-generators/mthread.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">MicroThread</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
</span><span class='line'>        <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</span><span class='line'>            <span class="k">yield</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Such changes let us inherit the class and extend it simply by overriding the <code>create()</code> and <code>step()</code> methods; the first is called as soon as <code>main()</code> is called, acting as a delayed initializer, while the second is executed at each call of <code>next()</code>, just before freezing the code with <code>yield</code>. Pay attention that since <code>create()</code> is called inside the generator function, you have to call <code>next()</code> once to run it after the genrator has been created. So the standard workflow with this object is</p>

<p>```python</p>

<h1>Instance the object</h1>

<p>mt = MicroThread()</p>

<h1>Initialize it</h1>

<p>mt.next()</p>

<h1>Loop over it</h1>

<p>mt.next()
mt.next()
...
```</p>

<p>Since <code>main()</code> is a generator function it must act as any generator and signal its exhaustion rising a <code>StopIteration</code> exception. The overridden <code>step()</code> method, thus, may raise this exception at any point (even multiple ones) to terminate the microthread.</p>

<h4>Scheduler</h4>

<p>Now we need a scheduler, i.e. the system component that manages running tasks. While in a true multitasking system the scheduler is a big and complex component, in a cooperative environment it can be rather simple: its job is to execute each task and wait till they give control back. In between a task and the following the scheduler can execute other functions, but its basic workflow is very straightforward. Obviously the scheduler shall handle the <code>StopIteration</code> exception possibly raised by a task, removing it from the list of running microthreads.</p>

<p>The core of the scheduler will be something like the following:</p>

<p>```python
for thread in active_microthreads:</p>

<pre><code>try:
    thread.next()
    scheduled_microthreads.append(thread)
except StopIteration:
    pass
</code></pre>

<p>active_microthreads = scheduled_microthreads
scheduled_microthreads = []
```</p>

<p>This snippet encompasses the behaviour described above. We have two lists, <code>active_microthreads</code> with all the tasks that shall be executed in the current loop and <code>scheduled_microthreads</code> with all the tasks that are goig to be executed in the next loop. At each loop of the scheduler all microthreads in <code>active_microthreads</code> are executed, that is they are granted one execution of their <code>next()</code> function. After this the thread is scheduled again, i.e. it is appended to the <code>scheduled_microthreads</code> list. If the thread raises the <code>StopIteration</code> exception during its execution it is simply not scheduled again. When the <code>active_microthreads</code> list is exhausted the loop ends and the scheduled threads list is transferred in the <code>active_threads</code> one; after this the loop starts again.</p>

<p>So the first implementation of the scheduler is the following:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (scheduler.py)</span> <a href='/downloads/code/python-generators/scheduler.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">Scheduler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">add_microthread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mthread</span><span class="p">):</span>
</span><span class='line'>        <span class="n">g</span> <span class="o">=</span> <span class="n">mthread</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</span><span class='line'>        <span class="n">g</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="p">:</span>
</span><span class='line'>                <span class="k">try</span><span class="p">:</span>
</span><span class='line'>                    <span class="n">thread</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>                    <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thread</span><span class="p">)</span>
</span><span class='line'>                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
</span><span class='line'>                    <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The <code>__init__()</code> method initializes the two internal lists we talked about above. The <code>add_microthread()</code> method allows us to add a microthread to the scheduler; the method calls <code>main()</code> on each microthread we add to obtain its generator, then calls <code>next()</code> once on this latter to initialize it and finally adds it to the list of scheduled tasks.</p>

<p>The scheduler logic is then implemented in the <code>run()</code> method, which executes the above core code in an infinite while loop.</p>

<p>We can test the microthreads and the scheduler with this simple code</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (test_scheduler.py)</span> <a href='/downloads/code/python-generators/test_scheduler.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">mthread</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">scheduler</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">TestMicroThread</span><span class="p">(</span><span class="n">mthread</span><span class="o">.</span><span class="n">MicroThread</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">number</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Number:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span>
</span><span class='line'>        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">mt1</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">mt2</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">mt3</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">ms</span> <span class="o">=</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">Scheduler</span><span class="p">()</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt1</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt2</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Here the <code>TestMicroThread</code> is a microthread but the <code>step()</code> method was reimplemented to print a number and wait 1 second. Three microthreads are instanced and added to the scheduler and the <code>run()</code> method of the scheduler is executed. Not surprisingly the result is the following</p>

<p><code>bash
$ python test_scheduler.py
Number: 1
Number: 2
Number: 3
Number: 1
Number: 2
Number: 3
[...]
</code></p>

<p>The three microthreads are executed in a round-robin fashion, as expected from a cooperative multitasking system.</p>

<p>Note: while all microthreads showed in this article just execute <code>yield 1</code> to freeze the code, <code>yield</code> can return any object, just like the <code>return</code> statement does, and this could be exploited to enhance the communication between microthreads and scheduler.</p>

<h4>Microschedulers</h4>

<p>The scheduler could however be more flexible, specifically it could be converted to a microthread itself. The scheduler, when executed, will return a generator, and each call of its <code>next()</code> method will run one of its microthreads. After this the scheduler will freeze and give control back.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (mscheduler.py)</span> <a href='/downloads/code/python-generators/mscheduler.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">MicroScheduler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">add_microthread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mthread</span><span class="p">):</span>
</span><span class='line'>        <span class="n">g</span> <span class="o">=</span> <span class="n">mthread</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</span><span class='line'>        <span class="n">g</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>                <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span><span class="p">:</span>
</span><span class='line'>                <span class="k">try</span><span class="p">:</span>
</span><span class='line'>                    <span class="n">thread</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>                    <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thread</span><span class="p">)</span>
</span><span class='line'>                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
</span><span class='line'>                    <span class="k">pass</span>
</span><span class='line'>                <span class="k">yield</span> <span class="mi">1</span>
</span><span class='line'>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">active_microthreads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">scheduled_microthreads</span> <span class="o">=</span> <span class="p">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It is sufficient to rename <code>run()</code> to <code>main()</code>, to match our arbitrary microthread interface, and add some <code>yield</code> statements. The first <code>yield</code> at the beginning of <code>main()</code> terminates the creation part: this scheduler has no <code>create()</code> method, but if present it should be called here. The second <code>yield</code> is called if the scheduler contains no microthreads, since it has nothing to do. The third <code>yield</code> is called after each loop of the microthread running part.</p>

<p>These little changes allow the scheduler to be run into another scheduler, thus enabling us to create a hierarchy to easily build complex systems. At the same time the scheduler can be used as usual simply calling its <code>next()</code> method in a for loop.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (test_mscheduler.py)</span> <a href='/downloads/code/python-generators/test_mscheduler.py'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">mthread</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">mscheduler</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">TestMicroThread</span><span class="p">(</span><span class="n">mthread</span><span class="o">.</span><span class="n">MicroThread</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">number</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Number:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span>
</span><span class='line'>        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">mt1</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">mt2</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">mt3</span> <span class="o">=</span> <span class="n">TestMicroThread</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">ms</span> <span class="o">=</span> <span class="n">mscheduler</span><span class="o">.</span><span class="n">MicroScheduler</span><span class="p">()</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt1</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt2</span><span class="p">)</span>
</span><span class='line'><span class="n">ms</span><span class="o">.</span><span class="n">add_microthread</span><span class="p">(</span><span class="n">mt3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ms</span><span class="o">.</span><span class="n">main</span><span class="p">():</span>
</span><span class='line'>    <span class="k">pass</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This example is obviously very simple. However it shows how simple it is to build components of a cooperative system and let them live together in an execution space. Executing the scheduler in a different way, for example inside another generator, new microthreads can also be added live. This allows to instance system components on the fly to manage specific needs, such as incoming service requests.</p>

<h2>Conclusions</h2>

<p>Obviously this sort of multitasking cannot provide an interactive execution like that used on our desktop OS or on a Web server, where human users must receive an immediate feedback of their actions. But for systems where task must simply be simultaneously executed without timing needs cooperative multitasking is a valuable solution, due to its simplicity.</p>

<p>Another interesting scenario is that of a real multitasking system (ruled by threaded code or by the OS itself) where each task is made of small cooperating components. This way putting multiple functionalities inside a single component becomes a breeze; the code of each functionality could also be splitted in several plugins and loaded on demand.</p>

<p>A package that implements cooperative multitasking with generator based microthreads is <a href="http://www.kamaelia.org">Kamaelia</a>, and this article has been heavily inspired by it. Other solutions you can find interesting are <a href="http://pypi.python.org/pypi/greenlet">greenlet</a>, presently the most used microthread Python library that runs on the standard unmodified Python interpreter and <a href="http://www.stackless.com/">Stackless Python</a>, a fork of Python that natively implements microthreads.</p>

<h2>Past articles</h2>

<ul>
<li><a href="/blog/2013/03/25/python-generators-from-iterators-to-cooperative-multitasking">Python Generators - From Iterators to Cooperative Multitasking</a></li>
<li><a href="/blog/2013/03/26/python-generators-from-iterators-to-cooperative-multitasking-2">Python Generators - From Iterators to Cooperative Multitasking 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Generators - From Iterators to Cooperative Multitasking - 2]]></title>
    <link href="http://lgiordani.github.io/blog/2013/03/26/python-generators-from-iterators-to-cooperative-multitasking-2/"/>
    <updated>2013-03-26T14:05:00+01:00</updated>
    <id>http://lgiordani.github.io/blog/2013/03/26/python-generators-from-iterators-to-cooperative-multitasking-2</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>After the recap of the iteration process in Python, in this post we will introduce the concept of generator, which aims to solve some problems that arise from the use of iterators.</p>

<!--more-->


<h2>Generators</h2>

<p>The for construct is generally simple to use and such a loop can be found in almost all programming languages. Its implementation, however, can be problematic in some cases. Let’s look at an example:</p>

<p>```python
def sequence(num):</p>

<pre><code>s = []
i = 0
while i != num:
    s.append(i)
    i += 1
return s
</code></pre>

<p>for i in sequence(5):</p>

<pre><code>print i
</code></pre>

<p>```</p>

<p>At  first sight <code>sequence()</code> seems to be a good function without big defects (for the sake of simplicity error checking has been intentionally omitted - it does not work with negative numbers for example - and the code is intentionally non-pythonic).</p>

<p>The problem concealed in such code is that the function does not execute return until the whole list has been built and until the function returns the loop does not start. Thus when the loop begins the function already processed the whole data set.</p>

<p>While you are building normal sequences of numbers this can be considered irrelevant, even for rather long ones. The problem gets worse when the data set becomes very big or when the creation of an element is very demanding process; in the first case the function might fill the memory, whereas in the second one the whole execution can last a very long time. Both conditions happen even before the loop produces the first element.</p>

<p>The solution can be found in the generation concept: generating, in this context, means producing only one element of the sequence at each function call. This way each call will take the minimum amount of memory and CPU time needed to create the element and the loop will start immediately.</p>

<p>To allow the implementation of such a solution without using global variables generators have been introduced in Python. A <strong>generator</strong> is a special type of iterator, its peculiarity being the way it is built. Aside from this, generators behave the same exact way as iterators.</p>

<p>A generator is built from every function that contains the <strong>yield</strong> statement; <code>yield</code>’s behaviour follows that of the <code>return</code> statement, i.e. it terminates the function returning a value to the caller. But whereas return permanently terminates the function, giving up local variables to the garbage collector, <code>yield</code> freezes the function’s code, allowing a later call to resume execution immediately after <code>yield</code>, with all local variables initialized as they were during the previous execution.</p>

<p>Pay attention to the fact that the first call of a function that contains an <code>yield</code> statement returns a generator immediately, without executing a single line of the function’s code. Since a generator is an iterator it automatically exposes a next() method that, when called, will actually continue the execution of the frozen function.</p>

<p>A simple example of generator is the following:</p>

<p>```python
def dec(num):</p>

<pre><code>x = num
while 1:
    x -= 1
    yield x
</code></pre>

<p>```</p>

<p>```bash</p>

<blockquote><blockquote><blockquote><p>g = dec(8)
g
<generator object dec at 0xb6abbf2c>
```</p></blockquote></blockquote></blockquote>

<p>When executed, the <code>dec()</code> function returns a <strong>generator object</strong> and no lines of code have been executed (i.e. <code>x</code> has not yet been initialized).</p>

<p>As soon as <code>next()</code> is called for the first time <code>x</code> will be initialized with the value passed to the function (8 in the example above) and the infinite loop will start. Inside it the local variable <code>x</code> will be decremented and returned to the caller by <code>yield</code>. This latter will also freeze again the code, holding the internal state, in this case the value of the variable <code>x</code>.</p>

<p>```bash</p>

<blockquote><blockquote><blockquote><p>g.next()
7
g.next()
6
g.next()
5
g.next()
4
```</p></blockquote></blockquote></blockquote>

<p>As you can see the generator <code>g</code> remembers its previous state and acts accordingly.</p>

<p>Since generators are iterators they are allowed to raise the <code>StopIteration</code> exception to signal their exhaustion. In the previous example the <code>dec()</code> function never raises it, thus providing an infinite generator (or infinite iterator).</p>

<p>Another caveat: as for return a function is not limited to one statement, but can contain more than one; obviously the peculiarity of yield makes this scenario rather complex, opening at the same time remarkable possibilities such as that of easily build state machines.</p>

<p>What happens if we call the function again, maybe with a different value of the parameter? We simply obtain a new generator object that is completely independent from the first one, although it behaves the same way.</p>

<p>```bash</p>

<blockquote><blockquote><blockquote><p>f = dec(12)
f
<generator object dec at 0xb72e1cac>
f.next()
11
g.next()
3
f.next()
10
g.next()
2
```</p></blockquote></blockquote></blockquote>

<p>Let’s recap the whole concept. A function containing the <code>yield</code> statement is called generator function and when executed returns a generator object; this is nothing more than a simple iterator, which automatically implements the freeze and resume of the function’s code.</p>

<p>Pay attention to the fact that a generator is an iterator (it exposes <code>next()</code> and <code>__iter__()</code> methods and may raise <code>StopIteration</code>) but the opposite is not always true. A generator is an iterator built by a generator function, i.e. through the use of the <code>yield</code> statement; as explained there are other ways to build iterators.</p>

<p>Back to the <code>sequence()</code> function showed above we can now write it as a generator function and use it to build arbitrarily long sequences and, at the limit, infinite.</p>

<p>```python
def sequence(num):</p>

<pre><code>i = 0
while 1:
    if i == num:
        raise StopIteration
    yield i
    i += 1
</code></pre>

<p><code>
</code>bash</p>

<blockquote><blockquote><blockquote><p>s = sequence(3)
s.next()
0
s.next()
1
s.next()
2
s.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in sequence
StopIteration</p>

<p>for i in sequence(3):
...  print i
...
0
1
2
```</p></blockquote></blockquote></blockquote>

<h2>Generators and iterators</h2>

<p>A question might arise: if generators are iterators why should we use the <code>yield</code>-based method to create them? After all, generator functions are simple to write but not so simple to manage, due to the radically different behaviour from that of standard functions. Wouldn’t it be enough to create an iterable object that at each call of the <code>next()</code> method creates the correct element of the sequence?</p>

<p>The answer is certainly affirmative: everything you can do with generators can be done with standard iterators. There are two caveats, however.</p>

<p>First consideration is about performances: instancing an object and calling its methods is slower than calling a function. Every time you hear talking about performance problems always think about Web services, administration or scientific tools and in general about big amounts of data. Obviously a script that manages a dozen or so files is not noticeably affected by such problems.</p>

<p>Second consideration is about code complexity, since writing a function is simpler than writing an object. Take into account, however, that an iterable object can be enriched by custom methods that make it more flexible than a generator; for instance a <code>reset()</code> method that can restore the object to its initial state.</p>

<h2>Generator expressions</h2>

<p>The two observations above identify the problems that generators can solve in a simpler way than iterators do; one of those problems concerns the processing of long arrays of data.</p>

<p>Every Python programmer uses and hopefully appreciates the elegance of list comprehension. The following code instances with a single line 100 objects of the <code>MyObject</code> class and puts them in a list</p>

<p><code>python
object_list = [MyObject() for i in range(100)]
</code></p>

<p>where the classic code would be</p>

<p>```python
object_list = []
for i in range(100):</p>

<pre><code>object_list.append(MyObject())
</code></pre>

<p>```</p>

<p>Surely it is not a lot of code, but it is less easy to understand immediately and less elegant; less pythonic, in a word. List comprehension, however, being nothing more than an alternative syntax to express the above for loop, suffers from the same problems, particularly from performance issues we talked about earlier. Bitter enemies of list comprehensions are long lists and objects which creation is expensive.</p>

<p>Could we take advantage of generators in this case? Yes, with <strong>generator expressions</strong>. The syntax of such expressions is identical to that of list comprehension, except for the use of round brackets instead of square ones. While list comprehension returns a list, however, a generator expression return a generator, as the name implies. The previous code could thus be written this way</p>

<p><code>python
object_generator = (MyObject() for i in range(100))
</code></p>

<p>where <code>object_generator</code> is a generator like one of those returned by a generator function. This latter form of the code would be</p>

<p>```python
def object_generator_function():</p>

<pre><code>for i in range(100):
    yield MyObject()
</code></pre>

<p>object_generator = object_generator_function()
```</p>

<p>Which is, as happens for list comprehension and for loops, less elegant than its equivalent shortcut syntax. Obviously, returning a generator has all the advantages we described above: after the generator expression has been executed no element has yet been created. That will happen when the generator is consumed by a for loop or a similar construct.</p>

<p>As for list comprehension, generator expressions can encompass a condition in the form</p>

<p><code>python
generator = (expression for i in s if condition).
</code></p>

<p>and can also be directly used as arguments for single-argument functions, using function call brackets to mark the expression.</p>

<p><code>python
afunction(expression for i in s)
</code></p>

<p>There is however no real performance improvement using such a syntax, since the generator is exhausted before passing it to the function, but the syntax is very elegant and compact.</p>

<p>A typical example of this use is that of the so-called <strong>dictionary comprehension</strong>; from two lists of the same length, one of keys and one of values, we can obtain a dictionary with</p>

<p><code>python
d = dict(z for z in zip(keys, values))
</code></p>

<p>since <code>dict()</code> accepts an iterable of <code>(key, value)</code> tuples, which is what the generator with <code>zip()</code> returns.</p>

<h2>Conclusions</h2>

<p>Generators are a very powerful tool, not only because they simplify the creation of iterators, but also for the advantage of delaying the creation of the objects in a list and for the capability of generator functions to interrupt and resume the execution. As we will see in the third post this last feature is the foundation stone of an easy approach to cooperative multitasking.</p>

<h2>Past articles</h2>

<ul>
<li><a href="/blog/2013/03/25/python-generators-from-iterators-to-cooperative-multitasking">Python Generators - From Iterators to Cooperative Multitasking</a></li>
</ul>


<h2>Next articles</h2>

<ul>
<li><a href="/blog/2013/03/29/python-generators-from-iterators-to-cooperative-multitasking-3">Python Generators - From Iterators to Cooperative Multitasking 3</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python generators - from iterators to cooperative multitasking]]></title>
    <link href="http://lgiordani.github.io/blog/2013/03/25/python-generators-from-iterators-to-cooperative-multitasking/"/>
    <updated>2013-03-25T10:41:00+01:00</updated>
    <id>http://lgiordani.github.io/blog/2013/03/25/python-generators-from-iterators-to-cooperative-multitasking</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Python is a language that in 11 years of life has been through a very remarkable development and the introduction of several new features, sometimes borrowed from other languages, sometimes arisen from the needs of developers and heavily discussed before being officially implemented. One of these improvements concerns generators, a concept which can be found in the computer science environment since the 70s; it has been implemented in Python from version 2.2 (2001) and became popular from version 2.3 (2003).</p>

<!--more-->


<p>Generators are a generalization of functions that allow to deal in a more complete and rich way with iterations, repeated executions and in general with everything concerns the program flow. In the last years a concept which was considered obsolete started to spread again, namely that of cooperative multitasking. This concept has been shadowed for some years by the advent of multiprocessing and multithreading but, as happened to interpreted languages and virtual machines, as time passes and contexts change good ideas rise again and prove to be anything but dead.</p>

<p>In the Python world, in particular, numerous solutions have appeared which endorse the use of microthreads: these are parallel execution flows without implicit scheduling as opposed to what happens with traditional processes and threads. The big advantage of such objects is the ease of implementation and management of the multiprogramming code, since all synchronization and data protection problems simply do not exist. On the other hand, their use requires a voluntary scheduling, in other words a system that explicitly acquires and releases system resources.</p>

<p>To start talking about cooperative multitasking in Python, thus, it is imperative to understand generators. This first post reviews the concept of iteration and its implementation.</p>

<h2>Iterations</h2>

<p><strong>Iteration</strong> in Python, like in other languages, is a process ruled by the <strong>for</strong> statement and allows to repeatedly execute a block of code, assigning to a variable a value extracted at each execution from a given ordered set. The simplest case of iteration is the processing of a list of values</p>

<p>``` python
for i in [0,1,2,3]:</p>

<pre><code>print i
</code></pre>

<p>```</p>

<p>In Python, however, iteration is more than simple loop over the elements of an array. The for statement implements a well-defined and nontrivial protocol, which allows to build very complex objects.</p>

<p>To understand the structure of iteration in Python we have to clarify what is the difference between iterable and iterator objects.</p>

<h4>Iterators</h4>

<p>In Python jargon an iterator is an object with the following properties:</p>

<ul>
<li>it contains a <strong>set of data</strong></li>
<li>it exposes the <code>next()</code> method, which returns one of the contained elements at each call. Each element is returned only one time. This method goes through the whole set of data the iterator incorporates. In Python 3 this method has been renamed <code>__next__()</code>.</li>
<li>after the <code>next()</code> method returns the last element any successive call of this method raises the <code>StopIteration</code> exception. This signals that the iterator is exhausted.</li>
<li>it exposes the <code>__iter__()</code> method that returns the iterator itself.</li>
</ul>


<h4>Iterables</h4>

<p>The definition of iterable, on the other hand, is more generic: an iterable is a container of data that exposes either the <code>__getitem__()</code> or the <code>__iter__()</code> methods (or both):</p>

<ul>
<li><code>__getitem__(i)</code> shall return the value at the given position <code>i</code> or raise the <code>IndexError</code> exception if there is no data at that position.</li>
<li><code>__iter__()</code> shall return an iterator on the data contained in the iterable</li>
</ul>


<p>As you can see the <code>__getitem__()</code> method considers the data as an ordered set, which is not always the case; for this reason an iterable may define the two different methods, or both.</p>

<p>From the previous definitions you see that an iterator is also automatically an iterable, since it exposes the <code>__iter__()</code> method that returns an iterator (itself).</p>

<h4>Loop protocol</h4>

<p>Back to the loop syntax from above we can clarify the matter saying that in Python <strong>the for statement expects an iterable as argument</strong>. This means that we can give any object the capability of being used in a for loop, simply exposing one of the two previously mentioned methods, <code>__getitem__()</code> or <code>__iter__()</code>.</p>

<p>Let’s look at an example:</p>

<p>```python
class AnIterator(object):</p>

<pre><code>def __init__(self, value):
    self.value = value

def next(self):
    if self.value &lt;= 0:
        raise StopIteration
    tmp = self.value
    self.value = self.value - 1
    return tmp

def __iter__():
    return self
</code></pre>

<p>```</p>

<p>This object is an iterator since it exposes <code>__iter__()</code>. Its <code>next()</code> method returns the decreasing sequence of integer numbers starting from a given number. Testing it we obtain</p>

<p>```sh</p>

<blockquote><blockquote><blockquote><p>iterator = AnIterator(3)
print iterator.next()
3
print iterator.next()
2
print iterator.next()
1
print iterator.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 7, in next
StopIteration</p>

<p>iterator = AnIterator(3)
for i in iterator:
...     print i
...
3
2
1
```</p></blockquote></blockquote></blockquote>

<p>This execution shows that the iterator can be used in a for loop. Pay attention to the fact that I had to instance twice the class, since the first three calls of next() exhausted the first instance.</p>

<p>Let’s dive a little more inside what happens when the for loop runs. The Python code</p>

<p>```python
for i in iterable:</p>

<pre><code>some_code
</code></pre>

<p>```</p>

<p>is equivalent to</p>

<p>```python
_iter = iterable.<strong>iter</strong>()
while 1:</p>

<pre><code>try:
    i = _iter.next()
except StopIteration:
    break
some_code
</code></pre>

<p>```</p>

<p>The for construct receives here an <strong>iterable</strong> object and calls its <code>__iter__()</code> method, obtaining an <strong>iterator</strong> object; then it calls the <code>next()</code> method of this latter until the <code>StopIteration</code> exception is raised. The actual code is a little different, here simplified for clarity’s sake; if you want to learn more about it check the following addresses</p>

<ul>
<li><a href="http://docs.python.org/2/glossary.html">Python Glossary</a></li>
<li><a href="http://docs.python.org/2/library/functions.html#iter">Built-in iter()</a></li>
<li><a href="http://docs.python.org/2/library/stdtypes.html#typeiter">Iterators and sequences</a></li>
</ul>


<h2>Conclusion</h2>

<p>This first post tried to summarize the loop protocol implemented by the for statement, which is in Python very different from many classic languages. Next post will explore the concept of generator and its Python implementation.</p>

<h2>Next articles</h2>

<ul>
<li><a href="/blog/2013/03/26/python-generators-from-iterators-to-cooperative-multitasking-2">Python Generators - From Iterators to Cooperative Multitasking 2</a></li>
<li><a href="/blog/2013/03/29/python-generators-from-iterators-to-cooperative-multitasking-3">Python Generators - From Iterators to Cooperative Multitasking 3</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
