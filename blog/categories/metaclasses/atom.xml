<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: metaclasses | The digital cat]]></title>
  <link href="http://lgiordani.com/blog/categories/metaclasses/atom.xml" rel="self"/>
  <link href="http://lgiordani.com/"/>
  <updated>2014-10-15T15:44:25+02:00</updated>
  <id>http://lgiordani.com/</id>
  <author>
    <name><![CDATA[Leonardo Giordani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advanced use of Python decorators and metaclasses]]></title>
    <link href="http://lgiordani.com/blog/2014/10/14/decorators-and-metaclasses/"/>
    <updated>2014-10-14T09:43:08+02:00</updated>
    <id>http://lgiordani.com/blog/2014/10/14/decorators-and-metaclasses</id>
    <content type="html"><![CDATA[<h2>Abstract</h2>

<p>While introducing people to Python metaclasses I realized that sometimes the big problem of the most powerful Python features is that programmers do not perceive how they may simplify their usual tasks. Therefore, features like metaclasses are considered a fancy but rather unuseful addition to a standard OOP language, instead of a real game changer.</p>

<p>This post wants to show how to use metaclasses and decorators to create a powerful class that can be inherited and customized by easily adding decorated methods.</p>

<!--more-->


<h2>Metaclasses and decorators: a match made in space</h2>

<p>Metaclasses are a complex topic, and most of the times even advanced programmers do not see a wide range of practical uses for them. Chances are that this is the part of Python (or other languages that support metaclasses, like Smalltalk and Ruby) that fits the least the "standard" object-oriented patterns or solutions found in C++ and Java, just to mention two big players.</p>

<p>Indeed metaclasess usually come in play when programming advanced libraries or frameworks, where a lot of automation must be provided. For example, Django Forms system heavily relies on metaclasses to provide all its magic.</p>

<p>We also have to note, however, that we usually call "magic" or "tricks" all those techniques we are not familiar with, and as a result in Python many things are called this way, being its implementation often peculiar compared to other languages.</p>

<p>Time to bring some spice into your programming: let's practice some Python wizardry and exploit the power of the language!</p>

<p>In this post I want to show you an interesting joint use of decorators and metaclasses. I will show you how to use decorators to mark methods so that they can be automatically used by the class when performing a given operation.</p>

<p>More in detail, I will implement a class that can be called on a string to "process" it, and show you how to implement different "filters" through simple decorated methods. What I want to obtain is something like this:</p>

<p>```python
class MyStringProcessor(StringProcessor):</p>

<pre><code>@stringfilter
def capitalize(self, str):
    [...]

@stringfilter
def remove_double_spaces(self, str):
    [...]
</code></pre>

<p>msp = MyStringProcessor()
"A test string" == msp("a test  string")
```</p>

<p>The module defines a <code>StringProcessor</code> class that I can inherit and customize adding methods that have a standard signature <code>(self, str)</code> and are decorated with <code>@stringfilter</code>. This class can later be instatiated and the instance used to directly process a string and return the result. Internally the class automatically executes all the decorated methods in succession. I also would like the class to obey the order I defined the filters: first defined, first executed.</p>

<h2>The Hitchhiker's Guide To Metaclasses</h2>

<p>How can metaclasses help to reach this target?</p>

<p>Simply put, metaclasses are classes that are instantiated to get classes. That means that whenever I use a class, for example to instantiate it, first Python <em>builds</em> that class using the metaclass and the class definition we wrote. For example, you know that you can find the class members in the <code>__dict__</code> attribute: this attribute is created by the standard metaclass, which is <code>type</code>.</p>

<p>Given that, a metaclass is a good starting point for us to insert some code to identify a subset of functions inside the definition of the class. In other words, we want the output of the metaclass (that is, the class) be built exactly as happens in the standard case, but with an addition: a separate list of all the methods decorated with <code>@stringfilter</code>.</p>

<p>You know that a class has a <em>namespace</em>, that is a dictionary of what was defined inside the class. So, when the standard <code>type</code> metaclass is used to create a class, the class body is parsed and a <code>dict()</code> object is used to collect the namespace.</p>

<p>We are however interested in preserving the order of definition and a Python dictionary is an unordered structure, so we take advantage of the <code>__prepare__</code> hook introduced in the class creation process with Python 3. This function, if present in the metaclass, is used to preprocess the class and to return the structure used to host the namespace. So, following the example found in the official documentation, we start defining a metaclass like</p>

<p>```python
class FilterClass(type):</p>

<pre><code>@classmethod
def __prepare__(metacls, name, bases, **kwds):
    return collections.OrderedDict()
</code></pre>

<p>```</p>

<p>This way, when the class will be created, an <code>OrderedDict</code> will be used to host the namespace, allowing us to keep the definition order. Please note that the signature <code>__prepare__(metacls, name, bases, **kwds)</code> and the <code>@classmethod</code> decorator are enforced by the language.</p>

<p>The second function we want to define in our metaclass is <code>__new__</code>. Just like happens for the instantiation of classes, this method is invoked by Python to get a new instance of the metaclass, and is run before <code>__init__</code>. Its signature has to be <code>__new__(cls, name, bases, namespace, **kwds)</code> and the result shall be an instance of the metaclass. As for its normal class counterpart (after all a metaclass is a class), <code>__new__()</code> usually wraps the same method of the parent class, <code>type</code> in this case, adding its own customizations.</p>

<p>The customization we need is the creation of a list of methods that are marked in some way (the decorated filters). Say for simplicity's sake that the decorated methods have an attribute <code>_filter</code>.</p>

<p>The full metaclass is then</p>

<p>```python
class FilterClass(type):</p>

<pre><code>@classmethod
def __prepare__(metacls, name, bases, **kwds):
    return collections.OrderedDict()

def __new__(cls, name, bases, namespace, **kwds):
    result = type.__new__(cls, name, bases, dict(namespace))
    result._filters = [
        value for value in namespace.values() if hasattr(value, '_filter')]
    return result
</code></pre>

<p>```</p>

<p>Now we have to find a way to mark all filter methods with a <code>_filter</code> attribute.</p>

<h2>The Anatomy of Purple Decorators</h2>

<p><strong>decorate</strong>: <em>to add something to an object or place, especially in order to make it more attractive</em> (Cambridge Dictionary)</p>

<p>Decorators are, as the name suggests, the best way to augment functions or methods. Remember that a decorator is basically a callable that accepts another callable, processes it, and returns it.</p>

<p>Used in conjunction with metaclasses, decorators are a very powerful and expressive way to implement advanced behaviours in our code. In this case we may easily use them to add an attribute to decorated methods, one of the most basic tasks for a decorator.</p>

<p>I decided to implement the <code>@stringfilter</code> decorator as a function, even if I usually prefer implementing them as classes. The reason is that decorator classes behave differently when used to implement decorators without arguments rather than decorators with arguments. In this case this difference would force to write some complex code and an explanation of that would be overkill now. In a future post on dectorators you will find all the gory details, but in the meantime you may check the three Bruce Eckel posts listed in the references section.</p>

<p>The decorator is very simple:</p>

<p>```python
def stringfilter(func):</p>

<pre><code>func._filter = True
return func
</code></pre>

<p>```</p>

<p>As you can see the decorator just creates an attribute called <code>_filter</code> into the function (remember that functions are objects). The actual value of this attribute is not important in this case, since we are just interested in telling apart class members that contain it.</p>

<h2>The Dynamics of a Callable Object</h2>

<p>We are used to think about functions as special language components that may be "called" or executed. In Python functions are objects, just like everything else, and the feature that allows them to be executed comes from the presence of the <code>__call__()</code> method. Python is polymorphic by design and based on delegation, so (almost) everything that happens in the code relies on some features of the target object.</p>

<p>The result of this generalization is that every object that contains the <code>__call__()</code> method may be executed like a function, and gains the name of <em>callable object</em>.</p>

<p>The <code>StringProcessor</code> class shall thus contain this method and perform there the string processing with all the contained filters. The code is</p>

<p>```python
class StringProcessor(metaclass=FilterClass):</p>

<pre><code>def __call__(self, string):
    _string = string
    for _filter in self._filters:
        _string = _filter(self, _string)

    return _string
</code></pre>

<p>```</p>

<p>A quick review of this simple function shows that it accepts the string as an argument, stores it in a local variable and loops over the filters, executing each of them on the local string, that is on the result of the previous filter.</p>

<p>The filter functions are extracted from the <code>self._filters</code> list, that is compiled by the <code>FilterClass</code> metaclass we already discussed.</p>

<p>What we need to do now is to inherit from <code>StringProcessor</code> to get the metaclass machinery and the <code>__call__()</code> method, and to define as many methods as needed, decorating them with the <code>@stringfilter</code> decorator.</p>

<p>Note that, thanks to the decorator and the metaclass, you may have other methods in your class that do not interfere with the string processing as long as they are not decorated with the decorator under consideration.</p>

<p>An example derived class may be the following</p>

<p>```python
class MyStringProcessor(StringProcessor):</p>

<pre><code>@stringfilter
def capitalize(self, string):
    return string.capitalize()

@stringfilter
def remove_double_spaces(self, string):
    return string.replace('  ', ' ')
</code></pre>

<p>```</p>

<p>The two <code>capitalize()</code> and <code>remove_double_spaces()</code> methods have been decorated, so they will be applied in order to any string passed when calling the class. A quick example of this last class is</p>

<p>```pycon</p>

<blockquote><blockquote><blockquote><p>import strproc
msp = strproc.MyStringProcessor()
input_string = "a test  string"
output_string = msp(input_string)
print("INPUT STRING:", input_string)
INPUT STRING: a test  string
print("OUTPUT STRING:", output_string)
OUTPUT STRING: A test string</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>That's it!</p>

<h2>Final words</h2>

<p>There are onviously other ways to accomplish the same task, and this post wanted just to give a practical example of what metaclasses are good for, and why I think that they should be part of any Python programmer's arsenal.</p>

<h2>Book Trivia</h2>

<p>Section titles come from the following books: <em>A Match Made in Space - George McFly</em>, <em>The Hitchhiker's Guide To the Galaxy - Various Authors</em>, <em>The Anatomy of Purple Dragons - Unknown</em>, <em>The Dynamics of an Asteroid - James Moriarty</em>.</p>

<h2>Source code</h2>

<p>The <a href="/downloads/code/metaclasses/strproc.py">strproc.py</a> file contains the full source code used in this post.</p>

<h2>Online resources</h2>

<p>The following resources may be useful.</p>

<h4>Metaclasses</h4>

<ul>
<li>Python 3 official documentation: <a href="https://docs.python.org/3.4/reference/datamodel.html#customizing-class-creation">customizing class creation</a>.</li>
<li>Python 3 OOP Part 5 - Metaclasses <a href="/blog/2014/09/01/python-3-oop-part-5-metaclasses">on this blog</a>.</li>
<li><a href="http://python-3-patterns-idioms-test.readthedocs.org/en/latest/Metaprogramming.html">Metaprogramming examples and patterns</a> (still using some Python 2 code but useful).</li>
</ul>


<h4>Decorators</h4>

<ul>
<li><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">Bruce Eckel</a> on decorators (series of three posts, 6 years old but still valid).</li>
<li><a href="http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/">A different approach</a> on explaining decorators.</li>
<li><a href="http://www.jeffknupp.com/blog/2013/11/29/improve-your-python-decorators-explained/">Jeff Knupp</a> goes deep inside the concept of function.</li>
</ul>


<h4>Callable objects</h4>

<ul>
<li><a href="http://www.rafekettler.com/magicmethods.html#callable">Rafe Kettler</a> provides a very detaild guide on Python "magic" methods.</li>
</ul>


<h2>Feedback</h2>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 3 OOP Part 6 - Abstract Base Classes]]></title>
    <link href="http://lgiordani.com/blog/2014/09/04/python-3-oop-part-6-abstract-base-classes/"/>
    <updated>2014-09-04T10:00:00+02:00</updated>
    <id>http://lgiordani.com/blog/2014/09/04/python-3-oop-part-6-abstract-base-classes</id>
    <content type="html"><![CDATA[<!--more-->


<h2>Previous post</h2>

<p><a href="/blog/2014/09/01/python-3-oop-part-5-metaclasses">Python 3 OOP Part 5 - Metaclasses</a></p>

<h2>The Inspection Club</h2>

<p>As you know, Python leverages polymorphism at its maximum by dealing only with generic references to objects. This makes OOP not an addition to the language but part of its structure from the ground up. Moreover, Python pushes the EAFP appoach, which tries to avoid direct inspection of objects as much as possible.</p>

<p>It is however very interesting to read what Guido van Rossum says in <a href="http://legacy.python.org/dev/peps/pep-3119/">PEP 3119</a>: <em>Invocation means interacting with an object by invoking its methods. Usually this is combined with polymorphism, so that invoking a given method may run different code depending on the type of an object. Inspection means the ability for external code (outside of the object's methods) to examine the type or properties of that object, and make decisions on how to treat that object based on that information. [...] In classical OOP theory, invocation is the preferred usage pattern, and inspection is actively discouraged, being considered a relic of an earlier, procedural programming style. However, in practice this view is simply too dogmatic and inflexible, and leads to a kind of design rigidity that is very much at odds with the dynamic nature of a language like Python.</em></p>

<p>The author of Python recognizes that forcing the use of a pure polymorphic approach leads sometimes to solutions that are too complex or even incorrect. In this section I want to show some of the problems that can arise from a pure polymorphic approach and introduce Abstract Base Classes, which aim to solve them. I strongly suggest to read <a href="http://legacy.python.org/dev/peps/pep-3119/">PEP 3119</a> (as for any other PEP) since it contains a deeper and better explanation of the whole matter. Indeed I think that this PEP is so well written that any further explanation is hardly needed. I am however used to write explanations to check how much I understood about the topic, so I am going to try it this time too.</p>

<h4>E.A.F.P the Extra Test Trial</h4>

<p>The EAFP coding style requires you to trust the incoming objects to provide the attributes and methods you need, and to manage the possible exceptions, if you know how to do it. Sometimes, however, you need to test if the incoming object matches a complex behaviour. For example, you could be interested in testing if the object <em>acts</em> like a list, but you quickly realize that the amount of methods a <code>list</code> provides is very big and this could lead to odd EAFP code like</p>

<p>``` python
try:</p>

<pre><code>obj.append
obj.count
obj.extend
obj.index
obj.insert
[...]
</code></pre>

<p>except AttributeError:</p>

<pre><code>[...]
</code></pre>

<p>```</p>

<p>where the methods of the <code>list</code> type are accessed (not called) just to force the object to raise the <code>AttributeError</code> exception if they are not present. This code, however, is not only ugly but also wrong. If you recall the "Enter the Composition" section of the <a href="/blog/2014/08/20/python-3-oop-part-3-delegation-composition-and-inheritance">third post</a> of this series, you know that in Python you can always customize the <code>__getattr__()</code> method, which is called whenever the requested attribute is not found in the object. So I could write a class that passes the test but actually does not act like a list</p>

<p>``` python
class FakeList:</p>

<pre><code>def fakemethod(self):
    pass

def __getattr__(self, name):
    if name in ['append', 'count', 'extend', 'index', 'insert', ...]:
        return self.fakemethod
</code></pre>

<p>```</p>

<p>This is obviously just an example, and no one will ever write such a class, but this demonstrates that just accessing methods does not guarantee that a class <em>acts</em> like the one we are expecting.</p>

<p>There are many examples that could be done leveraging the highly dynamic nature of Python and its rich object model. I would summarize them by saying that sometimes you'd better to check the type of the incoming object.</p>

<p>In Python you can obtain the type of an object using the <code>type()</code> built-in function, but to check it you'd better use <code>isinstance()</code>, which returns a boolean value. Let us see an example before moving on</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>isinstance([], list)
True
isinstance(1, int)
True
class Door:
...  pass
...
d = Door()
isinstance(d, Door)
True
class EnhancedDoor(Door):
...  pass
...
ed = EnhancedDoor()
isinstance(ed, EnhancedDoor)
True
isinstance(ed, Door)
True
```</p></blockquote></blockquote></blockquote>

<p>As you can see the function can also walk the class hierarchy, so the check is not so trivial like the one you would obtain by directly using <code>type()</code>.</p>

<p>The <code>isinstance()</code> function, however, does not completely solve the problem. If we write a class that actually <em>acts</em> like a <code>list</code> but does not inherit from it, <code>isinstance()</code> does not recognize the fact that the two may be considered the same thing. The following code returns <code>False</code> regardless the content of the <code>MyList</code> class</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>class MyList:
...  pass
...
ml = MyList()
isinstance(ml, list)
False
```</p></blockquote></blockquote></blockquote>

<p>since <code>isinstance()</code> does not check the content of the class or its behaviour, it just consider the class and its ancestors.</p>

<p>The problem, thus, may be summed up with the following question: what is the best way to test that an object exposes a given interface? Here, the word <em>interface</em> is used for its natural meaning, without any reference to other programming solutions, which however address the same problem.</p>

<p>A good way to address the problem could be to write inside an attribute of the object the list of interfaces it promises to implement, and to agree that any time we want to test the behaviour of an object we simply have to check the content of this attribute. This is exactly the path followed by Python, and it is very important to understand that the whole system is just about a promised behaviour.</p>

<p>The solution proposed through PEP 3119 is, in my opinion, very simple and elegant, and it perfectly fits the nature of Python, where things are usually agreed rather than being enforced. Not only, the solution follows the spirit of polymorphism, where information is provided by the object itself and not extracted by the calling code.</p>

<p>In the next sections I am going to try and describe this solution in its main building blocks. The matter is complex so my explanation will lack some details: please refer to the forementioned PEP 3119 for a complete description.</p>

<h4>Who Framed the Metaclasses</h4>

<p>As already described, Python provides two built-ins to inspect objects and classes, which are <code>isinstance()</code> and <code>issubclass()</code> and it would be desirable that a solution to the inspection problem allows the programmer to go on with using those two functions.</p>

<p>This means that we need to find a way to inject the "behaviour promise" into both classes and instances. This is the reason why metaclasses come in play. Recall what we said about them in the fifth issue of this series: metaclasses are the classes used to build classes, which means that they are the preferred way to change the structure of a class, and, in consequence, of its instances.</p>

<p>Another way to do the same job would be to leverage the inheritance mechanism, injecting the behaviour through a dedicated parent class. This solution has many downsides, which I'm am not going to detail. It is enough to say that affecting the class hierarchy may lead to complex situations or subtle bugs. Metaclasses may provide here a different entry point for the introduction of a "virtual base class" (as PEP 3119 specifies, this is not the same concept as in C++).</p>

<h4>Overriding Places</h4>

<p>As said, <code>isinstance()</code> and <code>issubclass()</code> are built-in functions, not object methods, so we cannot simply override them providing a different implementation in a given class. So the first part of the solution is to change the behaviour of those two functions to first check if the class or the instance contain a special method, which is <code>__instancecheck__()</code> for <code>isinstance()</code> and <code>__subclasscheck__()</code> for <code>issubclass()</code>. So both built-ins try to run the respective special method, reverting to the standard algorithm if it is not present.</p>

<p>A note about naming. Methods must accept the object they belong to as the first argument, so the two special methods shall have the form</p>

<p>``` python
def <strong>instancecheck</strong>(cls, inst):
   [...]</p>

<p>def <strong>subclasscheck</strong>(cls, sub):
   [...]
```</p>

<p>where <code>cls</code> is the class where they are injected, that is the one representing the promised behaviour. The two built-ins, however, have a reversed argument order, where the behaviour comes after the tested object: when you write <code>isinstance([], list)</code> you want to check if the <code>[]</code> instance has the <code>list</code> behaviour. This is the reason behind the name choice: just calling the methods <code>__isinstance__()</code> and <code>__issubclass__()</code> and passing arguments in a reversed order would have been confusing.</p>

<h4>This is ABC</h4>

<p>The proposed solution is thus called Abstract Base Classes, as it provides a way to attach to a concrete class a virtual class with the only purpose of signaling a promised behaviour to anyone inspecting it with <code>isinstance()</code> or <code>issubclass()</code>.</p>

<p>To help programmers implement Abstract Base Classes, the standard library has been given an <code>abc</code> module, thet contains the <code>ABCMeta</code> class (and other facilities). This class is the one that implements <code>__instancecheck__()</code> and <code>__subclasscheck__()</code> and shall be used as a metaclass to augment a standard class. This latter will then be able to register other classes as implementation of its behaviour.</p>

<p>Sounds complex? An example may clarify the whole matter. The one from the official documentation is rather simple:</p>

<p>``` python
from abc import ABCMeta</p>

<p>class MyABC(metaclass=ABCMeta):</p>

<pre><code>pass
</code></pre>

<p>MyABC.register(tuple)</p>

<p>assert issubclass(tuple, MyABC)
assert isinstance((), MyABC)
```</p>

<p>Here, the <code>MyABC</code> class is provided the <code>ABCMeta</code> metaclass. This puts the two <code>__isinstancecheck__()</code> and <code>__subclasscheck__()</code> methods inside <code>MyABC</code> so that, when issuing <code>isinstance()</code>, what Python actually ececutes is</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>d = {'a': 1}
isinstance(d, MyABC)
False
MyABC.<strong>class</strong>.<strong>instancecheck</strong>(MyABC, d)
False
isinstance((), MyABC)
True
MyABC.<strong>class</strong>.<strong>instancecheck</strong>(MyABC, ())
True
```</p></blockquote></blockquote></blockquote>

<p>After the definition of <code>MyABC</code> we need a way to signal that a given class is an instance of the Abstract Base Class and this happens through the <code>register()</code> method, provided by the <code>ABCMeta</code> metaclass. Calling <code>MyABC.register(tuple)</code> we record inside <code>MyABC</code> the fact that the <code>tuple</code> class shall be identified as a subclass of <code>MyABC</code> itself. This is analogous to saying that <code>tuple</code> inherits from <code>MyABC</code> but not quite the same. As already said registering a class in an Abstract Base Class with <code>register()</code> does not affect the class hierarchy. Indeed, the whole <code>tuple</code> class is unchanged.</p>

<p>The current implementation of ABCs stores the registered types inside the <code>_abc_registry</code> attribute. Actually it stores there weak references to the registered types (this part is outside the scope of this article, so I'm not detailing it)</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>MyABC._abc_registry.data
{<weakref at 0xb682966c; to 'type' at 0x83dcca0 (tuple)>}
```</p></blockquote></blockquote></blockquote>

<h2>Movie Trivia</h2>

<p>Section titles come from the following movies: <em>The Breakfast Club (1985)</em>, <em>E.T. the Extra-Terrestrial (1982)</em>, <em>Who Framed Roger Rabbit (1988)</em>, <em>Trading Places (1983)</em>, <em>This is Spinal Tap (1984)</em>.</p>

<h2>Sources</h2>

<p>You will find a lot of documentation in <a href="http://www.reddit.com/r/Python/comments/226ahl/some_links_about_python_oop/">this Reddit post</a>. Most of the information contained in this series come from those sources.</p>

<h2>Feedback</h2>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 3 OOP Part 5 - Metaclasses]]></title>
    <link href="http://lgiordani.com/blog/2014/09/01/python-3-oop-part-5-metaclasses/"/>
    <updated>2014-09-01T15:00:00+02:00</updated>
    <id>http://lgiordani.com/blog/2014/09/01/python-3-oop-part-5-metaclasses</id>
    <content type="html"><![CDATA[<!--more-->


<h2>Previous post</h2>

<p><a href="/blog/2014/08/21/python-3-oop-part-4-polymorphism">Python 3 OOP Part 4 - Polymorphism</a></p>

<h2>The Type Brothers</h2>

<p>The first step into the most intimate secrets of Python objects comes from two components we already met in the first post: <code>class</code> and <code>object</code>. These two things are the very fundamental elements of Python OOP system, so it is worth spending some time to understand how they work and relate each other.</p>

<p>First of all recall that in Python <em>everything is an object</em>, that is everything inherits from <code>object</code>. Thus, <code>object</code> seems to be the deepest thing you can find digging into Python variables. Let's check this</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>a = 5
type(a)
<class 'int'>
a.<strong>class</strong>
<class 'int'>
a.<strong>class</strong>.<strong>bases</strong>
(<class 'object'>,)
object.<strong>bases</strong>
()
```</p></blockquote></blockquote></blockquote>

<p>The variable <code>a</code> is an instance of the <code>int</code> class, and this latter inherits from <code>object</code>, which inherits from nothing. This demonstrates that <code>object</code> is at the top of the class hierarchy. However, as you can see, both <code>int</code> and <code>object</code> are called <em>classes</em> (<code>&lt;class 'int'&gt;</code>, <code>&lt;class 'object'&gt;</code>). Indeed, while <code>a</code> is an instance of the <code>int</code> class, <code>int</code> itself is an instance of another class, <em>a class that is instanced to build classes</em></p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>type(a)
<class 'int'>
type(int)
<class 'type'>
type(float)
<class 'type'>
type(dict)
<class 'type'>
```</p></blockquote></blockquote></blockquote>

<p>Since in Python everything is an object, everything is the instance of a class, even classes. Well, <code>type</code> is the class that is instanced to get classes. So remember this: <code>object</code> is the base of every object, <code>type</code> is the class of every type. Sounds puzzling? It is not your fault, don't worry. However, just to strike you with the finishing move, this is what Python is built on</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>type(object)
<class 'type'>
type.<strong>bases</strong>
(<class 'object'>,)
```</p></blockquote></blockquote></blockquote>

<p>If you are not about to faint at this point chances are that you are Guido van Rossum of one of his friends down at the Python core development team (in this case let me thank you for your beautiful creation). You may get a cup of tea, if you need it.</p>

<p>Jokes apart, at the very base of Python type system there are two things, <code>object</code> and <code>type</code>, which are inseparable. The previous code shows that <code>object</code> is an instance of <code>type</code>, and <code>type</code> inherits from <code>object</code>. Take your time to understand this subtle concept, as it is very important for the upcoming discussion about metaclasses.</p>

<p>When you think you grasped the <code>type</code>/<code>object</code> matter read this and start thinking again</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>type(type)
<class 'type'>
```</p></blockquote></blockquote></blockquote>

<h2>The Metaclasses Take Python</h2>

<p>You are now familiar with Python classes. You know that a class is used to create an instance, and that the structure of this latter is ruled by the source class and all its parent classes (until you reach <code>object</code>).</p>

<p>Since classes are objects too, you know that a class itself is an instance of a (super)class, and this class is <code>type</code>. That is, as already stated, <code>type</code> is the class that is used to build classes.</p>

<p>So for example you know that a class may be instanced, i.e. it can be called and by calling it you obtain another object that is linked with the class. What prepares the class for being called? What gives the class all its methods? In Python the class in charge of performing such tasks is called <em>metaclass</em>, and <code>type</code> is the default metaclass of all classes.</p>

<p>The point of exposing this structure of Python objects is that you may change the way classes are built. As you know, <code>type</code> is an object, so it can be subclassed just like any other class. Once you get a subclass of <code>type</code> you need to instruct your class to use it as the metaclass instead of type, and you can do this by passing it as the <code>metaclass</code> keyword argument in the class definition.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>class MyType(type):
...  pass
...
class MySpecialClass(metaclass=MyType):
...  pass
...
msp = MySpecialClass()
type(msp)
<class '__main__.MySpecialClass'>
type(MySpecialClass)
<class '__main__.MyType'>
type(MyType)
<class 'type'>
```</p></blockquote></blockquote></blockquote>

<h4>Metaclasses 2: Singleton Day</h4>

<p>Metaclasses are a very advanced topic in Python, but they have many practical uses. For example, by means of a custom metaclass you may log any time a class is instanced, which can be important for applications that shall keep a low memory usage or have to monitor it.</p>

<p>I am going to show here a very simple example of metaclass, the Singleton. Singleton is a well known design pattern, and many description of it may be found on the Internet. It has also been heavily criticized mostly because its bad behaviour when subclassed, but here I do not want to introduce it for its technological value, but for its simplicity (so please do not question the choice, it is just an example).</p>

<p>Singleton has one purpose: to return the same instance every time it is instanced, like a sort of object-oriented global variable. So we need to build a class that does not work like standard classes, which return a new instance every time they are called.</p>

<p>"Build a class"? This is a task for metaclasses. The following implementation comes from <a href="http://python-3-patterns-idioms-test.readthedocs.org/en/latest/Metaprogramming.html#intercepting-class-creation">Python 3 Patterns, Recipes and Idioms</a>.</p>

<p>``` python
class Singleton(type):</p>

<pre><code>instance = None
def __call__(cls, *args, **kw):
    if not cls.instance:
         cls.instance = super(Singleton, cls).__call__(*args, **kw)
    return cls.instance
</code></pre>

<p>```</p>

<p>We are defining a new type, which inherits from <code>type</code> to provide all bells and whistles of Python classes. We override the <code>__call__</code> method, that is a special method invoked when we call the class, i.e. when we instance it. The new method wraps the original method of <code>type</code> by calling it only when the <code>instance</code> attribute is not set, i.e. the first time the class is instanced, otherwise it just returns the recorded instance. As you can see this is a very basic cache class, the only trick is that it is applied to the creation of instances.</p>

<p>To test the new type we need to define a new class that uses it as its metaclass</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>class ASingleton(metaclass=Singleton):
...  pass
...
a = ASingleton()
b = ASingleton()
a is b
True
hex(id(a))
'0xb68030ec'
hex(id(b))
'0xb68030ec'
```</p></blockquote></blockquote></blockquote>

<p>By using the <code>is</code> operator we test that the two objects are the very same structure in memory, that is their ids are the same, as explicitly shown. What actually happens is that when you issue <code>a = ASingleton()</code> the <code>ASingleton</code> class runs its <code>__call__()</code> method, which is taken from the <code>Singleton</code> type behind the class. That method recognizes that no instance has been created (<code>Singleton.instance</code> is <code>None</code>) and acts just like any standard class does. When you issue <code>b = ASingleton()</code> the very same things happen, but since <code>Singleton.instance</code> is now different from <code>None</code> its value (the previous instance) is directly returned.</p>

<p>Metaclasses are a very powerful programming tool and leveraging them you can achieve very complex behaviours with a small effort. Their use is a must every time you are actually metaprogramming, that is you are writing code that has to drive the way your code works. Good examples are creational patterns (injecting custom class attributes depending on some configuration), testing, debugging, and performance monitoring.</p>

<h2>Coming to Instance</h2>

<p>Before introducing you to a very smart use of metaclasses by talking about Abstract Base Classes (read: to save some topics for the next part of this series), I want to dive into the object creation procedure in Python, that is what happens when you instance a class. In the first post this procedure was described only partially, by looking at the <code>__init__()</code> method.</p>

<p>In the first post I recalled the object-oriented concept of <em>constructor</em>, which is a special method of the class that is automatically called when the instance is created. The class may also define a destructor, which is called when the object is destroyed. In languages without a garbage collection mechanism such as C++ the destructor shall be carefully designed. In Python the destructor may be defined through the <code>__del__()</code> method, but it is hardly used.</p>

<p>The constructor mechanism in Python is on the contrary very important, and it is implemented by two methods, instead of just one: <code>__new__()</code> and <code>__init__()</code>. The tasks of the two methods are very clear and distinct: <code>__new__()</code> shall perform actions needed when <em>creating</em> a new instance while <code>__init__</code> deals with object <em>initialization</em>.</p>

<p>Since in Python you do not need to declare attributes due to its dynamic nature, <code>__new__()</code> is rarely defined by programmers, who may rely on <code>__init__</code> to perform the majority of the usual tasks. Typical uses of <code>__new__()</code> are very similar to those listed in the previous section, since it allows to trigger some code whenever your class is instanced.</p>

<p>The standard way to override <code>__new__()</code> is</p>

<p>``` python
class MyClass():</p>

<pre><code>def __new__(cls, *args, **kwds):
    obj = super().__new__(cls, *args, **kwds)
    [put your code here]
    return obj
</code></pre>

<p>```</p>

<p>just like you usually do with <code>__init__()</code>. When your class inherits from <code>object</code> you do not need to call the parent method (<code>object.__init__()</code>), because it is empty, but you need to do it when overriding <code>__new__</code>.</p>

<p>Remember that <code>__new__()</code> is not forced to return an instance of the class in which it is defined, even if you shall have very good reasons to break this behaviour. Anyway, <code>__init__()</code> will be called only if you return an instance of the container class. Please also note that <code>__new__()</code>, unlike <code>__init__()</code>, accepts the class as its first parameter. The name is not important in Python, and you can also call it <code>self</code>, but it is worth using <code>cls</code> to remember that it is not an instance.</p>

<h2>Movie Trivia</h2>

<p>Section titles come from the following movies: <em>The Blues Brothers (1980)</em>, <em>The Muppets Take Manhattan (1984)</em>, <em>Terminator 2: Judgement Day (1991)</em>, <em>Coming to America (1988)</em>.</p>

<h2>Sources</h2>

<p>You will find a lot of documentation in <a href="http://www.reddit.com/r/Python/comments/226ahl/some_links_about_python_oop/">this Reddit post</a>. Most of the information contained in this series come from those sources.</p>

<h2>Feedback</h2>

<p>Feel free to use <a href="https://plus.google.com/u/0/b/110554719587236016835/110554719587236016835/posts">the blog Google+ page</a> to comment the post. The <a href="https://github.com/lgiordani/lgiordani.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>

<h2>Next post</h2>

<p><a href="/blog/2014/09/04/python-3-oop-part-6-abstract-base-classes">Python 3 OOP Part 6 - Abstract Base Classes</a></p>
]]></content>
  </entry>
  
</feed>
